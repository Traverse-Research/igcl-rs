/* automatically generated by rust-bindgen 0.71.1 */

pub const CTL_IMPL_MAJOR_VERSION: u32 = 1;
pub const CTL_IMPL_MINOR_VERSION: u32 = 1;
pub const CTL_MAX_DEVICE_NAME_LEN: u32 = 100;
pub const CTL_MAX_RESERVED_SIZE: u32 = 112;
pub const CTL_I2C_MAX_DATA_SIZE: u32 = 128;
pub const CTL_AUX_MAX_DATA_SIZE: u32 = 132;
pub const CTL_MAX_NUM_SAMPLES_PER_CHANNEL_1D_LUT: u32 = 8192;
pub const CTL_MAX_DISPLAYS_FOR_MGPU_COLLAGE: u32 = 16;
pub const CTL_MAX_WIREFORMAT_COLOR_MODELS_SUPPORTED: u32 = 4;
pub const CTL_FAN_TEMP_SPEED_PAIR_COUNT: u32 = 32;
pub const CTL_PSU_COUNT: u32 = 5;
pub const CTL_FAN_COUNT: u32 = 5;
#[doc = "\n @brief Supported initialization flags"]
pub type ctl_init_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_init_flag_t {
    #[doc = "< Use Level0 or not. This is usually required for telemetry,\n< performance, frequency related APIs"]
    CTL_INIT_FLAG_USE_LEVEL_ZERO = 1,
    CTL_INIT_FLAG_MAX = -2147483648,
}
pub use self::_ctl_init_flag_t as ctl_init_flag_t;
#[doc = "\n @brief Version information"]
pub type ctl_version_info_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_api_handle_t {
    _unused: [u8; 0],
}
#[doc = "\n @brief Handle of a control API instance"]
pub type ctl_api_handle_t = *mut _ctl_api_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_device_adapter_handle_t {
    _unused: [u8; 0],
}
#[doc = "\n @brief Handle of a device adapter instance"]
pub type ctl_device_adapter_handle_t = *mut _ctl_device_adapter_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_temp_handle_t {
    _unused: [u8; 0],
}
#[doc = "\n @brief Handle of a device temperature sensor"]
pub type ctl_temp_handle_t = *mut _ctl_temp_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_freq_handle_t {
    _unused: [u8; 0],
}
#[doc = "\n @brief Handle for a device frequency domain"]
pub type ctl_freq_handle_t = *mut _ctl_freq_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_pwr_handle_t {
    _unused: [u8; 0],
}
#[doc = "\n @brief Handle of a power device."]
pub type ctl_pwr_handle_t = *mut _ctl_pwr_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_fan_handle_t {
    _unused: [u8; 0],
}
#[doc = "\n @brief Handle of a device fan"]
pub type ctl_fan_handle_t = *mut _ctl_fan_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_mem_handle_t {
    _unused: [u8; 0],
}
#[doc = "\n @brief Handle of a device memory module"]
pub type ctl_mem_handle_t = *mut _ctl_mem_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_engine_handle_t {
    _unused: [u8; 0],
}
#[doc = "\n @brief Handle of a device engine group"]
pub type ctl_engine_handle_t = *mut _ctl_engine_handle_t;
#[doc = "\n @brief Base for all properties types"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_base_interface_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
}
#[doc = "\n @brief Base for all properties types"]
pub type ctl_base_interface_t = _ctl_base_interface_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Value type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_property_value_type_t {
    #[doc = "< Boolean"]
    CTL_PROPERTY_VALUE_TYPE_BOOL = 0,
    #[doc = "< Float"]
    CTL_PROPERTY_VALUE_TYPE_FLOAT = 1,
    #[doc = "< Int32"]
    CTL_PROPERTY_VALUE_TYPE_INT32 = 2,
    #[doc = "< Unsigned Int32"]
    CTL_PROPERTY_VALUE_TYPE_UINT32 = 3,
    #[doc = "< Enum"]
    CTL_PROPERTY_VALUE_TYPE_ENUM = 4,
    #[doc = "< Custom argument"]
    CTL_PROPERTY_VALUE_TYPE_CUSTOM = 5,
    CTL_PROPERTY_VALUE_TYPE_MAX = 6,
}
#[doc = "\n @brief Value type"]
pub use self::_ctl_property_value_type_t as ctl_property_value_type_t;
#[doc = "\n @brief Property range details, a generic struct to hold min/max/step size\n        information of various feature properties"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_property_range_info_t {
    #[doc = "< [out] Minimum possible value"]
    pub min_possible_value: f32,
    #[doc = "< [out] Maximum possible value"]
    pub max_possible_value: f32,
    #[doc = "< [out] Step size possible"]
    pub step_size: f32,
    #[doc = "< [out] Default value"]
    pub default_value: f32,
}
#[doc = "\n @brief Property range details, a generic struct to hold min/max/step size\n        information of various feature properties"]
pub type ctl_property_range_info_t = _ctl_property_range_info_t;
#[doc = "\n @brief Property range details of integer type, a generic struct to hold\n        min/max/step size information of various feature properties"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_property_range_info_int_t {
    #[doc = "< [out] Minimum possible value"]
    pub min_possible_value: i32,
    #[doc = "< [out] Maximum possible value"]
    pub max_possible_value: i32,
    #[doc = "< [out] Step size possible"]
    pub step_size: i32,
    #[doc = "< [out] Default value"]
    pub default_value: i32,
}
#[doc = "\n @brief Property range details of integer type, a generic struct to hold\n        min/max/step size information of various feature properties"]
pub type ctl_property_range_info_int_t = _ctl_property_range_info_int_t;
#[doc = "\n @brief Property range details of unsigned integer type, a generic struct to\n        hold min/max/step size information of various feature properties"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_property_range_info_uint_t {
    #[doc = "< [out] Minimum possible value"]
    pub min_possible_value: u32,
    #[doc = "< [out] Maximum possible value"]
    pub max_possible_value: u32,
    #[doc = "< [out] Step size possible"]
    pub step_size: u32,
    #[doc = "< [out] Default value"]
    pub default_value: u32,
}
#[doc = "\n @brief Property range details of unsigned integer type, a generic struct to\n        hold min/max/step size information of various feature properties"]
pub type ctl_property_range_info_uint_t = _ctl_property_range_info_uint_t;
#[doc = "\n @brief Bool feature details"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_property_info_boolean_t {
    #[doc = "< [out] Default state"]
    pub DefaultState: bool,
}
#[doc = "\n @brief Bool feature details"]
pub type ctl_property_info_boolean_t = _ctl_property_info_boolean_t;
#[doc = "\n @brief Bool feature for get/set"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_property_boolean_t {
    #[doc = "< [in,out] Enable"]
    pub Enable: bool,
}
#[doc = "\n @brief Bool feature for get/set"]
pub type ctl_property_boolean_t = _ctl_property_boolean_t;
#[doc = "\n @brief Enumeration feature details"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_property_info_enum_t {
    #[doc = "< [out] Supported possible values represented as a bitmask"]
    pub SupportedTypes: u64,
    #[doc = "< [out] Default type"]
    pub DefaultType: u32,
}
#[doc = "\n @brief Enumeration feature details"]
pub type ctl_property_info_enum_t = _ctl_property_info_enum_t;
#[doc = "\n @brief Enumeration feature for get/set"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_property_enum_t {
    #[doc = "< [in,out] Enable with specific type"]
    pub EnableType: u32,
}
#[doc = "\n @brief Enumeration feature for get/set"]
pub type ctl_property_enum_t = _ctl_property_enum_t;
#[doc = "\n @brief Float feature details"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_property_info_float_t {
    #[doc = "< [in,out] DefaultEnable"]
    pub DefaultEnable: bool,
    #[doc = "< [out] Min/max/default/step details"]
    pub RangeInfo: ctl_property_range_info_t,
}
#[doc = "\n @brief Float feature details"]
pub type ctl_property_info_float_t = _ctl_property_info_float_t;
#[doc = "\n @brief Float feature for get/set"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_property_float_t {
    #[doc = "< [in,out] Enable"]
    pub Enable: bool,
    #[doc = "< [in,out] Value"]
    pub Value: f32,
}
#[doc = "\n @brief Float feature for get/set"]
pub type ctl_property_float_t = _ctl_property_float_t;
#[doc = "\n @brief Int32 feature details"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_property_info_int_t {
    #[doc = "< [in,out] DefaultEnable"]
    pub DefaultEnable: bool,
    #[doc = "< [out] Min/max/default/step details"]
    pub RangeInfo: ctl_property_range_info_int_t,
}
#[doc = "\n @brief Int32 feature details"]
pub type ctl_property_info_int_t = _ctl_property_info_int_t;
#[doc = "\n @brief Int32 feature for get/set"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_property_int_t {
    #[doc = "< [in,out] Enable"]
    pub Enable: bool,
    #[doc = "< [in,out] Value"]
    pub Value: i32,
}
#[doc = "\n @brief Int32 feature for get/set"]
pub type ctl_property_int_t = _ctl_property_int_t;
#[doc = "\n @brief Int32 feature details"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_property_info_uint_t {
    #[doc = "< [in,out] DefaultEnable"]
    pub DefaultEnable: bool,
    #[doc = "< [out] Min/max/default/step details"]
    pub RangeInfo: ctl_property_range_info_uint_t,
}
#[doc = "\n @brief Int32 feature details"]
pub type ctl_property_info_uint_t = _ctl_property_info_uint_t;
#[doc = "\n @brief Int32 feature for get/set"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_property_uint_t {
    #[doc = "< [in,out] Enable"]
    pub Enable: bool,
    #[doc = "< [in,out] Value"]
    pub Value: u32,
}
#[doc = "\n @brief Int32 feature for get/set"]
pub type ctl_property_uint_t = _ctl_property_uint_t;
#[doc = "\n @brief Feature element details, union of bool/float/enum property_info\n        structs. Used for feature specific capability check"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ctl_property_info_t {
    #[doc = "< [in,out] Boolean type fields"]
    pub BoolType: ctl_property_info_boolean_t,
    #[doc = "< [in,out] Float type fields"]
    pub FloatType: ctl_property_info_float_t,
    #[doc = "< [in,out] Int type fields"]
    pub IntType: ctl_property_info_int_t,
    #[doc = "< [in,out] Enum type fields"]
    pub EnumType: ctl_property_info_enum_t,
    #[doc = "< [in,out] Unsigned Int type fields"]
    pub UIntType: ctl_property_info_uint_t,
}
impl Default for _ctl_property_info_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _ctl_property_info_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_ctl_property_info_t {{ union }}")
    }
}
#[doc = "\n @brief Feature element details, union of bool/float/enum property_info\n        structs. Used for feature specific capability check"]
pub type ctl_property_info_t = _ctl_property_info_t;
#[doc = "\n @brief Feature element details, union of bool/float/enum property structs.\n        Used for get/set calls"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ctl_property_t {
    #[doc = "< [in,out] Boolean type fields"]
    pub BoolType: ctl_property_boolean_t,
    #[doc = "< [in,out] Float type fields"]
    pub FloatType: ctl_property_float_t,
    #[doc = "< [in,out] Int type fields"]
    pub IntType: ctl_property_int_t,
    #[doc = "< [in,out] Enum type fields"]
    pub EnumType: ctl_property_enum_t,
    #[doc = "< [in,out] Unsigned Int type fields"]
    pub UIntType: ctl_property_uint_t,
}
impl Default for _ctl_property_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _ctl_property_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_ctl_property_t {{ union }}")
    }
}
#[doc = "\n @brief Feature element details, union of bool/float/enum property structs.\n        Used for get/set calls"]
pub type ctl_property_t = _ctl_property_t;
impl _ctl_result_t {
    pub const CTL_RESULT_ERROR_GENERIC_END: _ctl_result_t = _ctl_result_t::CTL_RESULT_ERROR_UNKNOWN;
}
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Defines Return/Error codes.\n        All generic error (bit30) codes are between 0x40000000-0x4000FFFF.\n        All 3D (bit 29) specific error codes are between 0x60000000-0x6000FFFF.\n        All media (bit 28) specific error codes are between 0x50000000-0x5000FFFF.\n        All display (bit 27) specific error codes are between 0x48000000-0x4800FFFF\n        All core (bit 26) specific error codes are between 0x44000000-0x4400FFFF\n        Success result code with additional info are between 0x00000001-0x0000FFFF."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_result_t {
    #[doc = "< success"]
    CTL_RESULT_SUCCESS = 0,
    #[doc = "< success but still open by another caller"]
    CTL_RESULT_SUCCESS_STILL_OPEN_BY_ANOTHER_CALLER = 1,
    #[doc = "< \"Success group error code end value, not to be used\n< \""]
    CTL_RESULT_ERROR_SUCCESS_END = 65535,
    #[doc = "< Generic error code starting value, not to be used"]
    CTL_RESULT_ERROR_GENERIC_START = 1073741824,
    #[doc = "< Result not initialized"]
    CTL_RESULT_ERROR_NOT_INITIALIZED = 1073741825,
    #[doc = "< Already initialized"]
    CTL_RESULT_ERROR_ALREADY_INITIALIZED = 1073741826,
    #[doc = "< Device hung, reset, was removed, or driver update occurred"]
    CTL_RESULT_ERROR_DEVICE_LOST = 1073741827,
    #[doc = "< Insufficient host memory to satisfy call"]
    CTL_RESULT_ERROR_OUT_OF_HOST_MEMORY = 1073741828,
    #[doc = "< Insufficient device memory to satisfy call"]
    CTL_RESULT_ERROR_OUT_OF_DEVICE_MEMORY = 1073741829,
    #[doc = "< Access denied due to permission level"]
    CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS = 1073741830,
    #[doc = "< Resource was removed"]
    CTL_RESULT_ERROR_NOT_AVAILABLE = 1073741831,
    #[doc = "< Library not initialized"]
    CTL_RESULT_ERROR_UNINITIALIZED = 1073741832,
    #[doc = "< Generic error code for unsupported versions"]
    CTL_RESULT_ERROR_UNSUPPORTED_VERSION = 1073741833,
    #[doc = "< Generic error code for unsupported features"]
    CTL_RESULT_ERROR_UNSUPPORTED_FEATURE = 1073741834,
    #[doc = "< Generic error code for invalid arguments"]
    CTL_RESULT_ERROR_INVALID_ARGUMENT = 1073741835,
    #[doc = "< API handle in invalid"]
    CTL_RESULT_ERROR_INVALID_API_HANDLE = 1073741836,
    #[doc = "< Handle argument is not valid"]
    CTL_RESULT_ERROR_INVALID_NULL_HANDLE = 1073741837,
    #[doc = "< Pointer argument may not be nullptr"]
    CTL_RESULT_ERROR_INVALID_NULL_POINTER = 1073741838,
    #[doc = "< Size argument is invalid (e.g., must not be zero)"]
    CTL_RESULT_ERROR_INVALID_SIZE = 1073741839,
    #[doc = "< Size argument is not supported by the device (e.g., too large)"]
    CTL_RESULT_ERROR_UNSUPPORTED_SIZE = 1073741840,
    #[doc = "< Image format is not supported by the device"]
    CTL_RESULT_ERROR_UNSUPPORTED_IMAGE_FORMAT = 1073741841,
    #[doc = "< Data read error"]
    CTL_RESULT_ERROR_DATA_READ = 1073741842,
    #[doc = "< Data write error"]
    CTL_RESULT_ERROR_DATA_WRITE = 1073741843,
    #[doc = "< Data not found error"]
    CTL_RESULT_ERROR_DATA_NOT_FOUND = 1073741844,
    #[doc = "< Function not implemented"]
    CTL_RESULT_ERROR_NOT_IMPLEMENTED = 1073741845,
    #[doc = "< Operating system call failure"]
    CTL_RESULT_ERROR_OS_CALL = 1073741846,
    #[doc = "< Kernel mode driver call failure"]
    CTL_RESULT_ERROR_KMD_CALL = 1073741847,
    #[doc = "< Library unload failure"]
    CTL_RESULT_ERROR_UNLOAD = 1073741848,
    #[doc = "< Level0 loader not found"]
    CTL_RESULT_ERROR_ZE_LOADER = 1073741849,
    #[doc = "< Invalid operation type"]
    CTL_RESULT_ERROR_INVALID_OPERATION_TYPE = 1073741850,
    #[doc = "< Null OS interface"]
    CTL_RESULT_ERROR_NULL_OS_INTERFACE = 1073741851,
    #[doc = "< Null OS adapter handle"]
    CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE = 1073741852,
    #[doc = "< Null display output handle"]
    CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE = 1073741853,
    #[doc = "< Timeout in Wait function"]
    CTL_RESULT_ERROR_WAIT_TIMEOUT = 1073741854,
    #[doc = "< Persistance not supported"]
    CTL_RESULT_ERROR_PERSISTANCE_NOT_SUPPORTED = 1073741855,
    #[doc = "< Platform not supported"]
    CTL_RESULT_ERROR_PLATFORM_NOT_SUPPORTED = 1073741856,
    #[doc = "< Unknown Appplicaion UID in Initialization call"]
    CTL_RESULT_ERROR_UNKNOWN_APPLICATION_UID = 1073741857,
    #[doc = "< The enum is not valid"]
    CTL_RESULT_ERROR_INVALID_ENUMERATION = 1073741858,
    #[doc = "< Error in file delete operation"]
    CTL_RESULT_ERROR_FILE_DELETE = 1073741859,
    #[doc = "< The device requires a reset."]
    CTL_RESULT_ERROR_RESET_DEVICE_REQUIRED = 1073741860,
    #[doc = "< The device requires a full reboot."]
    CTL_RESULT_ERROR_FULL_REBOOT_REQUIRED = 1073741861,
    #[doc = "< Library load failure"]
    CTL_RESULT_ERROR_LOAD = 1073741862,
    #[doc = "< Unknown or internal error"]
    CTL_RESULT_ERROR_UNKNOWN = 1073807359,
    #[doc = "< Operation failed, retry previous operation again"]
    CTL_RESULT_ERROR_RETRY_OPERATION = 1073807360,
    #[doc = "< Core error code starting value, not to be used"]
    CTL_RESULT_ERROR_CORE_START = 1140850688,
    #[doc = "< The Overclock is not supported."]
    CTL_RESULT_ERROR_CORE_OVERCLOCK_NOT_SUPPORTED = 1140850689,
    #[doc = "< The Voltage exceeds the acceptable min/max."]
    CTL_RESULT_ERROR_CORE_OVERCLOCK_VOLTAGE_OUTSIDE_RANGE = 1140850690,
    #[doc = "< The Frequency exceeds the acceptable min/max."]
    CTL_RESULT_ERROR_CORE_OVERCLOCK_FREQUENCY_OUTSIDE_RANGE = 1140850691,
    #[doc = "< The Power exceeds the acceptable min/max."]
    CTL_RESULT_ERROR_CORE_OVERCLOCK_POWER_OUTSIDE_RANGE = 1140850692,
    #[doc = "< The Temperature exceeds the acceptable min/max."]
    CTL_RESULT_ERROR_CORE_OVERCLOCK_TEMPERATURE_OUTSIDE_RANGE = 1140850693,
    #[doc = "< The Overclock is in voltage locked mode."]
    CTL_RESULT_ERROR_CORE_OVERCLOCK_IN_VOLTAGE_LOCKED_MODE = 1140850694,
    #[doc = "< It indicates that the requested change will not be applied until the\n< device is reset."]
    CTL_RESULT_ERROR_CORE_OVERCLOCK_RESET_REQUIRED = 1140850695,
    #[doc = "< The $OverclockWaiverSet function has not been called."]
    CTL_RESULT_ERROR_CORE_OVERCLOCK_WAIVER_NOT_SET = 1140850696,
    #[doc = "< The error indicates to switch to newer API version if applicable."]
    CTL_RESULT_ERROR_CORE_OVERCLOCK_DEPRECATED_API = 1140850697,
    #[doc = "< \"Core error code end value, not to be used\n< \""]
    CTL_RESULT_ERROR_CORE_END = 71368703,
    #[doc = "< 3D error code starting value, not to be used"]
    CTL_RESULT_ERROR_3D_START = 1610612736,
    #[doc = "< \"3D error code end value, not to be used\n< \""]
    CTL_RESULT_ERROR_3D_END = 1610678271,
    #[doc = "< Media error code starting value, not to be used"]
    CTL_RESULT_ERROR_MEDIA_START = 1342177280,
    #[doc = "< \"Media error code end value, not to be used\n< \""]
    CTL_RESULT_ERROR_MEDIA_END = 1342242815,
    #[doc = "< Display error code starting value, not to be used"]
    CTL_RESULT_ERROR_DISPLAY_START = 1207959552,
    #[doc = "< Invalid flag for Aux access"]
    CTL_RESULT_ERROR_INVALID_AUX_ACCESS_FLAG = 1207959553,
    #[doc = "< Invalid flag for Sharpness"]
    CTL_RESULT_ERROR_INVALID_SHARPNESS_FILTER_FLAG = 1207959554,
    #[doc = "< Error for Display not attached"]
    CTL_RESULT_ERROR_DISPLAY_NOT_ATTACHED = 1207959555,
    #[doc = "< Error for display attached but not active"]
    CTL_RESULT_ERROR_DISPLAY_NOT_ACTIVE = 1207959556,
    #[doc = "< Error for invalid power optimization flag"]
    CTL_RESULT_ERROR_INVALID_POWERFEATURE_OPTIMIZATION_FLAG = 1207959557,
    #[doc = "< DPST is supported only in DC Mode"]
    CTL_RESULT_ERROR_INVALID_POWERSOURCE_TYPE_FOR_DPST = 1207959558,
    #[doc = "< Invalid query type for pixel transformation get configuration"]
    CTL_RESULT_ERROR_INVALID_PIXTX_GET_CONFIG_QUERY_TYPE = 1207959559,
    #[doc = "< Invalid operation type for pixel transformation set configuration"]
    CTL_RESULT_ERROR_INVALID_PIXTX_SET_CONFIG_OPERATION_TYPE = 1207959560,
    #[doc = "< Invalid number of samples for pixel transformation set configuration"]
    CTL_RESULT_ERROR_INVALID_SET_CONFIG_NUMBER_OF_SAMPLES = 1207959561,
    #[doc = "< Invalid block id for pixel transformation"]
    CTL_RESULT_ERROR_INVALID_PIXTX_BLOCK_ID = 1207959562,
    #[doc = "< Invalid block type for pixel transformation"]
    CTL_RESULT_ERROR_INVALID_PIXTX_BLOCK_TYPE = 1207959563,
    #[doc = "< Invalid block number for pixel transformation"]
    CTL_RESULT_ERROR_INVALID_PIXTX_BLOCK_NUMBER = 1207959564,
    #[doc = "< Insufficient memery allocated for BlockConfigs"]
    CTL_RESULT_ERROR_INSUFFICIENT_PIXTX_BLOCK_CONFIG_MEMORY = 1207959565,
    #[doc = "< Invalid pipe for 3dlut"]
    CTL_RESULT_ERROR_3DLUT_INVALID_PIPE = 1207959566,
    #[doc = "< Invalid 3dlut data"]
    CTL_RESULT_ERROR_3DLUT_INVALID_DATA = 1207959567,
    #[doc = "< 3dlut not supported in HDR"]
    CTL_RESULT_ERROR_3DLUT_NOT_SUPPORTED_IN_HDR = 1207959568,
    #[doc = "< Invalid 3dlut operation"]
    CTL_RESULT_ERROR_3DLUT_INVALID_OPERATION = 1207959569,
    #[doc = "< 3dlut call unsuccessful"]
    CTL_RESULT_ERROR_3DLUT_UNSUCCESSFUL = 1207959570,
    #[doc = "< AUX defer failure"]
    CTL_RESULT_ERROR_AUX_DEFER = 1207959571,
    #[doc = "< AUX timeout failure"]
    CTL_RESULT_ERROR_AUX_TIMEOUT = 1207959572,
    #[doc = "< AUX incomplete write failure"]
    CTL_RESULT_ERROR_AUX_INCOMPLETE_WRITE = 1207959573,
    #[doc = "< I2C/AUX unkonown failure"]
    CTL_RESULT_ERROR_I2C_AUX_STATUS_UNKNOWN = 1207959574,
    #[doc = "< I2C/AUX unsuccessful"]
    CTL_RESULT_ERROR_I2C_AUX_UNSUCCESSFUL = 1207959575,
    #[doc = "< Lace Incorrrect AggressivePercent data or LuxVsAggressive Map data\n< passed by user"]
    CTL_RESULT_ERROR_LACE_INVALID_DATA_ARGUMENT_PASSED = 1207959576,
    #[doc = "< External Display is Attached hence fail the Display Switch"]
    CTL_RESULT_ERROR_EXTERNAL_DISPLAY_ATTACHED = 1207959577,
    #[doc = "< Standard custom mode exists"]
    CTL_RESULT_ERROR_CUSTOM_MODE_STANDARD_CUSTOM_MODE_EXISTS = 1207959578,
    #[doc = "< Non custom matching mode exists"]
    CTL_RESULT_ERROR_CUSTOM_MODE_NON_CUSTOM_MATCHING_MODE_EXISTS = 1207959579,
    #[doc = "< Custom mode insufficent memory"]
    CTL_RESULT_ERROR_CUSTOM_MODE_INSUFFICIENT_MEMORY = 1207959580,
    #[doc = "< Adapter is already linked"]
    CTL_RESULT_ERROR_ADAPTER_ALREADY_LINKED = 1207959581,
    #[doc = "< Adapter is not identical for linking"]
    CTL_RESULT_ERROR_ADAPTER_NOT_IDENTICAL = 1207959582,
    #[doc = "< Adapter is LDA Secondary, so not supporting requested operation"]
    CTL_RESULT_ERROR_ADAPTER_NOT_SUPPORTED_ON_LDA_SECONDARY = 1207959583,
    #[doc = "< Set FBC Feature not supported"]
    CTL_RESULT_ERROR_SET_FBC_FEATURE_NOT_SUPPORTED = 1207959584,
    #[doc = "< \"Display error code end value, not to be used\n< \""]
    CTL_RESULT_ERROR_DISPLAY_END = 1208025087,
    CTL_RESULT_MAX = 1208025088,
}
#[doc = "\n @brief Defines Return/Error codes.\n        All generic error (bit30) codes are between 0x40000000-0x4000FFFF.\n        All 3D (bit 29) specific error codes are between 0x60000000-0x6000FFFF.\n        All media (bit 28) specific error codes are between 0x50000000-0x5000FFFF.\n        All display (bit 27) specific error codes are between 0x48000000-0x4800FFFF\n        All core (bit 26) specific error codes are between 0x44000000-0x4400FFFF\n        Success result code with additional info are between 0x00000001-0x0000FFFF."]
pub use self::_ctl_result_t as ctl_result_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief General Physical Units."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_units_t {
    #[doc = "< Type is Frequency with units in MHz."]
    CTL_UNITS_FREQUENCY_MHZ = 0,
    #[doc = "< Type is Frequency with units in GT/s (gigatransfers per second)."]
    CTL_UNITS_OPERATIONS_GTS = 1,
    #[doc = "< Type is Frequency with units in MT/s (megatransfers per second)."]
    CTL_UNITS_OPERATIONS_MTS = 2,
    #[doc = "< Type is Voltage with units in Volts."]
    CTL_UNITS_VOLTAGE_VOLTS = 3,
    #[doc = "< Type is Power with units in Watts."]
    CTL_UNITS_POWER_WATTS = 4,
    #[doc = "< Type is Temperature with units in Celsius."]
    CTL_UNITS_TEMPERATURE_CELSIUS = 5,
    #[doc = "< Type is Energy with units in Joules."]
    CTL_UNITS_ENERGY_JOULES = 6,
    #[doc = "< Type is Time with units in Seconds."]
    CTL_UNITS_TIME_SECONDS = 7,
    #[doc = "< Type is Memory with units in Bytes."]
    CTL_UNITS_MEMORY_BYTES = 8,
    #[doc = "< Type is Angular Speed with units in Revolutions per Minute."]
    CTL_UNITS_ANGULAR_SPEED_RPM = 9,
    #[doc = "< Type is Power with units in MilliWatts."]
    CTL_UNITS_POWER_MILLIWATTS = 10,
    #[doc = "< Type is Percentage."]
    CTL_UNITS_PERCENT = 11,
    #[doc = "< Type is Memory Speed in Gigabyte per Seconds (Gbps)"]
    CTL_UNITS_MEM_SPEED_GBPS = 12,
    #[doc = "< Type is Voltage with units in milliVolts."]
    CTL_UNITS_VOLTAGE_MILLIVOLTS = 13,
    #[doc = "< Type of units unknown."]
    CTL_UNITS_UNKNOWN = 1208025087,
    CTL_UNITS_MAX = 1208025088,
}
#[doc = "\n @brief General Physical Units."]
pub use self::_ctl_units_t as ctl_units_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief General Data Types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_data_type_t {
    #[doc = "< The data type is 8 bit signed integer."]
    CTL_DATA_TYPE_INT8 = 0,
    #[doc = "< The data type is 8 bit unsigned integer."]
    CTL_DATA_TYPE_UINT8 = 1,
    #[doc = "< The data type is 16 bit signed integer."]
    CTL_DATA_TYPE_INT16 = 2,
    #[doc = "< The data type is 16 bit unsigned integer."]
    CTL_DATA_TYPE_UINT16 = 3,
    #[doc = "< The data type is 32 bit signed integer."]
    CTL_DATA_TYPE_INT32 = 4,
    #[doc = "< The data type is 32 bit unsigned integer."]
    CTL_DATA_TYPE_UINT32 = 5,
    #[doc = "< The data type is 64 bit signed integer."]
    CTL_DATA_TYPE_INT64 = 6,
    #[doc = "< The data type is 64 bit unsigned integer."]
    CTL_DATA_TYPE_UINT64 = 7,
    #[doc = "< The data type is 32 bit floating point."]
    CTL_DATA_TYPE_FLOAT = 8,
    #[doc = "< The data type is 64 bit floating point."]
    CTL_DATA_TYPE_DOUBLE = 9,
    #[doc = "< The data type is an array of 8 bit unsigned integers."]
    CTL_DATA_TYPE_STRING_ASCII = 10,
    #[doc = "< The data type is an array of 16 bit unsigned integers."]
    CTL_DATA_TYPE_STRING_UTF16 = 11,
    #[doc = "< The data type is an array of 32 bit unsigned integers."]
    CTL_DATA_TYPE_STRING_UTF132 = 12,
    #[doc = "< The data type is unknown."]
    CTL_DATA_TYPE_UNKNOWN = 1208025087,
    CTL_DATA_TYPE_MAX = 1208025088,
}
#[doc = "\n @brief General Data Types."]
pub use self::_ctl_data_type_t as ctl_data_type_t;
#[doc = "\n @brief Union for Generic Data.\n\n @details\n     - The telemetry data items could be of different types.\n     - Refer to ::ctl_data_type_t to find the current type."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ctl_data_value_t {
    #[doc = "< [out] The data type is 8 bit signed integer."]
    pub data8: i8,
    #[doc = "< [out] The data type is 8 bit unsigned integer."]
    pub datau8: u8,
    #[doc = "< [out] The data type is 16 bit signed integer."]
    pub data16: i16,
    #[doc = "< [out] The data type is 16 bit unsigned integer."]
    pub datau16: u16,
    #[doc = "< [out] The data type is 32 bit signed integer."]
    pub data32: i32,
    #[doc = "< [out] The data type is 32 bit unsigned integer."]
    pub datau32: u32,
    #[doc = "< [out] The data type is 64 bit signed integer."]
    pub data64: i64,
    #[doc = "< [out] The data type is 64 bit unsigned integer."]
    pub datau64: u64,
    #[doc = "< [out] The data type is 32 bit floating point."]
    pub datafloat: f32,
    #[doc = "< [out] The data type is 64 bit floating point."]
    pub datadouble: f64,
}
impl Default for _ctl_data_value_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _ctl_data_value_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_ctl_data_value_t {{ union }}")
    }
}
#[doc = "\n @brief Union for Generic Data.\n\n @details\n     - The telemetry data items could be of different types.\n     - Refer to ::ctl_data_type_t to find the current type."]
pub type ctl_data_value_t = _ctl_data_value_t;
#[doc = "\n @brief Base for all properties types"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_base_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
}
#[doc = "\n @brief Base for all properties types"]
pub type ctl_base_properties_t = _ctl_base_properties_t;
#[doc = "\n @brief Application Unique ID"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_application_id_t {
    #[doc = "< [in] Data1"]
    pub Data1: u32,
    #[doc = "< [in] Data2"]
    pub Data2: u16,
    #[doc = "< [in] Data3"]
    pub Data3: u16,
    #[doc = "< [in] Data4"]
    pub Data4: [u8; 8usize],
}
#[doc = "\n @brief Application Unique ID"]
pub type ctl_application_id_t = _ctl_application_id_t;
#[doc = "\n @brief Init arguments"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_init_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in][release] App's IGCL version"]
    pub AppVersion: ctl_version_info_t,
    #[doc = "< [in][release] Caller version"]
    pub flags: ctl_init_flags_t,
    #[doc = "< [out][release] IGCL implementation version"]
    pub SupportedVersion: ctl_version_info_t,
    #[doc = "< [in] Application Provided Unique ID.Application can pass all 0's as\n< the default ID"]
    pub ApplicationUID: ctl_application_id_t,
}
#[doc = "\n @brief Init arguments"]
pub type ctl_init_args_t = _ctl_init_args_t;
#[doc = "\n @brief Reserved struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_reserved_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Reserved struct"]
    pub pSpecialArg: *mut ::std::os::raw::c_void,
    #[doc = "< [in] struct size"]
    pub ArgSize: u32,
}
impl Default for _ctl_reserved_args_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Reserved struct"]
pub type ctl_reserved_args_t = _ctl_reserved_args_t;
#[doc = "\n @brief Reserved base struct"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_reserved_args_base_t {
    #[doc = "< [in] Unique ID for reserved/special function"]
    pub ReservedFuncID: ctl_application_id_t,
}
#[doc = "\n @brief Reserved base struct"]
pub type ctl_reserved_args_base_t = _ctl_reserved_args_base_t;
#[doc = "\n @brief Reserved - Unlock function capability"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_unlock_capability_t {
    #[doc = "< [in] Unique ID for reserved/special function"]
    pub ReservedFuncID: ctl_application_id_t,
    #[doc = "< [in] Unique ID to unlock a specific function"]
    pub UnlockCapsID: ctl_application_id_t,
}
#[doc = "\n @brief Reserved - Unlock function capability"]
pub type ctl_unlock_capability_t = _ctl_unlock_capability_t;
#[doc = "\n @brief Used by loader like modules to specify runtime implementation details"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_runtime_path_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Unique ID for reserved/special function"]
    pub UnlockID: ctl_application_id_t,
    #[doc = "< [in] Path to runtime DLL"]
    pub pRuntimePath: *mut u16,
    #[doc = "< [in] Device ID of interest to caller. pRuntimePath should not be NULL."]
    pub DeviceID: u16,
    #[doc = "< [in] Revision ID of interest to caller. pRuntimePath should not be\n< NULL."]
    pub RevID: u8,
}
impl Default for _ctl_runtime_path_args_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Used by loader like modules to specify runtime implementation details"]
pub type ctl_runtime_path_args_t = _ctl_runtime_path_args_t;
#[doc = "\n @brief Supported Functions"]
pub type ctl_supported_functions_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_supported_functions_flag_t {
    #[doc = "< [out] Is Display supported"]
    CTL_SUPPORTED_FUNCTIONS_FLAG_DISPLAY = 1,
    #[doc = "< [out] Is 3D supported"]
    CTL_SUPPORTED_FUNCTIONS_FLAG_3D = 2,
    #[doc = "< [out] Is Media supported"]
    CTL_SUPPORTED_FUNCTIONS_FLAG_MEDIA = 4,
    CTL_SUPPORTED_FUNCTIONS_FLAG_MAX = -2147483648,
}
pub use self::_ctl_supported_functions_flag_t as ctl_supported_functions_flag_t;
#[doc = "\n @brief Firmware version"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_firmware_version_t {
    #[doc = "< [out] Major version"]
    pub major_version: u64,
    #[doc = "< [out] Minor version"]
    pub minor_version: u64,
    #[doc = "< [out] Build number"]
    pub build_number: u64,
}
#[doc = "\n @brief Firmware version"]
pub type ctl_firmware_version_t = _ctl_firmware_version_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief DeviceType"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_device_type_t {
    #[doc = "< Graphics Device type"]
    CTL_DEVICE_TYPE_GRAPHICS = 1,
    #[doc = "< System Device type"]
    CTL_DEVICE_TYPE_SYSTEM = 2,
    CTL_DEVICE_TYPE_MAX = 3,
}
#[doc = "\n @brief DeviceType"]
pub use self::_ctl_device_type_t as ctl_device_type_t;
#[doc = "\n @brief Adapter Properties"]
pub type ctl_adapter_properties_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_adapter_properties_flag_t {
    #[doc = "< [out] Is Integrated Graphics adapter"]
    CTL_ADAPTER_PROPERTIES_FLAG_INTEGRATED = 1,
    #[doc = "< [out] Is Primary (Lead) adapter in a Linked Display Adapter (LDA)\n< chain"]
    CTL_ADAPTER_PROPERTIES_FLAG_LDA_PRIMARY = 2,
    #[doc = "< [out] Is Secondary (Linked) adapter in a Linked Display Adapter (LDA)\n< chain"]
    CTL_ADAPTER_PROPERTIES_FLAG_LDA_SECONDARY = 4,
    CTL_ADAPTER_PROPERTIES_FLAG_MAX = -2147483648,
}
pub use self::_ctl_adapter_properties_flag_t as ctl_adapter_properties_flag_t;
#[doc = "\n @brief Adapter Pci Bus, Device, Function"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_adapter_bdf_t {
    #[doc = "< [out] PCI Bus Number"]
    pub bus: u8,
    #[doc = "< [out] PCI device number"]
    pub device: u8,
    #[doc = "< [out] PCI function"]
    pub function: u8,
}
#[doc = "\n @brief Adapter Pci Bus, Device, Function"]
pub type ctl_adapter_bdf_t = _ctl_adapter_bdf_t;
#[doc = "\n @brief Device Adapter properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_device_adapter_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] OS specific Device ID"]
    pub pDeviceID: *mut ::std::os::raw::c_void,
    #[doc = "< [in] size of the device ID"]
    pub device_id_size: u32,
    #[doc = "< [out] Device Type"]
    pub device_type: ctl_device_type_t,
    #[doc = "< [out] Supported functions"]
    pub supported_subfunction_flags: ctl_supported_functions_flags_t,
    #[doc = "< [out] Driver version"]
    pub driver_version: u64,
    #[doc = "< [out] Firmware version"]
    pub firmware_version: ctl_firmware_version_t,
    #[doc = "< [out] PCI Vendor ID"]
    pub pci_vendor_id: u32,
    #[doc = "< [out] PCI Device ID"]
    pub pci_device_id: u32,
    #[doc = "< [out] PCI Revision ID"]
    pub rev_id: u32,
    #[doc = "< [out] Number of EUs per sub-slice"]
    pub num_eus_per_sub_slice: u32,
    #[doc = "< [out] Number of sub-slices per slice"]
    pub num_sub_slices_per_slice: u32,
    #[doc = "< [out] Number of slices"]
    pub num_slices: u32,
    #[doc = "< [out] Device name"]
    pub name: [::std::os::raw::c_char; 100usize],
    #[doc = "< [out] Graphics Adapter Properties"]
    pub graphics_adapter_properties: ctl_adapter_properties_flags_t,
    #[doc = "< [out] Clock frequency for this device. Supported only for Version > 0"]
    pub Frequency: u32,
    #[doc = "< [out] PCI SubSys ID, Supported only for Version > 1"]
    pub pci_subsys_id: u16,
    #[doc = "< [out] PCI SubSys Vendor ID, Supported only for Version > 1"]
    pub pci_subsys_vendor_id: u16,
    #[doc = "< [out] Pci Bus, Device, Function. Supported only for Version > 1"]
    pub adapter_bdf: ctl_adapter_bdf_t,
    #[doc = "< [out] Reserved"]
    pub reserved: [::std::os::raw::c_char; 112usize],
}
impl Default for _ctl_device_adapter_properties_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Device Adapter properties"]
pub type ctl_device_adapter_properties_t = _ctl_device_adapter_properties_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief OperationType"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_operation_type_t {
    #[doc = "< Read operation"]
    CTL_OPERATION_TYPE_READ = 1,
    #[doc = "< Write operation"]
    CTL_OPERATION_TYPE_WRITE = 2,
    CTL_OPERATION_TYPE_MAX = 3,
}
#[doc = "\n @brief OperationType"]
pub use self::_ctl_operation_type_t as ctl_operation_type_t;
#[doc = "\n @brief Generic Structure for Void* datatypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_generic_void_datatype_t {
    #[doc = "< [in,out]void pointer to memory"]
    pub pData: *mut ::std::os::raw::c_void,
    #[doc = "< [in,out]size of the allocated memory"]
    pub size: u32,
}
impl Default for _ctl_generic_void_datatype_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Generic Structure for Void* datatypes"]
pub type ctl_generic_void_datatype_t = _ctl_generic_void_datatype_t;
#[doc = "\n @brief Generic Structure for Revision datatypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_revision_datatype_t {
    #[doc = "< [in,out]Major Version"]
    pub major_version: u8,
    #[doc = "< [in,out]Minor Version"]
    pub minor_version: u8,
    #[doc = "< [in,out]Revision Version"]
    pub revision_version: u8,
}
#[doc = "\n @brief Generic Structure for Revision datatypes"]
pub type ctl_revision_datatype_t = _ctl_revision_datatype_t;
#[doc = "\n @brief Property Type flags"]
pub type ctl_property_type_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_property_type_flag_t {
    #[doc = "< Display type. Supported scenarios: Sharpness/gamma/CSC"]
    CTL_PROPERTY_TYPE_FLAG_DISPLAY = 1,
    #[doc = "< 3D type. Supported scenarios: All set calls via IGCL's 3D APIs"]
    CTL_PROPERTY_TYPE_FLAG_3D = 2,
    #[doc = "< Media type. Supported scenarios: All set calls via IGCL's media APIs"]
    CTL_PROPERTY_TYPE_FLAG_MEDIA = 4,
    #[doc = "< For future: Core graphic event types like clocking, frequency etc."]
    CTL_PROPERTY_TYPE_FLAG_CORE = 8,
    CTL_PROPERTY_TYPE_FLAG_MAX = -2147483648,
}
pub use self::_ctl_property_type_flag_t as ctl_property_type_flag_t;
#[doc = "\n @brief Arguments related to wait for a property change function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_wait_property_change_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Type of the property"]
    pub PropertyType: ctl_property_type_flags_t,
    #[doc = "< [in][release] Time-out interval in milliseconds. Specify 0xFFFFFFFF if\n< time-out is not desired"]
    pub TimeOutMilliSec: u32,
    #[doc = "< [in][release] Event flags for future use"]
    pub EventMiscFlags: u32,
    #[doc = "< [in][release] Reserved for future use"]
    pub pReserved: *mut ::std::os::raw::c_void,
    #[doc = "< [out] Reserved out argument for future use"]
    pub ReservedOutFlags: u64,
}
impl Default for _ctl_wait_property_change_args_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Arguments related to wait for a property change function"]
pub type ctl_wait_property_change_args_t = _ctl_wait_property_change_args_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Display orientation (rotation)"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_display_orientation_t {
    #[doc = "< 0 Degree"]
    CTL_DISPLAY_ORIENTATION_0 = 0,
    #[doc = "< 90 Degree"]
    CTL_DISPLAY_ORIENTATION_90 = 1,
    #[doc = "< 180 Degree"]
    CTL_DISPLAY_ORIENTATION_180 = 2,
    #[doc = "< 270 Degree"]
    CTL_DISPLAY_ORIENTATION_270 = 3,
    CTL_DISPLAY_ORIENTATION_MAX = 4,
}
#[doc = "\n @brief Display orientation (rotation)"]
pub use self::_ctl_display_orientation_t as ctl_display_orientation_t;
#[doc = "\n @brief Rectangle"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_rect_t {
    #[doc = "< [in,out] Left"]
    pub Left: i32,
    #[doc = "< [in,out] Top"]
    pub Top: i32,
    #[doc = "< [in,out] Right"]
    pub Right: i32,
    #[doc = "< [in,out] Bottom"]
    pub Bottom: i32,
}
#[doc = "\n @brief Rectangle"]
pub type ctl_rect_t = _ctl_rect_t;
#[doc = "\n @brief Forward-declare ctl_endurance_gaming_caps_t"]
pub type ctl_endurance_gaming_caps_t = _ctl_endurance_gaming_caps_t;
#[doc = "\n @brief Forward-declare ctl_endurance_gaming_t"]
pub type ctl_endurance_gaming_t = _ctl_endurance_gaming_t;
#[doc = "\n @brief Forward-declare ctl_endurance_gaming2_t"]
pub type ctl_endurance_gaming2_t = _ctl_endurance_gaming2_t;
#[doc = "\n @brief Forward-declare ctl_adaptivesync_caps_t"]
pub type ctl_adaptivesync_caps_t = _ctl_adaptivesync_caps_t;
#[doc = "\n @brief Forward-declare ctl_adaptivesync_getset_t"]
pub type ctl_adaptivesync_getset_t = _ctl_adaptivesync_getset_t;
#[doc = "\n @brief Forward-declare ctl_3d_app_profiles_caps_t"]
pub type ctl_3d_app_profiles_caps_t = _ctl_3d_app_profiles_caps_t;
#[doc = "\n @brief Forward-declare ctl_3d_app_profiles_t"]
pub type ctl_3d_app_profiles_t = _ctl_3d_app_profiles_t;
#[doc = "\n @brief Forward-declare ctl_3d_tier_details_t"]
pub type ctl_3d_tier_details_t = _ctl_3d_tier_details_t;
#[doc = "\n @brief Forward-declare ctl_3d_feature_details_t"]
pub type ctl_3d_feature_details_t = _ctl_3d_feature_details_t;
#[doc = "\n @brief Forward-declare ctl_3d_feature_caps_t"]
pub type ctl_3d_feature_caps_t = _ctl_3d_feature_caps_t;
#[doc = "\n @brief Forward-declare ctl_3d_feature_getset_t"]
pub type ctl_3d_feature_getset_t = _ctl_3d_feature_getset_t;
#[doc = "\n @brief Forward-declare ctl_kmd_load_features_t"]
pub type ctl_kmd_load_features_t = _ctl_kmd_load_features_t;
#[doc = "\n @brief Forward-declare ctl_display_timing_t"]
pub type ctl_display_timing_t = _ctl_display_timing_t;
#[doc = "\n @brief Forward-declare ctl_display_properties_t"]
pub type ctl_display_properties_t = _ctl_display_properties_t;
#[doc = "\n @brief Forward-declare ctl_adapter_display_encoder_properties_t"]
pub type ctl_adapter_display_encoder_properties_t = _ctl_adapter_display_encoder_properties_t;
#[doc = "\n @brief Forward-declare ctl_sharpness_filter_properties_t"]
pub type ctl_sharpness_filter_properties_t = _ctl_sharpness_filter_properties_t;
#[doc = "\n @brief Forward-declare ctl_sharpness_caps_t"]
pub type ctl_sharpness_caps_t = _ctl_sharpness_caps_t;
#[doc = "\n @brief Forward-declare ctl_sharpness_settings_t"]
pub type ctl_sharpness_settings_t = _ctl_sharpness_settings_t;
#[doc = "\n @brief Forward-declare ctl_i2c_access_args_t"]
pub type ctl_i2c_access_args_t = _ctl_i2c_access_args_t;
#[doc = "\n @brief Forward-declare ctl_i2c_access_pinpair_args_t"]
pub type ctl_i2c_access_pinpair_args_t = _ctl_i2c_access_pinpair_args_t;
#[doc = "\n @brief Forward-declare ctl_aux_access_args_t"]
pub type ctl_aux_access_args_t = _ctl_aux_access_args_t;
#[doc = "\n @brief Forward-declare ctl_power_optimization_caps_t"]
pub type ctl_power_optimization_caps_t = _ctl_power_optimization_caps_t;
#[doc = "\n @brief Forward-declare ctl_power_optimization_lrr_t"]
pub type ctl_power_optimization_lrr_t = _ctl_power_optimization_lrr_t;
#[doc = "\n @brief Forward-declare ctl_power_optimization_psr_t"]
pub type ctl_power_optimization_psr_t = _ctl_power_optimization_psr_t;
#[doc = "\n @brief Forward-declare ctl_power_optimization_dpst_t"]
pub type ctl_power_optimization_dpst_t = _ctl_power_optimization_dpst_t;
#[doc = "\n @brief Forward-declare ctl_power_optimization_settings_t"]
pub type ctl_power_optimization_settings_t = _ctl_power_optimization_settings_t;
#[doc = "\n @brief Forward-declare ctl_set_brightness_t"]
pub type ctl_set_brightness_t = _ctl_set_brightness_t;
#[doc = "\n @brief Forward-declare ctl_get_brightness_t"]
pub type ctl_get_brightness_t = _ctl_get_brightness_t;
#[doc = "\n @brief Forward-declare ctl_pixtx_color_primaries_t"]
pub type ctl_pixtx_color_primaries_t = _ctl_pixtx_color_primaries_t;
#[doc = "\n @brief Forward-declare ctl_pixtx_pixel_format_t"]
pub type ctl_pixtx_pixel_format_t = _ctl_pixtx_pixel_format_t;
#[doc = "\n @brief Forward-declare ctl_pixtx_1dlut_config_t"]
pub type ctl_pixtx_1dlut_config_t = _ctl_pixtx_1dlut_config_t;
#[doc = "\n @brief Forward-declare ctl_pixtx_matrix_config_t"]
pub type ctl_pixtx_matrix_config_t = _ctl_pixtx_matrix_config_t;
#[doc = "\n @brief Forward-declare ctl_pixtx_3dlut_sample_t"]
pub type ctl_pixtx_3dlut_sample_t = _ctl_pixtx_3dlut_sample_t;
#[doc = "\n @brief Forward-declare ctl_pixtx_3dlut_config_t"]
pub type ctl_pixtx_3dlut_config_t = _ctl_pixtx_3dlut_config_t;
#[doc = "\n @brief Forward-declare ctl_pixtx_block_config_t"]
pub type ctl_pixtx_block_config_t = _ctl_pixtx_block_config_t;
#[doc = "\n @brief Forward-declare ctl_pixtx_pipe_get_config_t"]
pub type ctl_pixtx_pipe_get_config_t = _ctl_pixtx_pipe_get_config_t;
#[doc = "\n @brief Forward-declare ctl_pixtx_pipe_set_config_t"]
pub type ctl_pixtx_pipe_set_config_t = _ctl_pixtx_pipe_set_config_t;
#[doc = "\n @brief Forward-declare ctl_panel_descriptor_access_args_t"]
pub type ctl_panel_descriptor_access_args_t = _ctl_panel_descriptor_access_args_t;
#[doc = "\n @brief Forward-declare ctl_retro_scaling_settings_t"]
pub type ctl_retro_scaling_settings_t = _ctl_retro_scaling_settings_t;
#[doc = "\n @brief Forward-declare ctl_retro_scaling_caps_t"]
pub type ctl_retro_scaling_caps_t = _ctl_retro_scaling_caps_t;
#[doc = "\n @brief Forward-declare ctl_scaling_caps_t"]
pub type ctl_scaling_caps_t = _ctl_scaling_caps_t;
#[doc = "\n @brief Forward-declare ctl_scaling_settings_t"]
pub type ctl_scaling_settings_t = _ctl_scaling_settings_t;
#[doc = "\n @brief Forward-declare ctl_lace_lux_aggr_map_entry_t"]
pub type ctl_lace_lux_aggr_map_entry_t = _ctl_lace_lux_aggr_map_entry_t;
#[doc = "\n @brief Forward-declare ctl_lace_lux_aggr_map_t"]
pub type ctl_lace_lux_aggr_map_t = _ctl_lace_lux_aggr_map_t;
#[doc = "\n @brief Forward-declare ctl_lace_config_t"]
pub type ctl_lace_config_t = _ctl_lace_config_t;
#[doc = "\n @brief Forward-declare ctl_sw_psr_settings_t"]
pub type ctl_sw_psr_settings_t = _ctl_sw_psr_settings_t;
#[doc = "\n @brief Forward-declare ctl_intel_arc_sync_monitor_params_t"]
pub type ctl_intel_arc_sync_monitor_params_t = _ctl_intel_arc_sync_monitor_params_t;
#[doc = "\n @brief Forward-declare ctl_mux_properties_t"]
pub type ctl_mux_properties_t = _ctl_mux_properties_t;
#[doc = "\n @brief Forward-declare ctl_intel_arc_sync_profile_params_t"]
pub type ctl_intel_arc_sync_profile_params_t = _ctl_intel_arc_sync_profile_params_t;
#[doc = "\n @brief Forward-declare ctl_edid_management_args_t"]
pub type ctl_edid_management_args_t = _ctl_edid_management_args_t;
#[doc = "\n @brief Forward-declare ctl_get_set_custom_mode_args_t"]
pub type ctl_get_set_custom_mode_args_t = _ctl_get_set_custom_mode_args_t;
#[doc = "\n @brief Forward-declare ctl_custom_src_mode_t"]
pub type ctl_custom_src_mode_t = _ctl_custom_src_mode_t;
#[doc = "\n @brief Forward-declare ctl_child_display_target_mode_t"]
pub type ctl_child_display_target_mode_t = _ctl_child_display_target_mode_t;
#[doc = "\n @brief Forward-declare ctl_combined_display_child_info_t"]
pub type ctl_combined_display_child_info_t = _ctl_combined_display_child_info_t;
#[doc = "\n @brief Forward-declare ctl_combined_display_args_t"]
pub type ctl_combined_display_args_t = _ctl_combined_display_args_t;
#[doc = "\n @brief Forward-declare ctl_genlock_display_info_t"]
pub type ctl_genlock_display_info_t = _ctl_genlock_display_info_t;
#[doc = "\n @brief Forward-declare ctl_genlock_target_mode_list_t"]
pub type ctl_genlock_target_mode_list_t = _ctl_genlock_target_mode_list_t;
#[doc = "\n @brief Forward-declare ctl_genlock_topology_t"]
pub type ctl_genlock_topology_t = _ctl_genlock_topology_t;
#[doc = "\n @brief Forward-declare ctl_genlock_args_t"]
pub type ctl_genlock_args_t = _ctl_genlock_args_t;
#[doc = "\n @brief Forward-declare ctl_vblank_ts_args_t"]
pub type ctl_vblank_ts_args_t = _ctl_vblank_ts_args_t;
#[doc = "\n @brief Forward-declare ctl_lda_args_t"]
pub type ctl_lda_args_t = _ctl_lda_args_t;
#[doc = "\n @brief Forward-declare ctl_dce_args_t"]
pub type ctl_dce_args_t = _ctl_dce_args_t;
#[doc = "\n @brief Forward-declare ctl_wire_format_t"]
pub type ctl_wire_format_t = _ctl_wire_format_t;
#[doc = "\n @brief Forward-declare ctl_get_set_wire_format_config_t"]
pub type ctl_get_set_wire_format_config_t = _ctl_get_set_wire_format_config_t;
#[doc = "\n @brief Forward-declare ctl_display_settings_t"]
pub type ctl_display_settings_t = _ctl_display_settings_t;
#[doc = "\n @brief Forward-declare ctl_engine_properties_t"]
pub type ctl_engine_properties_t = _ctl_engine_properties_t;
#[doc = "\n @brief Forward-declare ctl_engine_stats_t"]
pub type ctl_engine_stats_t = _ctl_engine_stats_t;
#[doc = "\n @brief Forward-declare ctl_fan_speed_t"]
pub type ctl_fan_speed_t = _ctl_fan_speed_t;
#[doc = "\n @brief Forward-declare ctl_fan_temp_speed_t"]
pub type ctl_fan_temp_speed_t = _ctl_fan_temp_speed_t;
#[doc = "\n @brief Forward-declare ctl_fan_speed_table_t"]
pub type ctl_fan_speed_table_t = _ctl_fan_speed_table_t;
#[doc = "\n @brief Forward-declare ctl_fan_properties_t"]
pub type ctl_fan_properties_t = _ctl_fan_properties_t;
#[doc = "\n @brief Forward-declare ctl_fan_config_t"]
pub type ctl_fan_config_t = _ctl_fan_config_t;
#[doc = "\n @brief Forward-declare ctl_freq_properties_t"]
pub type ctl_freq_properties_t = _ctl_freq_properties_t;
#[doc = "\n @brief Forward-declare ctl_freq_range_t"]
pub type ctl_freq_range_t = _ctl_freq_range_t;
#[doc = "\n @brief Forward-declare ctl_freq_state_t"]
pub type ctl_freq_state_t = _ctl_freq_state_t;
#[doc = "\n @brief Forward-declare ctl_freq_throttle_time_t"]
pub type ctl_freq_throttle_time_t = _ctl_freq_throttle_time_t;
#[doc = "\n @brief Forward-declare ctl_video_processing_super_resolution_info_t"]
pub type ctl_video_processing_super_resolution_info_t =
    _ctl_video_processing_super_resolution_info_t;
#[doc = "\n @brief Forward-declare ctl_video_processing_super_resolution_t"]
pub type ctl_video_processing_super_resolution_t = _ctl_video_processing_super_resolution_t;
#[doc = "\n @brief Forward-declare ctl_video_processing_noise_reduction_info_t"]
pub type ctl_video_processing_noise_reduction_info_t = _ctl_video_processing_noise_reduction_info_t;
#[doc = "\n @brief Forward-declare ctl_video_processing_noise_reduction_t"]
pub type ctl_video_processing_noise_reduction_t = _ctl_video_processing_noise_reduction_t;
#[doc = "\n @brief Forward-declare ctl_video_processing_adaptive_contrast_enhancement_info_t"]
pub type ctl_video_processing_adaptive_contrast_enhancement_info_t =
    _ctl_video_processing_adaptive_contrast_enhancement_info_t;
#[doc = "\n @brief Forward-declare ctl_video_processing_adaptive_contrast_enhancement_t"]
pub type ctl_video_processing_adaptive_contrast_enhancement_t =
    _ctl_video_processing_adaptive_contrast_enhancement_t;
#[doc = "\n @brief Forward-declare ctl_video_processing_standard_color_correction_info_t"]
pub type ctl_video_processing_standard_color_correction_info_t =
    _ctl_video_processing_standard_color_correction_info_t;
#[doc = "\n @brief Forward-declare ctl_video_processing_standard_color_correction_t"]
pub type ctl_video_processing_standard_color_correction_t =
    _ctl_video_processing_standard_color_correction_t;
#[doc = "\n @brief Forward-declare ctl_video_processing_total_color_correction_info_t"]
pub type ctl_video_processing_total_color_correction_info_t =
    _ctl_video_processing_total_color_correction_info_t;
#[doc = "\n @brief Forward-declare ctl_video_processing_total_color_correction_t"]
pub type ctl_video_processing_total_color_correction_t =
    _ctl_video_processing_total_color_correction_t;
#[doc = "\n @brief Forward-declare ctl_video_processing_feature_details_t"]
pub type ctl_video_processing_feature_details_t = _ctl_video_processing_feature_details_t;
#[doc = "\n @brief Forward-declare ctl_video_processing_feature_caps_t"]
pub type ctl_video_processing_feature_caps_t = _ctl_video_processing_feature_caps_t;
#[doc = "\n @brief Forward-declare ctl_video_processing_feature_getset_t"]
pub type ctl_video_processing_feature_getset_t = _ctl_video_processing_feature_getset_t;
#[doc = "\n @brief Forward-declare ctl_mem_properties_t"]
pub type ctl_mem_properties_t = _ctl_mem_properties_t;
#[doc = "\n @brief Forward-declare ctl_mem_state_t"]
pub type ctl_mem_state_t = _ctl_mem_state_t;
#[doc = "\n @brief Forward-declare ctl_mem_bandwidth_t"]
pub type ctl_mem_bandwidth_t = _ctl_mem_bandwidth_t;
#[doc = "\n @brief Forward-declare ctl_oc_telemetry_item_t"]
pub type ctl_oc_telemetry_item_t = _ctl_oc_telemetry_item_t;
#[doc = "\n @brief Forward-declare ctl_oc_control_info_t"]
pub type ctl_oc_control_info_t = _ctl_oc_control_info_t;
#[doc = "\n @brief Forward-declare ctl_oc_properties_t"]
pub type ctl_oc_properties_t = _ctl_oc_properties_t;
#[doc = "\n @brief Forward-declare ctl_oc_vf_pair_t"]
pub type ctl_oc_vf_pair_t = _ctl_oc_vf_pair_t;
#[doc = "\n @brief Forward-declare ctl_psu_info_t"]
pub type ctl_psu_info_t = _ctl_psu_info_t;
#[doc = "\n @brief Forward-declare ctl_power_telemetry_t"]
pub type ctl_power_telemetry_t = _ctl_power_telemetry_t;
#[doc = "\n @brief Forward-declare ctl_pci_address_t"]
pub type ctl_pci_address_t = _ctl_pci_address_t;
#[doc = "\n @brief Forward-declare ctl_pci_speed_t"]
pub type ctl_pci_speed_t = _ctl_pci_speed_t;
#[doc = "\n @brief Forward-declare ctl_pci_properties_t"]
pub type ctl_pci_properties_t = _ctl_pci_properties_t;
#[doc = "\n @brief Forward-declare ctl_pci_state_t"]
pub type ctl_pci_state_t = _ctl_pci_state_t;
#[doc = "\n @brief Forward-declare ctl_power_properties_t"]
pub type ctl_power_properties_t = _ctl_power_properties_t;
#[doc = "\n @brief Forward-declare ctl_power_energy_counter_t"]
pub type ctl_power_energy_counter_t = _ctl_power_energy_counter_t;
#[doc = "\n @brief Forward-declare ctl_power_sustained_limit_t"]
pub type ctl_power_sustained_limit_t = _ctl_power_sustained_limit_t;
#[doc = "\n @brief Forward-declare ctl_power_burst_limit_t"]
pub type ctl_power_burst_limit_t = _ctl_power_burst_limit_t;
#[doc = "\n @brief Forward-declare ctl_power_peak_limit_t"]
pub type ctl_power_peak_limit_t = _ctl_power_peak_limit_t;
#[doc = "\n @brief Forward-declare ctl_power_limits_t"]
pub type ctl_power_limits_t = _ctl_power_limits_t;
#[doc = "\n @brief Forward-declare ctl_energy_threshold_t"]
pub type ctl_energy_threshold_t = _ctl_energy_threshold_t;
#[doc = "\n @brief Forward-declare ctl_temp_properties_t"]
pub type ctl_temp_properties_t = _ctl_temp_properties_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Feature type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_3d_feature_t {
    #[doc = "< Frame pacing. Contains generic enum type fields"]
    CTL_3D_FEATURE_FRAME_PACING = 0,
    #[doc = "< Endurance gaming. Contains generic integer type fields. Value will be\n< interpreted as the max FPS to be used when in DC mode globally or per\n< application"]
    CTL_3D_FEATURE_ENDURANCE_GAMING = 1,
    #[doc = "< Frame limit for games. Contains generic integer type fields. Value\n< will be interpreted as the max FPS to be used independent of system\n< power state"]
    CTL_3D_FEATURE_FRAME_LIMIT = 2,
    #[doc = "< ANISOTROPIC. Contains generic enum type fields"]
    CTL_3D_FEATURE_ANISOTROPIC = 3,
    #[doc = "< CMAA. Contains generic enum type fields"]
    CTL_3D_FEATURE_CMAA = 4,
    #[doc = "< Texture filtering quality. Contains generic enum type fields"]
    CTL_3D_FEATURE_TEXTURE_FILTERING_QUALITY = 5,
    #[doc = "< Adaptive tessellation quality. Contains generic integer type fields"]
    CTL_3D_FEATURE_ADAPTIVE_TESSELLATION = 6,
    #[doc = "< Sharpening Filter. Contains generic integer type fields"]
    CTL_3D_FEATURE_SHARPENING_FILTER = 7,
    #[doc = "< Msaa. Contains generic enum type fields"]
    CTL_3D_FEATURE_MSAA = 8,
    #[doc = "< Various Gaming flip modes like speed frame, smooth sync & force async\n< flip. Contains generic enum type fields"]
    CTL_3D_FEATURE_GAMING_FLIP_MODES = 9,
    #[doc = "< Adaptive sync plus. Refer custom field ::ctl_adaptivesync_caps_t &\n< ::ctl_adaptivesync_getset_t"]
    CTL_3D_FEATURE_ADAPTIVE_SYNC_PLUS = 10,
    #[doc = "< Game Compatibility & Performance Profiles. Refer custom field\n< ::ctl_3d_app_profiles_caps_t & ::ctl_3d_app_profiles_t"]
    CTL_3D_FEATURE_APP_PROFILES = 11,
    #[doc = "< Game Profile Customization. Refer custom field ::ctl_3d_tier_details_t"]
    CTL_3D_FEATURE_APP_PROFILE_DETAILS = 12,
    #[doc = "< Emulated Typed 64bit Atomics support in DG2"]
    CTL_3D_FEATURE_EMULATED_TYPED_64BIT_ATOMICS = 13,
    #[doc = "< VRR windowed blt. Control VRR for windowed mode game"]
    CTL_3D_FEATURE_VRR_WINDOWED_BLT = 14,
    #[doc = "< Set global settings or per application settings"]
    CTL_3D_FEATURE_GLOBAL_OR_PER_APP = 15,
    CTL_3D_FEATURE_MAX = 16,
}
#[doc = "\n @brief Feature type"]
pub use self::_ctl_3d_feature_t as ctl_3d_feature_t;
#[doc = "\n @brief 3D feature misc flags"]
pub type ctl_3d_feature_misc_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_3d_feature_misc_flag_t {
    #[doc = "< Feature supported on DX11"]
    CTL_3D_FEATURE_MISC_FLAG_DX11 = 1,
    #[doc = "< Feature supported on DX12"]
    CTL_3D_FEATURE_MISC_FLAG_DX12 = 2,
    #[doc = "< Feature supported on VULKAN"]
    CTL_3D_FEATURE_MISC_FLAG_VULKAN = 4,
    #[doc = "< User can change feature live without restarting the game"]
    CTL_3D_FEATURE_MISC_FLAG_LIVE_CHANGE = 8,
    CTL_3D_FEATURE_MISC_FLAG_MAX = -2147483648,
}
pub use self::_ctl_3d_feature_misc_flag_t as ctl_3d_feature_misc_flag_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Anisotropic values possible"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_3d_anisotropic_types_t {
    #[doc = "< Application choice"]
    CTL_3D_ANISOTROPIC_TYPES_APP_CHOICE = 0,
    #[doc = "< 2X"]
    CTL_3D_ANISOTROPIC_TYPES_2X = 2,
    #[doc = "< 4X"]
    CTL_3D_ANISOTROPIC_TYPES_4X = 4,
    #[doc = "< 8X"]
    CTL_3D_ANISOTROPIC_TYPES_8X = 8,
    #[doc = "< 16X"]
    CTL_3D_ANISOTROPIC_TYPES_16X = 16,
    CTL_3D_ANISOTROPIC_TYPES_MAX = 17,
}
#[doc = "\n @brief Anisotropic values possible"]
pub use self::_ctl_3d_anisotropic_types_t as ctl_3d_anisotropic_types_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Texture filtering values possible"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_3d_texture_filtering_quality_types_t {
    #[doc = "< Performance"]
    CTL_3D_TEXTURE_FILTERING_QUALITY_TYPES_PERFORMANCE = 0,
    #[doc = "< Balanced"]
    CTL_3D_TEXTURE_FILTERING_QUALITY_TYPES_BALANCED = 1,
    #[doc = "< Quality"]
    CTL_3D_TEXTURE_FILTERING_QUALITY_TYPES_QUALITY = 2,
    CTL_3D_TEXTURE_FILTERING_QUALITY_TYPES_MAX = 3,
}
#[doc = "\n @brief Texture filtering values possible"]
pub use self::_ctl_3d_texture_filtering_quality_types_t as ctl_3d_texture_filtering_quality_types_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Frame pacing values possible"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_3d_frame_pacing_types_t {
    #[doc = "< Disable"]
    CTL_3D_FRAME_PACING_TYPES_DISABLE = 0,
    #[doc = "< Enable with scheduler without any frame smoothening"]
    CTL_3D_FRAME_PACING_TYPES_ENABLE_MODE_FRAME_NO_SMOOTHENING = 1,
    #[doc = "< Enable with scheduler with maximum smoothness"]
    CTL_3D_FRAME_PACING_TYPES_ENABLE_MODE_FRAME_MAX_SMOOTHENING = 2,
    #[doc = "< Enable with scheduler in competitive gaming mode"]
    CTL_3D_FRAME_PACING_TYPES_ENABLE_MODE_COMPETITIVE_GAMING = 3,
    CTL_3D_FRAME_PACING_TYPES_MAX = 4,
}
#[doc = "\n @brief Frame pacing values possible"]
pub use self::_ctl_3d_frame_pacing_types_t as ctl_3d_frame_pacing_types_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Endurance Gaming control possible"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_3d_endurance_gaming_control_t {
    #[doc = "< Endurance Gaming disable"]
    CTL_3D_ENDURANCE_GAMING_CONTROL_TURN_OFF = 0,
    #[doc = "< Endurance Gaming enable"]
    CTL_3D_ENDURANCE_GAMING_CONTROL_TURN_ON = 1,
    #[doc = "< Endurance Gaming auto"]
    CTL_3D_ENDURANCE_GAMING_CONTROL_AUTO = 2,
    CTL_3D_ENDURANCE_GAMING_CONTROL_MAX = 3,
}
#[doc = "\n @brief Endurance Gaming control possible"]
pub use self::_ctl_3d_endurance_gaming_control_t as ctl_3d_endurance_gaming_control_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Endurance Gaming modes possible"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_3d_endurance_gaming_mode_t {
    #[doc = "< Endurance Gaming better performance mode"]
    CTL_3D_ENDURANCE_GAMING_MODE_BETTER_PERFORMANCE = 0,
    #[doc = "< Endurance Gaming balanced mode"]
    CTL_3D_ENDURANCE_GAMING_MODE_BALANCED = 1,
    #[doc = "< Endurance Gaming maximum battery mode"]
    CTL_3D_ENDURANCE_GAMING_MODE_MAXIMUM_BATTERY = 2,
    CTL_3D_ENDURANCE_GAMING_MODE_MAX = 3,
}
#[doc = "\n @brief Endurance Gaming modes possible"]
pub use self::_ctl_3d_endurance_gaming_mode_t as ctl_3d_endurance_gaming_mode_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Cmaa values possible"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_3d_cmaa_types_t {
    #[doc = "< Turn off"]
    CTL_3D_CMAA_TYPES_TURN_OFF = 0,
    #[doc = "< Override MSAA"]
    CTL_3D_CMAA_TYPES_OVERRIDE_MSAA = 1,
    #[doc = "< Enhance Application"]
    CTL_3D_CMAA_TYPES_ENHANCE_APPLICATION = 2,
    CTL_3D_CMAA_TYPES_MAX = 3,
}
#[doc = "\n @brief Cmaa values possible"]
pub use self::_ctl_3d_cmaa_types_t as ctl_3d_cmaa_types_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Adaptive Tessellation"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_3d_adaptive_tessellation_types_t {
    #[doc = "< Turn off"]
    CTL_3D_ADAPTIVE_TESSELLATION_TYPES_TURN_OFF = 0,
    #[doc = "< Turn on"]
    CTL_3D_ADAPTIVE_TESSELLATION_TYPES_TURN_ON = 1,
    CTL_3D_ADAPTIVE_TESSELLATION_TYPES_MAX = 2,
}
#[doc = "\n @brief Adaptive Tessellation"]
pub use self::_ctl_3d_adaptive_tessellation_types_t as ctl_3d_adaptive_tessellation_types_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Sharpening filter values possible"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_3d_sharpening_filter_types_t {
    #[doc = "< Turn off"]
    CTL_3D_SHARPENING_FILTER_TYPES_TURN_OFF = 0,
    #[doc = "< Turn on"]
    CTL_3D_SHARPENING_FILTER_TYPES_TURN_ON = 1,
    CTL_3D_SHARPENING_FILTER_TYPES_MAX = 2,
}
#[doc = "\n @brief Sharpening filter values possible"]
pub use self::_ctl_3d_sharpening_filter_types_t as ctl_3d_sharpening_filter_types_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief MSAA values possible"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_3d_msaa_types_t {
    #[doc = "< Application choice"]
    CTL_3D_MSAA_TYPES_APP_CHOICE = 0,
    #[doc = "< Disabled. MSAA count 1"]
    CTL_3D_MSAA_TYPES_DISABLED = 1,
    #[doc = "< 2X"]
    CTL_3D_MSAA_TYPES_2X = 2,
    #[doc = "< 4X"]
    CTL_3D_MSAA_TYPES_4X = 4,
    #[doc = "< 8X"]
    CTL_3D_MSAA_TYPES_8X = 8,
    #[doc = "< 16X"]
    CTL_3D_MSAA_TYPES_16X = 16,
    CTL_3D_MSAA_TYPES_MAX = 17,
}
#[doc = "\n @brief MSAA values possible"]
pub use self::_ctl_3d_msaa_types_t as ctl_3d_msaa_types_t;
#[doc = "\n @brief Gaming flip modes"]
pub type ctl_gaming_flip_mode_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_gaming_flip_mode_flag_t {
    #[doc = "< Application Default"]
    CTL_GAMING_FLIP_MODE_FLAG_APPLICATION_DEFAULT = 1,
    #[doc = "< Convert all sync flips to async on the next possible scanline."]
    CTL_GAMING_FLIP_MODE_FLAG_VSYNC_OFF = 2,
    #[doc = "< Convert all async flips to sync flips."]
    CTL_GAMING_FLIP_MODE_FLAG_VSYNC_ON = 4,
    #[doc = "< Reduce tearing effect with async flips"]
    CTL_GAMING_FLIP_MODE_FLAG_SMOOTH_SYNC = 8,
    #[doc = "< Application unaware triple buffering"]
    CTL_GAMING_FLIP_MODE_FLAG_SPEED_FRAME = 16,
    #[doc = "< Limit the game FPS to panel RR"]
    CTL_GAMING_FLIP_MODE_FLAG_CAPPED_FPS = 32,
    CTL_GAMING_FLIP_MODE_FLAG_MAX = -2147483648,
}
pub use self::_ctl_gaming_flip_mode_flag_t as ctl_gaming_flip_mode_flag_t;
#[doc = "\n @brief Endurance Gaming caps"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_endurance_gaming_caps_t {
    #[doc = "< [out] Endurance Gaming control capability"]
    pub EGControlCaps: ctl_property_info_enum_t,
    #[doc = "< [out] Endurance Gaming mode capability"]
    pub EGModeCaps: ctl_property_info_enum_t,
}
#[doc = "\n @brief Endurance Gaming Get/Set"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_endurance_gaming_t {
    #[doc = "< [in,out] Endurance Gaming control - Off/On/Auto"]
    pub EGControl: ctl_3d_endurance_gaming_control_t,
    #[doc = "< [in,out] Endurance Gaming mode - Better Performance/Balanced/Maximum\n< Battery"]
    pub EGMode: ctl_3d_endurance_gaming_mode_t,
}
impl Default for _ctl_endurance_gaming_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Endurance Gaming version2 Get/Set"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_endurance_gaming2_t {
    #[doc = "< [in,out] Endurance Gaming control - Off/On/Auto"]
    pub EGControl: ctl_3d_endurance_gaming_control_t,
    #[doc = "< [in,out] Endurance Gaming mode - Better Performance/Balanced/Maximum\n< Battery"]
    pub EGMode: ctl_3d_endurance_gaming_mode_t,
    #[doc = "< [out] Is frame pacing required, dynamic state"]
    pub IsFPRequired: bool,
    #[doc = "< [out] Target FPS for frame pacing"]
    pub TargetFPS: f64,
    #[doc = "< [out] Refresh rate used to calculate target fps"]
    pub RefreshRate: f64,
    #[doc = "< [out] Reserved fields"]
    pub Reserved: [u32; 4usize],
}
impl Default for _ctl_endurance_gaming2_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Adaptive sync plus caps"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_adaptivesync_caps_t {
    #[doc = "< [out] Adaptive balance supported"]
    pub AdaptiveBalanceSupported: bool,
    #[doc = "< [out] Strength of adaptive balance algorithm - min/max/steps/default"]
    pub AdaptiveBalanceStrengthCaps: ctl_property_info_float_t,
}
#[doc = "\n @brief Adaptive sync plus"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_adaptivesync_getset_t {
    #[doc = "< [in,out] Adaptive sync. Note that in Windows, OS controls state of\n< adaptive sync and which game gets the feature using it's own policies"]
    pub AdaptiveSync: bool,
    #[doc = "< [in,out] Adaptive balance"]
    pub AdaptiveBalance: bool,
    #[doc = "< [in,out] Allow async flips when FPS is higher than max refresh rate of\n< the panel"]
    pub AllowAsyncForHighFPS: bool,
    #[doc = "< [in,out] Adaptive balance strength"]
    pub AdaptiveBalanceStrength: f32,
}
#[doc = "\n @brief Game tier types"]
pub type ctl_3d_tier_type_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_3d_tier_type_flag_t {
    #[doc = "< Compatibility Tier"]
    CTL_3D_TIER_TYPE_FLAG_COMPATIBILITY = 1,
    #[doc = "< Performance Tier"]
    CTL_3D_TIER_TYPE_FLAG_PERFORMANCE = 2,
    CTL_3D_TIER_TYPE_FLAG_MAX = -2147483648,
}
pub use self::_ctl_3d_tier_type_flag_t as ctl_3d_tier_type_flag_t;
#[doc = "\n @brief Game tiers"]
pub type ctl_3d_tier_profile_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_3d_tier_profile_flag_t {
    #[doc = "< Tier 1 Profile"]
    CTL_3D_TIER_PROFILE_FLAG_TIER_1 = 1,
    #[doc = "< Tier 2 Profile"]
    CTL_3D_TIER_PROFILE_FLAG_TIER_2 = 2,
    #[doc = "< Recommended Tier Profile. If set other tier values shouldn't be set"]
    CTL_3D_TIER_PROFILE_FLAG_TIER_RECOMMENDED = 1073741824,
    CTL_3D_TIER_PROFILE_FLAG_MAX = -2147483648,
}
pub use self::_ctl_3d_tier_profile_flag_t as ctl_3d_tier_profile_flag_t;
#[doc = "\n @brief Game Profile Capabilities. Typically these remain the same across\n        games."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_3d_app_profiles_caps_t {
    #[doc = "< [out] Tier of interest for capability check"]
    pub SupportedTierTypes: ctl_3d_tier_type_flags_t,
    #[doc = "< [in,out] Reserved for future"]
    pub Reserved: u64,
}
#[doc = "\n @brief Game Profile tiers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_3d_app_profiles_t {
    #[doc = "< [in] Tier type"]
    pub TierType: ctl_3d_tier_type_flag_t,
    #[doc = "< [out] Supported tier profiles bitmask"]
    pub SupportedTierProfiles: ctl_3d_tier_profile_flags_t,
    #[doc = "< [out] Default tiers which driver will enable if there is no user\n< specific setting for global or per application"]
    pub DefaultEnabledTierProfiles: ctl_3d_tier_profile_flags_t,
    #[doc = "< [out] Tiers supporting customization - reserved for future"]
    pub CustomizationSupportedTierProfiles: ctl_3d_tier_profile_flags_t,
    #[doc = "< [in,out] Tier profile(s) to be enabled/disabled in the case of a set\n< call. For a get call this will return the currently enabled tiers"]
    pub EnabledTierProfiles: ctl_3d_tier_profile_flags_t,
    #[doc = "< [in,out] Tier profile(s) which are customized. Caller shall call\n< ::ctl_3d_tier_details_t to get specifics if any."]
    pub CustomizationEnabledTierProfiles: ctl_3d_tier_profile_flags_t,
    #[doc = "< [in,out] Reserved for future"]
    pub Reserved: u64,
}
impl Default for _ctl_3d_app_profiles_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Game Profile tiers details"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_3d_tier_details_t {
    #[doc = "< [in] Tier type"]
    pub TierType: ctl_3d_tier_type_flag_t,
    #[doc = "< [in] Tier profile(s) for get/set details"]
    pub TierProfile: ctl_3d_tier_profile_flag_t,
    #[doc = "< [in,out] Reserved for future"]
    pub Reserved: [u64; 4usize],
}
impl Default for _ctl_3d_tier_details_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Emulated Typed 64bit Atomics"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_emulated_typed_64bit_atomics_types_t {
    #[doc = "< Default settings is based on workload/driver decision."]
    CTL_EMULATED_TYPED_64BIT_ATOMICS_TYPES_DEFAULT = 0,
    #[doc = "< Force Turn on"]
    CTL_EMULATED_TYPED_64BIT_ATOMICS_TYPES_TURN_ON = 1,
    #[doc = "< Force Turn off"]
    CTL_EMULATED_TYPED_64BIT_ATOMICS_TYPES_TURN_OFF = 2,
    CTL_EMULATED_TYPED_64BIT_ATOMICS_TYPES_MAX = 3,
}
#[doc = "\n @brief Emulated Typed 64bit Atomics"]
pub use self::_ctl_emulated_typed_64bit_atomics_types_t as ctl_emulated_typed_64bit_atomics_types_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief VRR windowed BLT control possible. Reserved functionality"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_3d_vrr_windowed_blt_reserved_t {
    #[doc = "< VRR windowed BLT auto"]
    CTL_3D_VRR_WINDOWED_BLT_RESERVED_AUTO = 0,
    #[doc = "< VRR windowed BLT enable"]
    CTL_3D_VRR_WINDOWED_BLT_RESERVED_TURN_ON = 1,
    #[doc = "< VRR windowed BLT disable"]
    CTL_3D_VRR_WINDOWED_BLT_RESERVED_TURN_OFF = 2,
    CTL_3D_VRR_WINDOWED_BLT_RESERVED_MAX = 3,
}
#[doc = "\n @brief VRR windowed BLT control possible. Reserved functionality"]
pub use self::_ctl_3d_vrr_windowed_blt_reserved_t as ctl_3d_vrr_windowed_blt_reserved_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Global or per app values possible"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_3d_global_or_per_app_types_t {
    #[doc = "< none"]
    CTL_3D_GLOBAL_OR_PER_APP_TYPES_NONE = 0,
    #[doc = "< Opt for per app settings"]
    CTL_3D_GLOBAL_OR_PER_APP_TYPES_PER_APP = 1,
    #[doc = "< Opt for global settings"]
    CTL_3D_GLOBAL_OR_PER_APP_TYPES_GLOBAL = 2,
    CTL_3D_GLOBAL_OR_PER_APP_TYPES_MAX = 3,
}
#[doc = "\n @brief Global or per app values possible"]
pub use self::_ctl_3d_global_or_per_app_types_t as ctl_3d_global_or_per_app_types_t;
#[doc = "\n @brief 3D feature capability details which will have range/supported and\n        default values"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_3d_feature_details_t {
    #[doc = "< [out] 3D feature type"]
    pub FeatureType: ctl_3d_feature_t,
    #[doc = "< [out] Type of value"]
    pub ValueType: ctl_property_value_type_t,
    #[doc = "< [out] Union of various type of values for 3D features. For enum types\n< this can be anisotropic/frame pacing etc. This member is valid iff\n< ValueType is not CTL_PROPERTY_VALUE_TYPE_CUSTOM"]
    pub Value: ctl_property_info_t,
    #[doc = "< [in] CustomValue buffer size. Typically for a feature requiring custom\n< struct, caller will know of it upfront and can provide the right size\n< info here"]
    pub CustomValueSize: i32,
    #[doc = "< [in,out] Pointer to a custom structure. Caller should allocate this\n< buffer with known custom feature structure size. This member is valid\n< iff ValueType is CTL_PROPERTY_VALUE_TYPE_CUSTOM"]
    pub pCustomValue: *mut ::std::os::raw::c_void,
    #[doc = "< [out] Flag indicating whether the feature is supported per application\n< or not"]
    pub PerAppSupport: bool,
    #[doc = "< [out] Mask of ::ctl_3d_feature_t values which can't be enabled along\n< with the mentioned FeatureType. If this is 0, it meant the feature\n< doesn't have any conflicts with other features"]
    pub ConflictingFeatures: i64,
    #[doc = "< [out] 3D Feature Miscellaneous support flags. This will be based on\n< ::ctl_3d_feature_misc_flags_t"]
    pub FeatureMiscSupport: i16,
    #[doc = "< [out] Reserved"]
    pub Reserved: i16,
    #[doc = "< [out] Reserved"]
    pub Reserved1: i16,
    #[doc = "< [out] Reserved"]
    pub Reserved2: i16,
}
impl Default for _ctl_3d_feature_details_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _ctl_3d_feature_details_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "_ctl_3d_feature_details_t {{ FeatureType: {:?}, ValueType: {:?}, Value: {:?}, pCustomValue: {:?}, PerAppSupport: {:?} }}" , self . FeatureType , self . ValueType , self . Value , self . pCustomValue , self . PerAppSupport)
    }
}
#[doc = "\n @brief 3D feature which are controllable"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_3d_feature_caps_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Number of elements in supported features array"]
    pub NumSupportedFeatures: u32,
    #[doc = "< [in,out] Array of feature details"]
    pub pFeatureDetails: *mut ctl_3d_feature_details_t,
}
impl Default for _ctl_3d_feature_caps_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief 3D feature for get/set"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_3d_feature_getset_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Features interested in"]
    pub FeatureType: ctl_3d_feature_t,
    #[doc = "< [in] Application name for which the property type is applicable. If\n< this is an empty string then this will get/set global settings for the\n< given adapter. Note that this should contain only the name of the\n< application and not the system specific path"]
    pub ApplicationName: *mut ::std::os::raw::c_char,
    #[doc = "< [in] Length of ApplicationName string"]
    pub ApplicationNameLength: i8,
    #[doc = "< [in] Set this if it's a set call"]
    pub bSet: bool,
    #[doc = "< [in] Type of value. Caller has to ensure it provides the right value\n< type which decides how one read the union structure below"]
    pub ValueType: ctl_property_value_type_t,
    #[doc = "< [in,out] Union of various type of values for 3D features. For enum\n< types this can be anisotropic/frame pacing etc. This member is valid\n< iff ValueType is not CTL_PROPERTY_VALUE_TYPE_CUSTOM"]
    pub Value: ctl_property_t,
    #[doc = "< [in] CustomValue buffer size. Typically for a feature requiring custom\n< struct, caller will know of it upfront and cn provide the right size\n< info here"]
    pub CustomValueSize: i32,
    #[doc = "< [in,out] Pointer to a custom structure. Caller should allocate this\n< buffer with known custom feature structure size. This member is valid\n< iff ValueType is CTL_PROPERTY_VALUE_TYPE_CUSTOM"]
    pub pCustomValue: *mut ::std::os::raw::c_void,
}
impl Default for _ctl_3d_feature_getset_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _ctl_3d_feature_getset_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "_ctl_3d_feature_getset_t {{ FeatureType: {:?}, ApplicationName: {:?}, bSet: {:?}, ValueType: {:?}, Value: {:?}, pCustomValue: {:?} }}" , self . FeatureType , self . ApplicationName , self . bSet , self . ValueType , self . Value , self . pCustomValue)
    }
}
#[doc = "\n @brief Load KMD gaming features. Restricted function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_kmd_load_features_t {
    #[doc = "< [in] Unique ID for reserved/special function"]
    pub ReservedFuncID: ctl_application_id_t,
    #[doc = "< [in] If set, will load known KMD features. If not set will reset known\n< KMD features to default"]
    pub bLoad: bool,
    #[doc = "< [in,out] Mask indicating the subset of KMD features within\n< ::ctl_3d_feature_t values. Default of 0 indicate all KMD features"]
    pub SubsetFeatureMask: i64,
    #[doc = "< [in] Application name for which the KMD properties are loaded for. If\n< this is an empty string then this will load global settings for the\n< given adapter. Note that this should contain only the name of the\n< application and not the system specific path"]
    pub ApplicationName: *mut ::std::os::raw::c_char,
    #[doc = "< [in] Length of ApplicationName string"]
    pub ApplicationNameLength: i8,
    #[doc = "< [in] Caller component"]
    pub CallerComponent: i8,
    #[doc = "< [in] Reserved field"]
    pub Reserved: [i64; 4usize],
}
impl Default for _ctl_kmd_load_features_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_display_output_handle_t {
    _unused: [u8; 0],
}
#[doc = "\n @brief Handle of a display output instance"]
pub type ctl_display_output_handle_t = *mut _ctl_display_output_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_i2c_pin_pair_handle_t {
    _unused: [u8; 0],
}
#[doc = "\n @brief Handle of a i2c pin-pair instance"]
pub type ctl_i2c_pin_pair_handle_t = *mut _ctl_i2c_pin_pair_handle_t;
#[doc = "\n @brief OS specific Display identifiers"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ctl_os_display_encoder_identifier_t {
    #[doc = "< [out] Windows OS Display encoder ID"]
    pub WindowsDisplayEncoderID: u32,
    #[doc = "< [out] Display encoder ID for non-windows OS"]
    pub DisplayEncoderID: ctl_generic_void_datatype_t,
}
impl Default for _ctl_os_display_encoder_identifier_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _ctl_os_display_encoder_identifier_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_ctl_os_display_encoder_identifier_t {{ union }}")
    }
}
#[doc = "\n @brief OS specific Display identifiers"]
pub type ctl_os_display_encoder_identifier_t = _ctl_os_display_encoder_identifier_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Various display types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_display_output_types_t {
    #[doc = "< Invalid"]
    CTL_DISPLAY_OUTPUT_TYPES_INVALID = 0,
    #[doc = "< DisplayPort"]
    CTL_DISPLAY_OUTPUT_TYPES_DISPLAYPORT = 1,
    #[doc = "< HDMI"]
    CTL_DISPLAY_OUTPUT_TYPES_HDMI = 2,
    #[doc = "< DVI"]
    CTL_DISPLAY_OUTPUT_TYPES_DVI = 3,
    #[doc = "< MIPI"]
    CTL_DISPLAY_OUTPUT_TYPES_MIPI = 4,
    #[doc = "< CRT"]
    CTL_DISPLAY_OUTPUT_TYPES_CRT = 5,
    CTL_DISPLAY_OUTPUT_TYPES_MAX = 6,
}
#[doc = "\n @brief Various display types"]
pub use self::_ctl_display_output_types_t as ctl_display_output_types_t;
#[doc = "\n @brief Supported output bits per color (bpc) bitmasks"]
pub type ctl_output_bpc_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_output_bpc_flag_t {
    #[doc = "< [out] Is 6bpc supported"]
    CTL_OUTPUT_BPC_FLAG_6BPC = 1,
    #[doc = "< [out] Is 8bpc supported"]
    CTL_OUTPUT_BPC_FLAG_8BPC = 2,
    #[doc = "< [out] Is 10bpc supported"]
    CTL_OUTPUT_BPC_FLAG_10BPC = 4,
    #[doc = "< [out] Is 12bpc supported"]
    CTL_OUTPUT_BPC_FLAG_12BPC = 8,
    CTL_OUTPUT_BPC_FLAG_MAX = -2147483648,
}
pub use self::_ctl_output_bpc_flag_t as ctl_output_bpc_flag_t;
#[doc = "\n @brief Display output features. This will indicate only the high level\n        capabilities"]
pub type ctl_std_display_feature_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_std_display_feature_flag_t {
    #[doc = "< [out] Is HDCP supported"]
    CTL_STD_DISPLAY_FEATURE_FLAG_HDCP = 1,
    #[doc = "< [out] Is HD Audio supported"]
    CTL_STD_DISPLAY_FEATURE_FLAG_HD_AUDIO = 2,
    #[doc = "< [out] Is VESA PSR supported"]
    CTL_STD_DISPLAY_FEATURE_FLAG_PSR = 4,
    #[doc = "< [out] Is VESA Adaptive Sync or HDMI VRR supported"]
    CTL_STD_DISPLAY_FEATURE_FLAG_ADAPTIVESYNC_VRR = 8,
    #[doc = "< [out] Is display compression (VESA DSC) supported"]
    CTL_STD_DISPLAY_FEATURE_FLAG_VESA_COMPRESSION = 16,
    #[doc = "< [out] Is HDR supported"]
    CTL_STD_DISPLAY_FEATURE_FLAG_HDR = 32,
    #[doc = "< [out] Is HDMI QMS supported"]
    CTL_STD_DISPLAY_FEATURE_FLAG_HDMI_QMS = 64,
    #[doc = "< [out] Is HDR10+ certified"]
    CTL_STD_DISPLAY_FEATURE_FLAG_HDR10_PLUS_CERTIFIED = 128,
    #[doc = "< [out] Is VESA HDR certified - for future use"]
    CTL_STD_DISPLAY_FEATURE_FLAG_VESA_HDR_CERTIFIED = 256,
    CTL_STD_DISPLAY_FEATURE_FLAG_MAX = -2147483648,
}
pub use self::_ctl_std_display_feature_flag_t as ctl_std_display_feature_flag_t;
#[doc = "\n @brief Advanced Graphics Features provided by Intel Graphics Adapter. This\n        will indicate only the high level capabilities"]
pub type ctl_intel_display_feature_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_intel_display_feature_flag_t {
    #[doc = "< [out] Is DPST supported"]
    CTL_INTEL_DISPLAY_FEATURE_FLAG_DPST = 1,
    #[doc = "< [out] Is LACE supported"]
    CTL_INTEL_DISPLAY_FEATURE_FLAG_LACE = 2,
    #[doc = "< [out] Is DRRS supported"]
    CTL_INTEL_DISPLAY_FEATURE_FLAG_DRRS = 4,
    #[doc = "< [out] Is Intel Arc certified adaptive sync display"]
    CTL_INTEL_DISPLAY_FEATURE_FLAG_ARC_ADAPTIVE_SYNC_CERTIFIED = 8,
    CTL_INTEL_DISPLAY_FEATURE_FLAG_MAX = -2147483648,
}
pub use self::_ctl_intel_display_feature_flag_t as ctl_intel_display_feature_flag_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Attached Display Mux Type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_attached_display_mux_type_t {
    #[doc = "< [out] Native DP / HDMI"]
    CTL_ATTACHED_DISPLAY_MUX_TYPE_NATIVE = 0,
    #[doc = "< [out] Thunderbolt"]
    CTL_ATTACHED_DISPLAY_MUX_TYPE_THUNDERBOLT = 1,
    #[doc = "< [out] USB Type C"]
    CTL_ATTACHED_DISPLAY_MUX_TYPE_TYPE_C = 2,
    #[doc = "< [out] USB4"]
    CTL_ATTACHED_DISPLAY_MUX_TYPE_USB4 = 3,
    CTL_ATTACHED_DISPLAY_MUX_TYPE_MAX = 4,
}
#[doc = "\n @brief Attached Display Mux Type"]
pub use self::_ctl_attached_display_mux_type_t as ctl_attached_display_mux_type_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Signal Standard"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_signal_standard_type_t {
    #[doc = "< [out] Unknown Signal Standard"]
    CTL_SIGNAL_STANDARD_TYPE_UNKNOWN = 0,
    #[doc = "< [out] Custom added timing"]
    CTL_SIGNAL_STANDARD_TYPE_CUSTOM = 1,
    #[doc = "< [out] DMT timing"]
    CTL_SIGNAL_STANDARD_TYPE_DMT = 2,
    #[doc = "< [out] GTF Timing"]
    CTL_SIGNAL_STANDARD_TYPE_GTF = 3,
    #[doc = "< [out] CVT Timing"]
    CTL_SIGNAL_STANDARD_TYPE_CVT = 4,
    #[doc = "< [out] CTA Timing"]
    CTL_SIGNAL_STANDARD_TYPE_CTA = 5,
    CTL_SIGNAL_STANDARD_TYPE_MAX = 6,
}
#[doc = "\n @brief Signal Standard"]
pub use self::_ctl_signal_standard_type_t as ctl_signal_standard_type_t;
#[doc = "\n @brief Protocol Converter Location"]
pub type ctl_protocol_converter_location_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_protocol_converter_location_flag_t {
    #[doc = "< [out] OnBoard Protocol Converter"]
    CTL_PROTOCOL_CONVERTER_LOCATION_FLAG_ONBOARD = 1,
    #[doc = "< [out] External Dongle"]
    CTL_PROTOCOL_CONVERTER_LOCATION_FLAG_EXTERNAL = 2,
    CTL_PROTOCOL_CONVERTER_LOCATION_FLAG_MAX = -2147483648,
}
pub use self::_ctl_protocol_converter_location_flag_t as ctl_protocol_converter_location_flag_t;
#[doc = "\n @brief [out] Display Output configuration related flags which indicate how\n        the output pixel stream drive the panel"]
pub type ctl_display_config_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_display_config_flag_t {
    #[doc = "< [out] DisplayActive 0: InActive 1: Active"]
    CTL_DISPLAY_CONFIG_FLAG_DISPLAY_ACTIVE = 1,
    #[doc = "< [out] DisplayAttached.This Bit indicates if any dongle/display/hub is\n< attached to the encoder. 0: Not Attached 1: Attached"]
    CTL_DISPLAY_CONFIG_FLAG_DISPLAY_ATTACHED = 2,
    #[doc = "< [out] This BIT will be set if a dongle/hub/onboard protocol converter\n< , is attached to the encoder"]
    CTL_DISPLAY_CONFIG_FLAG_IS_DONGLE_CONNECTED_TO_ENCODER = 4,
    #[doc = "< [out] This BIT will be set if dithering is enabled on the encoder"]
    CTL_DISPLAY_CONFIG_FLAG_DITHERING_ENABLED = 8,
    CTL_DISPLAY_CONFIG_FLAG_MAX = -2147483648,
}
pub use self::_ctl_display_config_flag_t as ctl_display_config_flag_t;
#[doc = "\n @brief [out] Encoder configuration related flags which indicate how the\n        output pixel stream drive the panel"]
pub type ctl_encoder_config_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_encoder_config_flag_t {
    #[doc = "< [out] Internal connection or not"]
    CTL_ENCODER_CONFIG_FLAG_INTERNAL_DISPLAY = 1,
    #[doc = "< [out] VESA DisplayID based tiled display which is driven by either\n< multiple physical connections (DisplayPort SST) or virtual streams\n< (DisplayPort MST)"]
    CTL_ENCODER_CONFIG_FLAG_VESA_TILED_DISPLAY = 2,
    #[doc = "< [out] This is set if encoder supports type c display"]
    CTL_ENCODER_CONFIG_FLAG_TYPEC_CAPABLE = 4,
    #[doc = "< [out] This is set if encoder supports Thunderbolt display"]
    CTL_ENCODER_CONFIG_FLAG_TBT_CAPABLE = 8,
    #[doc = "< [out] This BIT will be set if encoder supports dithering"]
    CTL_ENCODER_CONFIG_FLAG_DITHERING_SUPPORTED = 16,
    #[doc = "< [out] This BIT will be set if this is a virtual display.Hardware based\n< features will not be applicable to this display.For collage display\n< this will be set for the virtual output created by driver. For split\n< display this will be set for the virtual split displays created out of\n< one single physical display"]
    CTL_ENCODER_CONFIG_FLAG_VIRTUAL_DISPLAY = 32,
    #[doc = "< [out] This BIT will be set if display is hidden from OS"]
    CTL_ENCODER_CONFIG_FLAG_HIDDEN_DISPLAY = 64,
    #[doc = "< [out] This BIT will be set if this is a collage display"]
    CTL_ENCODER_CONFIG_FLAG_COLLAGE_DISPLAY = 128,
    #[doc = "< [out] This BIT will be set if this is a split display"]
    CTL_ENCODER_CONFIG_FLAG_SPLIT_DISPLAY = 256,
    #[doc = "< [out] This BIT will be set if this is a companion display"]
    CTL_ENCODER_CONFIG_FLAG_COMPANION_DISPLAY = 512,
    #[doc = "< [out] This BIT will be set if this is a Multi GPU collage display"]
    CTL_ENCODER_CONFIG_FLAG_MGPU_COLLAGE_DISPLAY = 1024,
    CTL_ENCODER_CONFIG_FLAG_MAX = -2147483648,
}
pub use self::_ctl_encoder_config_flag_t as ctl_encoder_config_flag_t;
#[doc = "\n @brief Display Timing"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_display_timing_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Pixel Clock in Hz"]
    pub PixelClock: u64,
    #[doc = "< [out] Horizontal Active"]
    pub HActive: u32,
    #[doc = "< [out] Vertical Active"]
    pub VActive: u32,
    #[doc = "< [out] Horizontal Total"]
    pub HTotal: u32,
    #[doc = "< [out] Vertical Total"]
    pub VTotal: u32,
    #[doc = "< [out] Horizontal Blank"]
    pub HBlank: u32,
    #[doc = "< [out] Vertical Blank"]
    pub VBlank: u32,
    #[doc = "< [out] Horizontal Blank"]
    pub HSync: u32,
    #[doc = "< [out] Vertical Blank"]
    pub VSync: u32,
    #[doc = "< [out] Refresh Rate"]
    pub RefreshRate: f32,
    #[doc = "< [out] Signal Standard"]
    pub SignalStandard: ctl_signal_standard_type_t,
    #[doc = "< [out] VIC ID for CTA timings"]
    pub VicId: u8,
}
impl Default for _ctl_display_timing_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief This structure will contain the properties of the display currently\n        attached to the encoder."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_display_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] OS specific Display ID"]
    pub Os_display_encoder_handle: ctl_os_display_encoder_identifier_t,
    #[doc = "< [out] Device Type from display HW stand point. If a DisplayPort\n< protocol converter is involved, this will indicate it's DisplayPort.\n< The protocol converter's output will be available from\n< ProtocolConverterOutput field"]
    pub Type: ctl_display_output_types_t,
    #[doc = "< [out] Attached Display Mux Type"]
    pub AttachedDisplayMuxType: ctl_attached_display_mux_type_t,
    #[doc = "< [out] Protocol output type which can be used if config flags indicate\n< it's a protocol converter. If it's not a protocol converter this will\n< be set to CTL_DISPLAY_OUTPUT_TYPES_INVALID"]
    pub ProtocolConverterOutput: ctl_display_output_types_t,
    #[doc = "< [out] Supported industry spec version."]
    pub SupportedSpec: ctl_revision_datatype_t,
    #[doc = "< [out] Supported output bits per color. Refer ::ctl_output_bpc_flag_t.\n< This is independent of RGB or YCbCr output.This is the max BPC\n< supported.BPC will vary per mode based on restrictions like bandwidth\n< and monitor support"]
    pub SupportedOutputBPCFlags: ctl_output_bpc_flags_t,
    #[doc = "< [out] Currently Active Protocol Converter. Refer\n< ::ctl_protocol_converter_location_flag_t"]
    pub ProtocolConverterType: ctl_protocol_converter_location_flags_t,
    #[doc = "< [out] Output configuration related flags which indicate how the output\n< pixel stream drive the panel. Refer ::ctl_display_config_flag_t"]
    pub DisplayConfigFlags: ctl_display_config_flags_t,
    #[doc = "< [out] Enabled Display features.Refer ::ctl_std_display_feature_flag_t."]
    pub FeatureEnabledFlags: ctl_std_display_feature_flags_t,
    #[doc = "< [out] Display Supported feature.Refer ::ctl_std_display_feature_flag_t"]
    pub FeatureSupportedFlags: ctl_std_display_feature_flags_t,
    #[doc = "< [out] Enabled advanced feature.Refer\n< ::ctl_intel_display_feature_flag_t."]
    pub AdvancedFeatureEnabledFlags: ctl_intel_display_feature_flags_t,
    #[doc = "< [out] Supported advanced feature.Refer\n< ::ctl_intel_display_feature_flag_t."]
    pub AdvancedFeatureSupportedFlags: ctl_intel_display_feature_flags_t,
    #[doc = "< [out] Applied Timing on the Display"]
    pub Display_Timing_Info: ctl_display_timing_t,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
impl Default for _ctl_display_properties_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _ctl_display_properties_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "_ctl_display_properties_t {{ Os_display_encoder_handle: {:?}, Type: {:?}, AttachedDisplayMuxType: {:?}, ProtocolConverterOutput: {:?}, SupportedSpec: {:?}, Display_Timing_Info: {:?}, ReservedFields: {:?} }}" , self . Os_display_encoder_handle , self . Type , self . AttachedDisplayMuxType , self . ProtocolConverterOutput , self . SupportedSpec , self . Display_Timing_Info , self . ReservedFields)
    }
}
#[doc = "\n @brief Adapter's display encoder properties"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_adapter_display_encoder_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] OS specific Display ID"]
    pub Os_display_encoder_handle: ctl_os_display_encoder_identifier_t,
    #[doc = "< [out] Device Type from display HW stand point. If a DisplayPort\n< protocol converter is involved, this will indicate it's DisplayPort.\n< The protocol converter's output will be available from\n< ProtocolConverterOutput field"]
    pub Type: ctl_display_output_types_t,
    #[doc = "< [out] Protocol output type which can be used if it's a protocol\n< converter. If it's not a protocol converter this will be set to\n< CTL_DISPLAY_OUTPUT_TYPES_INVALID"]
    pub IsOnBoardProtocolConverterOutputPresent: bool,
    #[doc = "< [out] Supported industry spec version"]
    pub SupportedSpec: ctl_revision_datatype_t,
    #[doc = "< [out] Supported output bits per color. Refer ::ctl_output_bpc_flag_t.\n< This is independent of RGB or YCbCr output.This is the max BPC\n< supported.BPC will vary per mode based on restrictions like bandwidth\n< and monitor support"]
    pub SupportedOutputBPCFlags: ctl_output_bpc_flags_t,
    #[doc = "< [out] Output configuration related flags which indicate how the output\n< pixel stream drive the panel. Refer ::ctl_encoder_config_flag_t\n< Note:\n<    Virtual = 1: This indicates that its a software display. Hardware\n< based features will not be applicable to this display.\n<    Collage=1,Virtual=1: Indicates the fake display output created by\n< driver which has the combined resolution of multiple physical displays\n< involved in collage configuration\n<    Collage=1,Virtual=0: Indicates the child physical displays involved\n< in a collage configuration. These are real physical outputs\n<    Split=1,Virtual=1  : Indicates the fake display output created by\n< driver which occupies a portion of a real physical display\n<    Split=1,Virtual=0  : Indicates the physical display which got split\n< to form multiple split displays\n<    Split=1,Collage=1  : Invalid combination\n<    MgpuCollage=1,Collage=1,Virtual=1: Indicates the fake display\n< output created by driver which has the combined resolution of multiple\n< physical displays spread across multiple GPUs involved in Multi-GPU\n< collage configuration\n<    MgpuCollage=1,Collage=1,Virtual=0: Indicates the child physical\n< displays involved in a Multi-GPU collage configuration. These are real\n< physical outputs"]
    pub EncoderConfigFlags: ctl_encoder_config_flags_t,
    #[doc = "< [out] Adapter Supported feature flags. Refer\n< ::ctl_std_display_feature_flag_t"]
    pub FeatureSupportedFlags: ctl_std_display_feature_flags_t,
    #[doc = "< [out] Advanced Features Supported by the Adapter. Refer\n< ::ctl_intel_display_feature_flag_t"]
    pub AdvancedFeatureSupportedFlags: ctl_intel_display_feature_flags_t,
    #[doc = "< [out] Reserved field of 60 bytes"]
    pub ReservedFields: [u32; 16usize],
}
impl Default for _ctl_adapter_display_encoder_properties_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _ctl_adapter_display_encoder_properties_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "_ctl_adapter_display_encoder_properties_t {{ Os_display_encoder_handle: {:?}, Type: {:?}, IsOnBoardProtocolConverterOutputPresent: {:?}, SupportedSpec: {:?}, ReservedFields: {:?} }}" , self . Os_display_encoder_handle , self . Type , self . IsOnBoardProtocolConverterOutputPresent , self . SupportedSpec , self . ReservedFields)
    }
}
#[doc = "\n @brief Various sharpness filter types"]
pub type ctl_sharpness_filter_type_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_sharpness_filter_type_flag_t {
    #[doc = "< Non-adaptive sharpness"]
    CTL_SHARPNESS_FILTER_TYPE_FLAG_NON_ADAPTIVE = 1,
    #[doc = "< Adaptive sharpness"]
    CTL_SHARPNESS_FILTER_TYPE_FLAG_ADAPTIVE = 2,
    CTL_SHARPNESS_FILTER_TYPE_FLAG_MAX = -2147483648,
}
pub use self::_ctl_sharpness_filter_type_flag_t as ctl_sharpness_filter_type_flag_t;
#[doc = "\n @brief Sharpness filter properties"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_sharpness_filter_properties_t {
    #[doc = "< [out] Filter type. Refer ::ctl_sharpness_filter_type_flag_t"]
    pub FilterType: ctl_sharpness_filter_type_flags_t,
    #[doc = "< [out] Min, max & step size information"]
    pub FilterDetails: ctl_property_range_info_t,
}
#[doc = "\n @brief Various sharpness filter types"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_sharpness_caps_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Supported sharpness filters for a given display output. Refer\n< ::ctl_sharpness_filter_type_flag_t"]
    pub SupportedFilterFlags: ctl_sharpness_filter_type_flags_t,
    #[doc = "< [out] Number of elements in filter properties array"]
    pub NumFilterTypes: u8,
    #[doc = "< [in,out] Array of filter properties structure describing supported\n< filter capabilities. Caller should provide a pre-allocated memory for\n< this."]
    pub pFilterProperty: *mut ctl_sharpness_filter_properties_t,
}
impl Default for _ctl_sharpness_caps_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Current sharpness setting"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_sharpness_settings_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Current or new state of sharpness setting"]
    pub Enable: bool,
    #[doc = "< [in,out] Current or new filter to be set. Refer\n< ::ctl_sharpness_filter_type_flag_t"]
    pub FilterType: ctl_sharpness_filter_type_flags_t,
    #[doc = "< [in,out] Setting intensity to be applied"]
    pub Intensity: f32,
}
#[doc = "\n @brief I2C Access Args input Flags bitmasks"]
pub type ctl_i2c_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_i2c_flag_t {
    #[doc = "< Force Atomic I2C."]
    CTL_I2C_FLAG_ATOMICI2C = 1,
    #[doc = "< 1-byte Indexed operation. If no Index Size flag set, decided based on\n< Offset Value."]
    CTL_I2C_FLAG_1BYTE_INDEX = 2,
    #[doc = "< 2-byte Indexed operation. If no Index Size flag set, decided based on\n< Offset Value."]
    CTL_I2C_FLAG_2BYTE_INDEX = 4,
    #[doc = "< 4-byte Indexed operation. If no Index Size flag set, decided based on\n< Offset Value."]
    CTL_I2C_FLAG_4BYTE_INDEX = 8,
    #[doc = "< If no Speed Flag is set, defaults to Best Option possible."]
    CTL_I2C_FLAG_SPEED_SLOW = 16,
    #[doc = "< If no Speed Flag is set, defaults to Best Option possible."]
    CTL_I2C_FLAG_SPEED_FAST = 32,
    #[doc = "< Uses Slower access using SW bit bashing method. If no Speed Flag is\n< set, defaults to Best Option possible."]
    CTL_I2C_FLAG_SPEED_BIT_BASH = 64,
    CTL_I2C_FLAG_MAX = -2147483648,
}
pub use self::_ctl_i2c_flag_t as ctl_i2c_flag_t;
#[doc = "\n @brief I2C access arguments"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_i2c_access_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Valid data size"]
    pub DataSize: u32,
    #[doc = "< [in] Address to read or write"]
    pub Address: u32,
    #[doc = "< [in] Operation type, 1 for Read, 2 for Write, for Write operation, App\n< needs to run with admin privileges"]
    pub OpType: ctl_operation_type_t,
    #[doc = "< [in] Offset"]
    pub Offset: u32,
    #[doc = "< [in] I2C Flags. Refer ::ctl_i2c_flag_t"]
    pub Flags: ctl_i2c_flags_t,
    #[doc = "< [in] RAD, For Future use, to be used for branch devices, Interface\n< will be provided to get RAD"]
    pub RAD: u64,
    #[doc = "< [in,out] Data array"]
    pub Data: [u8; 128usize],
}
impl Default for _ctl_i2c_access_args_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief I2C Access on PinPair Args input Flags bitmasks"]
pub type ctl_i2c_pinpair_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_i2c_pinpair_flag_t {
    #[doc = "< Force Atomic I2C."]
    CTL_I2C_PINPAIR_FLAG_ATOMICI2C = 1,
    #[doc = "< 1-byte Indexed operation. If no Index Size flag set, decided based on\n< Offset Value."]
    CTL_I2C_PINPAIR_FLAG_1BYTE_INDEX = 2,
    #[doc = "< 2-byte Indexed operation. If no Index Size flag set, decided based on\n< Offset Value."]
    CTL_I2C_PINPAIR_FLAG_2BYTE_INDEX = 4,
    #[doc = "< 4-byte Indexed operation. If no Index Size flag set, decided based on\n< Offset Value."]
    CTL_I2C_PINPAIR_FLAG_4BYTE_INDEX = 8,
    #[doc = "< If no Speed Flag is set, defaults to Best Option possible."]
    CTL_I2C_PINPAIR_FLAG_SPEED_SLOW = 16,
    #[doc = "< If no Speed Flag is set, defaults to Best Option possible."]
    CTL_I2C_PINPAIR_FLAG_SPEED_FAST = 32,
    #[doc = "< Uses Slower access using SW bit bashing method. If no Speed Flag is\n< set, defaults to Best Option possible."]
    CTL_I2C_PINPAIR_FLAG_SPEED_BIT_BASH = 64,
    CTL_I2C_PINPAIR_FLAG_MAX = -2147483648,
}
pub use self::_ctl_i2c_pinpair_flag_t as ctl_i2c_pinpair_flag_t;
#[doc = "\n @brief I2C access on Pin Pair arguments"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_i2c_access_pinpair_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Valid data size"]
    pub DataSize: u32,
    #[doc = "< [in] Address to read or write"]
    pub Address: u32,
    #[doc = "< [in] Operation type, 1 for Read, 2 for Write, for Write operation, App\n< needs to run with admin privileges"]
    pub OpType: ctl_operation_type_t,
    #[doc = "< [in] Offset"]
    pub Offset: u32,
    #[doc = "< [in] I2C Flags. Refer ::ctl_i2c_pinpair_flag_t"]
    pub Flags: ctl_i2c_pinpair_flags_t,
    #[doc = "< [in,out] Data array"]
    pub Data: [u8; 128usize],
    #[doc = "< [in] Reserved for future use, must be set to Zero."]
    pub ReservedFields: [u32; 4usize],
}
impl Default for _ctl_i2c_access_pinpair_args_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief AUX Flags bitmasks"]
pub type ctl_aux_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_aux_flag_t {
    #[doc = "< For Native AUX operation"]
    CTL_AUX_FLAG_NATIVE_AUX = 1,
    #[doc = "< For I2C AUX operation"]
    CTL_AUX_FLAG_I2C_AUX = 2,
    #[doc = "< For I2C AUX MOT operation"]
    CTL_AUX_FLAG_I2C_AUX_MOT = 4,
    CTL_AUX_FLAG_MAX = -2147483648,
}
pub use self::_ctl_aux_flag_t as ctl_aux_flag_t;
#[doc = "\n @brief AUX access arguments"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_aux_access_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Operation type, 1 for Read, 2 for Write, for Write operation, App\n< needs to run with admin privileges"]
    pub OpType: ctl_operation_type_t,
    #[doc = "< [in] Aux Flags. Refer ::ctl_aux_flag_t"]
    pub Flags: ctl_aux_flags_t,
    #[doc = "< [in] Address to read or write"]
    pub Address: u32,
    #[doc = "< [in] RAD, For Future use, to be used for branch devices, Interface\n< will be provided to get RAD"]
    pub RAD: u64,
    #[doc = "< [in] Port ID, For Future use, to be used for SST tiled devices"]
    pub PortID: u32,
    #[doc = "< [in,out] Valid data size"]
    pub DataSize: u32,
    #[doc = "< [in,out] Data array"]
    pub Data: [u8; 132usize],
}
impl Default for _ctl_aux_access_args_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Power saving features (Each individual feature's set & get call can be\n        called only once at a time)"]
pub type ctl_power_optimization_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_power_optimization_flag_t {
    #[doc = "< Frame buffer compression"]
    CTL_POWER_OPTIMIZATION_FLAG_FBC = 1,
    #[doc = "< Panel self refresh"]
    CTL_POWER_OPTIMIZATION_FLAG_PSR = 2,
    #[doc = "< Display power saving technology (Panel technology dependent)"]
    CTL_POWER_OPTIMIZATION_FLAG_DPST = 4,
    #[doc = "< Low refresh rate (LRR/ALRR/UBRR), UBRR is supported only for IGCC and\n< NDA clients. UBZRR and UBLRR both can not be enabled at the same time,\n< only one can be enabled at a given time"]
    CTL_POWER_OPTIMIZATION_FLAG_LRR = 8,
    #[doc = "< Lighting Aware Contrast Enhancement"]
    CTL_POWER_OPTIMIZATION_FLAG_LACE = 16,
    CTL_POWER_OPTIMIZATION_FLAG_MAX = -2147483648,
}
pub use self::_ctl_power_optimization_flag_t as ctl_power_optimization_flag_t;
#[doc = "\n @brief GPU/Panel/TCON dependent power optimization technology"]
pub type ctl_power_optimization_dpst_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_power_optimization_dpst_flag_t {
    #[doc = "< Intel DPST with Backlight control"]
    CTL_POWER_OPTIMIZATION_DPST_FLAG_BKLT = 1,
    #[doc = "< Panel TCON specific Content Adaptive Control mechanism"]
    CTL_POWER_OPTIMIZATION_DPST_FLAG_PANEL_CABC = 2,
    #[doc = "< Intel OLED Power Saving Technology"]
    CTL_POWER_OPTIMIZATION_DPST_FLAG_OPST = 4,
    #[doc = "< TCON based Edge Luminance Profile"]
    CTL_POWER_OPTIMIZATION_DPST_FLAG_ELP = 8,
    #[doc = "< Extra power saving mode"]
    CTL_POWER_OPTIMIZATION_DPST_FLAG_EPSM = 16,
    #[doc = "< Adaptive Pixel Dimming"]
    CTL_POWER_OPTIMIZATION_DPST_FLAG_APD = 32,
    #[doc = "< TCON+ based DPST like solution"]
    CTL_POWER_OPTIMIZATION_DPST_FLAG_PIXOPTIX = 64,
    CTL_POWER_OPTIMIZATION_DPST_FLAG_MAX = -2147483648,
}
pub use self::_ctl_power_optimization_dpst_flag_t as ctl_power_optimization_dpst_flag_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Power Source"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_power_source_t {
    #[doc = "< Power Source AC"]
    CTL_POWER_SOURCE_AC = 0,
    #[doc = "< Power Source DC"]
    CTL_POWER_SOURCE_DC = 1,
    CTL_POWER_SOURCE_MAX = 2,
}
#[doc = "\n @brief Power Source"]
pub use self::_ctl_power_source_t as ctl_power_source_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Power Optimization Plan"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_power_optimization_plan_t {
    #[doc = "< Balanced mode"]
    CTL_POWER_OPTIMIZATION_PLAN_BALANCED = 0,
    #[doc = "< High Performance Mode"]
    CTL_POWER_OPTIMIZATION_PLAN_HIGH_PERFORMANCE = 1,
    #[doc = "< Power Saver Mode"]
    CTL_POWER_OPTIMIZATION_PLAN_POWER_SAVER = 2,
    CTL_POWER_OPTIMIZATION_PLAN_MAX = 3,
}
#[doc = "\n @brief Power Optimization Plan"]
pub use self::_ctl_power_optimization_plan_t as ctl_power_optimization_plan_t;
#[doc = "\n @brief Type of low refresh rate feature"]
pub type ctl_power_optimization_lrr_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_power_optimization_lrr_flag_t {
    #[doc = "< LRR 1.0"]
    CTL_POWER_OPTIMIZATION_LRR_FLAG_LRR10 = 1,
    #[doc = "< LRR 2.0"]
    CTL_POWER_OPTIMIZATION_LRR_FLAG_LRR20 = 2,
    #[doc = "< LRR 2.5"]
    CTL_POWER_OPTIMIZATION_LRR_FLAG_LRR25 = 4,
    #[doc = "< Autonomous LRR"]
    CTL_POWER_OPTIMIZATION_LRR_FLAG_ALRR = 8,
    #[doc = "< User based low refresh rate"]
    CTL_POWER_OPTIMIZATION_LRR_FLAG_UBLRR = 16,
    #[doc = "< User based zero refresh rate"]
    CTL_POWER_OPTIMIZATION_LRR_FLAG_UBZRR = 32,
    CTL_POWER_OPTIMIZATION_LRR_FLAG_MAX = -2147483648,
}
pub use self::_ctl_power_optimization_lrr_flag_t as ctl_power_optimization_lrr_flag_t;
#[doc = "\n @brief Power optimization caps"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_power_optimization_caps_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Supported power optimization features. Refer\n< ::ctl_power_optimization_flag_t"]
    pub SupportedFeatures: ctl_power_optimization_flags_t,
}
#[doc = "\n @brief LRR detailed settings"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_power_optimization_lrr_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] LRR type(s). Refer ::ctl_power_optimization_lrr_flag_t"]
    pub SupportedLRRTypes: ctl_power_optimization_lrr_flags_t,
    #[doc = "< [in,out] Current enabled LRR type(s) or the LRR type(s) to set to.\n< Refer ::ctl_power_optimization_lrr_flag_t"]
    pub CurrentLRRTypes: ctl_power_optimization_lrr_flags_t,
    #[doc = "< [out] Require PSR disable for any change in the selected LRR feature.\n< Caller can re-enable PSR once the respective LRR feature is\n< enable/disabled. E.g. for UBRR based on platform this flag may not be\n< set in which case caller doesn't need to do an explicit PSR disable"]
    pub bRequirePSRDisable: bool,
    #[doc = "< [out] Lowest RR used for LRR functionality if known to source"]
    pub LowRR: u16,
}
#[doc = "\n @brief PSR detailed settings"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_power_optimization_psr_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] A value of 1 means PSR1, 2 means PSR2"]
    pub PSRVersion: u8,
    #[doc = "< [in,out] Full fetch and update"]
    pub FullFetchUpdate: bool,
}
#[doc = "\n @brief DPST detailed settings"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_power_optimization_dpst_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Minimum supported aggressiveness level"]
    pub MinLevel: u8,
    #[doc = "< [out] Maximum supported aggressiveness level"]
    pub MaxLevel: u8,
    #[doc = "< [in,out] Current aggressiveness level to be set"]
    pub Level: u8,
    #[doc = "< [out] Supported features"]
    pub SupportedFeatures: ctl_power_optimization_dpst_flags_t,
    #[doc = "< [in,out] Features enabled or to be enabled. Fill only one feature for\n< SET call"]
    pub EnabledFeatures: ctl_power_optimization_dpst_flags_t,
}
#[doc = "\n @brief Feature specific power optimization data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ctl_power_optimization_feature_specific_info_t {
    #[doc = "< [out] LRR info"]
    pub LRRInfo: ctl_power_optimization_lrr_t,
    #[doc = "< [in,out] PSR info"]
    pub PSRInfo: ctl_power_optimization_psr_t,
    #[doc = "< [in,out] DPST info"]
    pub DPSTInfo: ctl_power_optimization_dpst_t,
}
impl Default for _ctl_power_optimization_feature_specific_info_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _ctl_power_optimization_feature_specific_info_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_ctl_power_optimization_feature_specific_info_t {{ union }}"
        )
    }
}
#[doc = "\n @brief Feature specific power optimization data"]
pub type ctl_power_optimization_feature_specific_info_t =
    _ctl_power_optimization_feature_specific_info_t;
#[doc = "\n @brief Power optimization settings"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_power_optimization_settings_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Power optimization power plan (max power/max perf/balanced)"]
    pub PowerOptimizationPlan: ctl_power_optimization_plan_t,
    #[doc = "< [in] Power optimization feature interested in. Refer\n< ::ctl_power_optimization_flag_t"]
    pub PowerOptimizationFeature: ctl_power_optimization_flags_t,
    #[doc = "< [in,out] Enable state"]
    pub Enable: bool,
    #[doc = "< [in,out] Data specific to the feature caller is interested in"]
    pub FeatureSpecificData: ctl_power_optimization_feature_specific_info_t,
    #[doc = "< [in] AC/DC"]
    pub PowerSource: ctl_power_source_t,
}
impl Default for _ctl_power_optimization_settings_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _ctl_power_optimization_settings_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "_ctl_power_optimization_settings_t {{ PowerOptimizationPlan: {:?}, Enable: {:?}, FeatureSpecificData: {:?}, PowerSource: {:?} }}" , self . PowerOptimizationPlan , self . Enable , self . FeatureSpecificData , self . PowerSource)
    }
}
#[doc = "\n @brief Brightness settings for SET call"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_set_brightness_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] The brightness level that the display need to transitioning to in\n< milli-percentage. Range is 0-100000 (100%)"]
    pub TargetBrightness: u32,
    #[doc = "< [in] Transition Time for brightness to take effect in milli-seconds.\n< If its 0 then it will be an immediate change. Maximum possible value\n< is 1000ms."]
    pub SmoothTransitionTimeInMs: u32,
    #[doc = "< [in] Reserved for future use"]
    pub ReservedFields: [u32; 4usize],
}
#[doc = "\n @brief Brightness settings for GET call"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_get_brightness_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] The brightness level that the display is currently transitioning\n< to in milli-percentage. If not in a transition, this should equal the\n< current brightness. Range is 0-100000 (100%)"]
    pub TargetBrightness: u32,
    #[doc = "< [out] The current brightness level of the display in milli-percentage"]
    pub CurrentBrightness: u32,
    #[doc = "< [out] Reserved for future use"]
    pub ReservedFields: [u32; 4usize],
}
#[doc = "\n @brief Pixtx pipe set configuration flags bitmasks"]
pub type ctl_pixtx_pipe_set_config_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_pixtx_pipe_set_config_flag_t {
    #[doc = "< For maintaining persistance across power events"]
    CTL_PIXTX_PIPE_SET_CONFIG_FLAG_PERSIST_ACROSS_POWER_EVENTS = 1,
    CTL_PIXTX_PIPE_SET_CONFIG_FLAG_MAX = -2147483648,
}
pub use self::_ctl_pixtx_pipe_set_config_flag_t as ctl_pixtx_pipe_set_config_flag_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Pixel transformation block types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_pixtx_block_type_t {
    #[doc = "< Block type 1D LUT"]
    CTL_PIXTX_BLOCK_TYPE_1D_LUT = 1,
    #[doc = "< Block type 3D LUT"]
    CTL_PIXTX_BLOCK_TYPE_3D_LUT = 2,
    #[doc = "< Block type 3x3 matrix"]
    CTL_PIXTX_BLOCK_TYPE_3X3_MATRIX = 3,
    #[doc = "< Block type 3x3 matrix and offsets"]
    CTL_PIXTX_BLOCK_TYPE_3X3_MATRIX_AND_OFFSETS = 4,
    CTL_PIXTX_BLOCK_TYPE_MAX = 5,
}
#[doc = "\n @brief Pixel transformation block types"]
pub use self::_ctl_pixtx_block_type_t as ctl_pixtx_block_type_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Pixel transformation LUT sampling types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_pixtx_lut_sampling_type_t {
    #[doc = "< Uniform LUT sampling"]
    CTL_PIXTX_LUT_SAMPLING_TYPE_UNIFORM = 0,
    #[doc = "< Non uniform LUT sampling, Required mainly in HDR mode"]
    CTL_PIXTX_LUT_SAMPLING_TYPE_NONUNIFORM = 1,
    CTL_PIXTX_LUT_SAMPLING_TYPE_MAX = 2,
}
#[doc = "\n @brief Pixel transformation LUT sampling types"]
pub use self::_ctl_pixtx_lut_sampling_type_t as ctl_pixtx_lut_sampling_type_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Configuration query types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_pixtx_config_query_type_t {
    #[doc = "< Get complete pixel processing pipeline capability"]
    CTL_PIXTX_CONFIG_QUERY_TYPE_CAPABILITY = 0,
    #[doc = "< Get the configuration set through last set call"]
    CTL_PIXTX_CONFIG_QUERY_TYPE_CURRENT = 1,
    CTL_PIXTX_CONFIG_QUERY_TYPE_MAX = 2,
}
#[doc = "\n @brief Configuration query types"]
pub use self::_ctl_pixtx_config_query_type_t as ctl_pixtx_config_query_type_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Configuration operation types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_pixtx_config_opertaion_type_t {
    #[doc = "< Restore block by block or entire pipe line. Use NumBlocks = 0 to\n< restore all."]
    CTL_PIXTX_CONFIG_OPERTAION_TYPE_RESTORE_DEFAULT = 1,
    #[doc = "< Custom LUT or matrix can be set thorugh this option."]
    CTL_PIXTX_CONFIG_OPERTAION_TYPE_SET_CUSTOM = 2,
    CTL_PIXTX_CONFIG_OPERTAION_TYPE_MAX = 3,
}
#[doc = "\n @brief Configuration operation types"]
pub use self::_ctl_pixtx_config_opertaion_type_t as ctl_pixtx_config_opertaion_type_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Pixel transformation gamma encoding types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_pixtx_gamma_encoding_type_t {
    #[doc = "< Gamma encoding SRGB"]
    CTL_PIXTX_GAMMA_ENCODING_TYPE_SRGB = 0,
    #[doc = "< Gamma encoding REC709, Applicable for REC2020 as well"]
    CTL_PIXTX_GAMMA_ENCODING_TYPE_REC709 = 1,
    #[doc = "< Gamma encoding ST2084"]
    CTL_PIXTX_GAMMA_ENCODING_TYPE_ST2084 = 2,
    #[doc = "< Gamma encoding HLG"]
    CTL_PIXTX_GAMMA_ENCODING_TYPE_HLG = 3,
    #[doc = "< Gamma encoding linear"]
    CTL_PIXTX_GAMMA_ENCODING_TYPE_LINEAR = 4,
    CTL_PIXTX_GAMMA_ENCODING_TYPE_MAX = 5,
}
#[doc = "\n @brief Pixel transformation gamma encoding types"]
pub use self::_ctl_pixtx_gamma_encoding_type_t as ctl_pixtx_gamma_encoding_type_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Pixel transformation color space types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_pixtx_color_space_t {
    #[doc = "< Color space REC709"]
    CTL_PIXTX_COLOR_SPACE_REC709 = 0,
    #[doc = "< Color space REC2020"]
    CTL_PIXTX_COLOR_SPACE_REC2020 = 1,
    #[doc = "< Color space AdobeRGB"]
    CTL_PIXTX_COLOR_SPACE_ADOBE_RGB = 2,
    #[doc = "< Color space P3_D65"]
    CTL_PIXTX_COLOR_SPACE_P3_D65 = 3,
    #[doc = "< Color space P3_DCI"]
    CTL_PIXTX_COLOR_SPACE_P3_DCI = 4,
    #[doc = "< Color space P3_D60"]
    CTL_PIXTX_COLOR_SPACE_P3_D60 = 5,
    #[doc = "< Color space custom, Refer ::ctl_pixtx_color_primaries_t for color\n< primary details"]
    CTL_PIXTX_COLOR_SPACE_CUSTOM = 65535,
    CTL_PIXTX_COLOR_SPACE_MAX = 65536,
}
#[doc = "\n @brief Pixel transformation color space types"]
pub use self::_ctl_pixtx_color_space_t as ctl_pixtx_color_space_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Pixel transformation color model types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_pixtx_color_model_t {
    #[doc = "< Color model RGB full range"]
    CTL_PIXTX_COLOR_MODEL_RGB_FR = 0,
    #[doc = "< Color model RGB limited range"]
    CTL_PIXTX_COLOR_MODEL_RGB_LR = 1,
    #[doc = "< Color model YCBCR 422 full range"]
    CTL_PIXTX_COLOR_MODEL_YCBCR_422_FR = 2,
    #[doc = "< Color model YCBCR 422 limited range"]
    CTL_PIXTX_COLOR_MODEL_YCBCR_422_LR = 3,
    #[doc = "< Color model YCBCR 420 full range"]
    CTL_PIXTX_COLOR_MODEL_YCBCR_420_FR = 4,
    #[doc = "< Color model YCBCR 420 limited range"]
    CTL_PIXTX_COLOR_MODEL_YCBCR_420_LR = 5,
    #[doc = "< Color model YCBCR 444 full range"]
    CTL_PIXTX_COLOR_MODEL_YCBCR_444_FR = 6,
    #[doc = "< Color model YCBCR 444 limited range"]
    CTL_PIXTX_COLOR_MODEL_YCBCR_444_LR = 7,
    CTL_PIXTX_COLOR_MODEL_MAX = 8,
}
#[doc = "\n @brief Pixel transformation color model types"]
pub use self::_ctl_pixtx_color_model_t as ctl_pixtx_color_model_t;
#[doc = "\n @brief Pixel transformation color primaries"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_pixtx_color_primaries_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] CIE1931 x value with maximum red pixel value"]
    pub xR: f64,
    #[doc = "< [out] CIE1931 y value with maximum red pixel value"]
    pub yR: f64,
    #[doc = "< [out] CIE1931 x value with maximum green pixel value"]
    pub xG: f64,
    #[doc = "< [out] CIE1931 y value with maximum green pixel value"]
    pub yG: f64,
    #[doc = "< [out] CIE1931 x value with maximum blue pixel value"]
    pub xB: f64,
    #[doc = "< [out] CIE1931 y value with maximum blue pixel value"]
    pub yB: f64,
    #[doc = "< [out] CIE1931 x value with maximum white pixel value"]
    pub xW: f64,
    #[doc = "< [out] CIE1931 y value with maximum white pixel value"]
    pub yW: f64,
}
#[doc = "\n @brief Pixel transformation pixel format"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_pixtx_pixel_format_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Bits per color, It Will be 16 for FP16 case"]
    pub BitsPerColor: u32,
    #[doc = "< [out] Will be set for FP16 or other floating point encoding schemes"]
    pub IsFloat: bool,
    #[doc = "< [out] Encoding type"]
    pub EncodingType: ctl_pixtx_gamma_encoding_type_t,
    #[doc = "< [out] Color space"]
    pub ColorSpace: ctl_pixtx_color_space_t,
    #[doc = "< [out] Color model"]
    pub ColorModel: ctl_pixtx_color_model_t,
    #[doc = "< [out] Color primaries, Used mainly for custom color space"]
    pub ColorPrimaries: ctl_pixtx_color_primaries_t,
    #[doc = "< [out] Maximum brightness of pixel values. If no input is given,\n< default will be set to sRGB during set call. If panel capability is\n< not known get call will default to sRGB."]
    pub MaxBrightness: f64,
    #[doc = "< [out] Minimum brightness of pixel values"]
    pub MinBrightness: f64,
}
impl Default for _ctl_pixtx_pixel_format_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Pixel transformation 1D LUT configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_pixtx_1dlut_config_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Blocks with non-uniform sampling capability support unifrom\n< sampling also but not vice versa."]
    pub SamplingType: ctl_pixtx_lut_sampling_type_t,
    #[doc = "< [in,out] Number of samples per channel. Resampled internally based on\n< HW capability for uniformly sampled LUT.Maximum supported value is\n< ::CTL_MAX_NUM_SAMPLES_PER_CHANNEL_1D_LUT Caller needs to use exact\n< sampling position given in pSamplePositions for non-uniformly sampled\n< LUTs."]
    pub NumSamplesPerChannel: u32,
    #[doc = "< [in,out] Number of channels, 1 for Grey scale LUT, 3 for RGB LUT"]
    pub NumChannels: u32,
    #[doc = "< [in,out] Pointer to sample values, R array followed by G and B arrays\n< in case of multi-channel LUT. Allocation size for pSampleValues should\n< be NumSamplesPerChannel * NumChannels * sizeof(double)"]
    pub pSampleValues: *mut f64,
    #[doc = "< [out] LUT (same for all channels) to represent sampling positions for\n< non-uniformly sampled LUTs.Can be NULL in case uniformly sampled LUTs"]
    pub pSamplePositions: *mut f64,
}
impl Default for _ctl_pixtx_1dlut_config_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Pixel transformation matrix configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_pixtx_matrix_config_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Pre offsets"]
    pub PreOffsets: [f64; 3usize],
    #[doc = "< [in,out] Post offsets"]
    pub PostOffsets: [f64; 3usize],
    #[doc = "< [in,out] 3x3 Matrix"]
    pub Matrix: [[f64; 3usize]; 3usize],
}
#[doc = "\n @brief Pixel transformation 3D LUT sample. Samples are converted to integer\n        based on underlying HW capabilities. Hence slight precision loss will\n        be observed while getting sample values."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_pixtx_3dlut_sample_t {
    #[doc = "< [in,out] Red output value"]
    pub Red: f64,
    #[doc = "< [in,out] Green output value"]
    pub Green: f64,
    #[doc = "< [in,out] Blue output value"]
    pub Blue: f64,
}
#[doc = "\n @brief Pixel transformation 3D LUT configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_pixtx_3dlut_config_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Number of samples per channel"]
    pub NumSamplesPerChannel: u32,
    #[doc = "< [in,out] Pointer to sample values, R in outer most loop followed by G\n< and B"]
    pub pSampleValues: *mut ctl_pixtx_3dlut_sample_t,
}
impl Default for _ctl_pixtx_3dlut_config_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Pixel transformation configuration"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ctl_pixtx_config_t {
    #[doc = "< [in,out] 1D LUT configuration"]
    pub OneDLutConfig: ctl_pixtx_1dlut_config_t,
    #[doc = "< [in,out] 3D LUT configuration"]
    pub ThreeDLutConfig: ctl_pixtx_3dlut_config_t,
    #[doc = "< [in,out] Matrix configuration"]
    pub MatrixConfig: ctl_pixtx_matrix_config_t,
}
impl Default for _ctl_pixtx_config_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _ctl_pixtx_config_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_ctl_pixtx_config_t {{ union }}")
    }
}
#[doc = "\n @brief Pixel transformation configuration"]
pub type ctl_pixtx_config_t = _ctl_pixtx_config_t;
#[doc = "\n @brief Pixel transformation block configuration"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_pixtx_block_config_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Unique ID for each pixel processing block. Id for a block is\n< fixed for a platform."]
    pub BlockId: u32,
    #[doc = "< [in,out] Block type"]
    pub BlockType: ctl_pixtx_block_type_t,
    #[doc = "< [in,out] Configuration"]
    pub Config: ctl_pixtx_config_t,
}
impl Default for _ctl_pixtx_block_config_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _ctl_pixtx_block_config_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_ctl_pixtx_block_config_t {{ BlockType: {:?}, Config: {:?} }}",
            self.BlockType, self.Config
        )
    }
}
#[doc = "\n @brief Pixel transformation pipe get configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_pixtx_pipe_get_config_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Query operation type"]
    pub QueryType: ctl_pixtx_config_query_type_t,
    #[doc = "< [out] Input pixel format"]
    pub InputPixelFormat: ctl_pixtx_pixel_format_t,
    #[doc = "< [out] Output pixel format"]
    pub OutputPixelFormat: ctl_pixtx_pixel_format_t,
    #[doc = "< [out] Number of blocks"]
    pub NumBlocks: u32,
    #[doc = "< [out] Pointer to specific configs"]
    pub pBlockConfigs: *mut ctl_pixtx_block_config_t,
}
impl Default for _ctl_pixtx_pipe_get_config_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Pixel transformation pipe set configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_pixtx_pipe_set_config_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Set operation type"]
    pub OpertaionType: ctl_pixtx_config_opertaion_type_t,
    #[doc = "< [in] Config flags. Refer ::ctl_pixtx_pipe_set_config_flag_t"]
    pub Flags: ctl_pixtx_pipe_set_config_flags_t,
    #[doc = "< [in] Number of blocks"]
    pub NumBlocks: u32,
    #[doc = "< [in,out] Array of block specific configs"]
    pub pBlockConfigs: *mut ctl_pixtx_block_config_t,
}
impl Default for _ctl_pixtx_pipe_set_config_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Panel descriptor access arguments"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_panel_descriptor_access_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Operation type, 1 for Read, 2 for Write. App needs to run with\n< admin privileges for Write operation, Currently only Read operation is\n< supported"]
    pub OpType: ctl_operation_type_t,
    #[doc = "< [in] Block number, Need to provide only if acccessing EDID"]
    pub BlockNumber: u32,
    #[doc = "< [in] Descriptor data size, Should be 0 for querying the size and\n< should be DescriptorDataSize derived from query call otherwise"]
    pub DescriptorDataSize: u32,
    #[doc = "< [in,out] Panel descriptor data"]
    pub pDescriptorData: *mut u8,
}
impl Default for _ctl_panel_descriptor_access_args_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief  Retro Scaling Types"]
pub type ctl_retro_scaling_type_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_retro_scaling_type_flag_t {
    #[doc = "< Integer Scaling"]
    CTL_RETRO_SCALING_TYPE_FLAG_INTEGER = 1,
    #[doc = "< Nearest Neighbour Scaling"]
    CTL_RETRO_SCALING_TYPE_FLAG_NEAREST_NEIGHBOUR = 2,
    CTL_RETRO_SCALING_TYPE_FLAG_MAX = -2147483648,
}
pub use self::_ctl_retro_scaling_type_flag_t as ctl_retro_scaling_type_flag_t;
#[doc = "\n @brief Set/Get Retro Scaling Type"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_retro_scaling_settings_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in][release] Set to true to get current scaling . Set to False to Set\n< the scaling"]
    pub Get: bool,
    #[doc = "< [in,out] State of the scaler"]
    pub Enable: bool,
    #[doc = "< [out] Requested retro scaling types. Refer\n< ::ctl_retro_scaling_type_flag_t"]
    pub RetroScalingType: ctl_retro_scaling_type_flags_t,
}
#[doc = "\n @brief Retro Scaling caps"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_retro_scaling_caps_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Supported retro scaling types"]
    pub SupportedRetroScaling: ctl_retro_scaling_type_flags_t,
}
#[doc = "\n @brief Scaling Types"]
pub type ctl_scaling_type_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_scaling_type_flag_t {
    #[doc = "< No scaling is applied and display manages scaling itself when possible"]
    CTL_SCALING_TYPE_FLAG_IDENTITY = 1,
    #[doc = "< Source is not scaled but place in the center of the target display"]
    CTL_SCALING_TYPE_FLAG_CENTERED = 2,
    #[doc = "< Source is stretched to fit the target size"]
    CTL_SCALING_TYPE_FLAG_STRETCHED = 4,
    #[doc = "< The aspect ratio is maintained with the source centered"]
    CTL_SCALING_TYPE_FLAG_ASPECT_RATIO_CENTERED_MAX = 8,
    #[doc = "< None of the standard types match this .Additional parameters are\n< required which should be set via a private driver interface"]
    CTL_SCALING_TYPE_FLAG_CUSTOM = 16,
    CTL_SCALING_TYPE_FLAG_MAX = -2147483648,
}
pub use self::_ctl_scaling_type_flag_t as ctl_scaling_type_flag_t;
#[doc = "\n @brief Scaling caps"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_scaling_caps_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Supported scaling types. Refer ::ctl_scaling_type_flag_t"]
    pub SupportedScaling: ctl_scaling_type_flags_t,
}
#[doc = "\n @brief Set/Get Scaling type"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_scaling_settings_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] State of the scaler"]
    pub Enable: bool,
    #[doc = "< [in,out] Requested scaling type. In Get call this field indicates\n< 'currunt' scaling set. Refer ::ctl_scaling_type_flag_t"]
    pub ScalingType: ctl_scaling_type_flags_t,
    #[doc = "< [in,out] Custom Scaling X in percentage. This is percentage of current\n< OS resolution. Valid values are 0 to 100. Up to 11% of native\n< resolution can be downscaled"]
    pub CustomScalingX: u32,
    #[doc = "< [in,out] Custom Scaling Y in percentage. This is percentage of current\n< OS resolution. Valid values are 0 to 100. Up to 11% of native\n< resolution can be downscaled"]
    pub CustomScalingY: u32,
    #[doc = "< [in] Flag to indicate hardware modeset should be done to apply the\n< scaling.Setting this to true would result in a flash on the screen. If\n< this flag is set to false , API will request the OS to do a virtual\n< modeset , but the OS can ignore this request and do a hardware modeset\n< in some instances"]
    pub HardwareModeSet: bool,
    #[doc = "< [out] Indicates OS persisted scaling type. This field is only valid\n< when version > 0. Refer ::ctl_scaling_type_flag_t"]
    pub PreferredScalingType: ctl_scaling_type_flags_t,
}
#[doc = "\n @brief Ambient light based enhancement table entry"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_lace_lux_aggr_map_entry_t {
    #[doc = "< [in,out] Ambient lux"]
    pub Lux: u32,
    #[doc = "< [in,out] Pixel boost agressiveness"]
    pub AggressivenessPercent: u8,
}
#[doc = "\n @brief Ambient light based enhancement table"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_lace_lux_aggr_map_t {
    #[doc = "< [out] Max Number of entries in mapping table supported"]
    pub MaxNumEntries: u32,
    #[doc = "< [in,out] Number of entries in the given mapping table"]
    pub NumEntries: u32,
    #[doc = "< [in] Max number of Entries which can be passed in\n< LuxToAggrMappingTable"]
    pub pLuxToAggrMappingTable: *mut ctl_lace_lux_aggr_map_entry_t,
}
impl Default for _ctl_lace_lux_aggr_map_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Data specific to the mode caller is interested in"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ctl_lace_aggr_config_t {
    #[doc = "< [in,out] Fixed aggressiveness level, applicable for\n< CTL_LACE_MODE_FIXED_AGGR_LEVEL"]
    pub FixedAggressivenessLevelPercent: u8,
    #[doc = "< [in,out] Lux to enhancement mapping table, applicable for\n< CTL_LACE_MODE_AMBIENT_ADAPTIVE"]
    pub AggrLevelMap: ctl_lace_lux_aggr_map_t,
}
impl Default for _ctl_lace_aggr_config_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _ctl_lace_aggr_config_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "_ctl_lace_aggr_config_t {{ union }}")
    }
}
#[doc = "\n @brief Data specific to the mode caller is interested in"]
pub type ctl_lace_aggr_config_t = _ctl_lace_aggr_config_t;
#[doc = "\n @brief Get Operations used for additional settings"]
pub type ctl_get_operation_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_get_operation_flag_t {
    #[doc = "< Get the details set through last set call"]
    CTL_GET_OPERATION_FLAG_CURRENT = 1,
    #[doc = "< Get the driver default values"]
    CTL_GET_OPERATION_FLAG_DEFAULT = 2,
    #[doc = "< Get capability"]
    CTL_GET_OPERATION_FLAG_CAPABILITY = 4,
    CTL_GET_OPERATION_FLAG_MAX = -2147483648,
}
pub use self::_ctl_get_operation_flag_t as ctl_get_operation_flag_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Set Operations used for additional settings"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_set_operation_t {
    #[doc = "< Restore default values"]
    CTL_SET_OPERATION_RESTORE_DEFAULT = 0,
    #[doc = "< Set custom values"]
    CTL_SET_OPERATION_CUSTOM = 1,
    CTL_SET_OPERATION_MAX = 2,
}
#[doc = "\n @brief Set Operations used for additional settings"]
pub use self::_ctl_set_operation_t as ctl_set_operation_t;
#[doc = "\n @brief  Lace Trigger Modes"]
pub type ctl_lace_trigger_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_lace_trigger_flag_t {
    #[doc = "< LACE enhancement depends on Ambient light"]
    CTL_LACE_TRIGGER_FLAG_AMBIENT_LIGHT = 1,
    #[doc = "< LACE enhancement is as per given fixed aggressiveness level"]
    CTL_LACE_TRIGGER_FLAG_FIXED_AGGRESSIVENESS = 2,
    CTL_LACE_TRIGGER_FLAG_MAX = -2147483648,
}
pub use self::_ctl_lace_trigger_flag_t as ctl_lace_trigger_flag_t;
#[doc = "\n @brief Set/Get LACE Config"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_lace_config_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Enable or disable LACE feature"]
    pub Enabled: bool,
    #[doc = "< [in] Get Operations used for additional settings"]
    pub OpTypeGet: ctl_get_operation_flags_t,
    #[doc = "< [in] Set Operations used for additional settings"]
    pub OpTypeSet: ctl_set_operation_t,
    #[doc = "< [in,out] LACE operating mode to be Triggerd"]
    pub Trigger: ctl_lace_trigger_flags_t,
    #[doc = "< [in,out] Data specific to the mode, caller is interested in"]
    pub LaceConfig: ctl_lace_aggr_config_t,
}
impl Default for _ctl_lace_config_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _ctl_lace_config_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_ctl_lace_config_t {{ Enabled: {:?}, OpTypeSet: {:?}, LaceConfig: {:?} }}",
            self.Enabled, self.OpTypeSet, self.LaceConfig
        )
    }
}
#[doc = "\n @brief Get Software PSR status/Set Software PSR settings"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_sw_psr_settings_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in][release] Set to False to Get Software PSR status. Set to True to\n< Enable/Disable Software PSR"]
    pub Set: bool,
    #[doc = "< [out] When Get is True, returns if SW PSR is supported"]
    pub Supported: bool,
    #[doc = "< [in,out] When Get is True, returns current state of  Software PSR.\n< When Get is False, Enables/Diasbles Software PSR"]
    pub Enable: bool,
}
#[doc = "\n @brief Intel Arc Sync Monitor Params"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_intel_arc_sync_monitor_params_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Intel Arc Sync support for the monitor"]
    pub IsIntelArcSyncSupported: bool,
    #[doc = "< [out] Minimum Intel Arc Sync refresh rate supported by the monitor"]
    pub MinimumRefreshRateInHz: f32,
    #[doc = "< [out] Maximum Intel Arc Sync refresh rate supported by the monitor"]
    pub MaximumRefreshRateInHz: f32,
    #[doc = "< [out] Max frame time increase in micro seconds from DID2.1 Adaptive\n< Sync block"]
    pub MaxFrameTimeIncreaseInUs: u32,
    #[doc = "< [out] Max frame time decrease in micro seconds from DID2.1 Adaptive\n< Sync block"]
    pub MaxFrameTimeDecreaseInUs: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_mux_output_handle_t {
    _unused: [u8; 0],
}
#[doc = "\n @brief Handle of a MUX output instance"]
pub type ctl_mux_output_handle_t = *mut _ctl_mux_output_handle_t;
#[doc = "\n @brief Display MUX device properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_mux_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] MUX ID of this MUX device enumerated"]
    pub MuxId: u8,
    #[doc = "< [in,out] Pointer to the number of display output instances this MUX\n< object can drive. If count is zero, then the api will update the value\n< with the total\n< number of outputs available. If count is non-zero, then the api will\n< only retrieve the number of outputs.\n< If count is larger than the number of display outputs MUX can drive,\n< then the api will update the value with the correct number of display\n< outputs MUX can driver."]
    pub Count: u32,
    #[doc = "< [in,out][range(0, *pCount)] Array of display output instance handles\n< this MUX device can drive"]
    pub phDisplayOutputs: *mut ctl_display_output_handle_t,
    #[doc = "< [out] [range(0, (Count-1))] This is the index into the\n< phDisplayOutputs list to the display output which currently owns the\n< MUX output. This doesn't mean display is active"]
    pub IndexOfDisplayOutputOwningMux: u8,
}
impl Default for _ctl_mux_properties_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Intel Arc Sync profile"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_intel_arc_sync_profile_t {
    #[doc = "< Invalid profile"]
    CTL_INTEL_ARC_SYNC_PROFILE_INVALID = 0,
    #[doc = "< Default. Selects appropriate profile based on the monitor. COMPATIBLE\n< profile is applied if profile is not available for the monitor"]
    CTL_INTEL_ARC_SYNC_PROFILE_RECOMMENDED = 1,
    #[doc = "< Unconstrained. Full VRR range of the monitor can be used"]
    CTL_INTEL_ARC_SYNC_PROFILE_EXCELLENT = 2,
    #[doc = "< Some minor range constraints, unlikely to effect user experience but\n< can reduce flicker on some monitors"]
    CTL_INTEL_ARC_SYNC_PROFILE_GOOD = 3,
    #[doc = "< Significant constraints that will reduce flicker considerably but are\n< likely to cause some level of judder onscreen especially when refresh\n< rates are changing rapidly"]
    CTL_INTEL_ARC_SYNC_PROFILE_COMPATIBLE = 4,
    #[doc = "< Disable Intel Arc Sync on this monitor. This disables variable rate\n< flips on this monitor. All sync flips will occur at the OS requested\n< refresh rate"]
    CTL_INTEL_ARC_SYNC_PROFILE_OFF = 5,
    #[doc = "< Applies vesa specified constraints if the monitor has provided them,\n< COMPATIBLE profile if not"]
    CTL_INTEL_ARC_SYNC_PROFILE_VESA = 6,
    #[doc = "< Unlocks controls to set a custom Intel Arc Sync profile"]
    CTL_INTEL_ARC_SYNC_PROFILE_CUSTOM = 7,
    CTL_INTEL_ARC_SYNC_PROFILE_MAX = 8,
}
#[doc = "\n @brief Intel Arc Sync profile"]
pub use self::_ctl_intel_arc_sync_profile_t as ctl_intel_arc_sync_profile_t;
#[doc = "\n @brief Intel Arc Sync Profile Params"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_intel_arc_sync_profile_params_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Intel Arc Sync profile used by driver. Refer\n< ::ctl_intel_arc_sync_profile_t"]
    pub IntelArcSyncProfile: ctl_intel_arc_sync_profile_t,
    #[doc = "< [in,out] Maximum refresh rate utilized by the driver"]
    pub MaxRefreshRateInHz: f32,
    #[doc = "< [in,out] Minimum refresh rate utilized by the driver"]
    pub MinRefreshRateInHz: f32,
    #[doc = "< [in,out] Maximum frame time increase (in micro seconds) imposed by the\n< driver"]
    pub MaxFrameTimeIncreaseInUs: u32,
    #[doc = "< [in,out] Maximum frame time decrease (in micro seconds) imposed by the\n< driver"]
    pub MaxFrameTimeDecreaseInUs: u32,
}
impl Default for _ctl_intel_arc_sync_profile_params_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief EDID Management operation type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_edid_management_optype_t {
    #[doc = "< This operation type is to read an output's EDID. Set edid_type input\n< arg to read MONITOR EDID or previously OVERRIDDEN EDID or CURRENT\n< active EDID. Read EDID is a 2 pass call. First call with size = 0,\n< pEdidBuf = nullptr to get the size, then call with allocated buffer to\n< get the EDID data. READ operation is applicable for any normal, edid\n< locked or edid overridden display output device."]
    CTL_EDID_MANAGEMENT_OPTYPE_READ_EDID = 1,
    #[doc = "< To make an output always connected with OVERRIDE or MONITOR EDID\n< across reboots. When output isn't connected call with OVERRIDE EDID;\n< when connected, either set OVERRIDE and provide pEdidBuf or set\n< MONITOR and driver will use monitor's EDID. There is no change to EDID\n< stored in Monitor. Cannot be called when override is active. Any OS\n< EDID override will take precedence over IGCL override."]
    CTL_EDID_MANAGEMENT_OPTYPE_LOCK_EDID = 2,
    #[doc = "< To undo lock EDID operation, i.e. it makes output as detached in\n< response to unplug. This operation removes past supplied EDID; output\n< status is reported to OS as it is; output restores back to monitor's\n< EDID when it is connected"]
    CTL_EDID_MANAGEMENT_OPTYPE_UNLOCK_EDID = 3,
    #[doc = "< To replace an output's EDID with supplied one (pEdidBuf) only when\n< physical display is connected. There is no change to EDID stored in\n< Monitor. Cannot apply this operation on locked output. When no output\n< device attached, the supplied EDID will be persisted in driver for\n< future use. Any OS EDID override will take precedence over IGCL\n< override."]
    CTL_EDID_MANAGEMENT_OPTYPE_OVERRIDE_EDID = 4,
    #[doc = "< To undo override EDID operation, that is remove previously overridden\n< EDID on an output. Output restores back to monitor's EDID when it is\n< connected"]
    CTL_EDID_MANAGEMENT_OPTYPE_UNDO_OVERRIDE_EDID = 5,
    CTL_EDID_MANAGEMENT_OPTYPE_MAX = 6,
}
#[doc = "\n @brief EDID Management operation type"]
pub use self::_ctl_edid_management_optype_t as ctl_edid_management_optype_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief EDID type. Used in LOCK_EDID and READ_EDID calls."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_edid_type_t {
    #[doc = "< [in] Used to return currently active EDID in READ_EDID call."]
    CTL_EDID_TYPE_CURRENT = 1,
    #[doc = "< [in] Is it user supplied EDID. Used in LOCK_EDID call with Supplied\n< EDID or in READ_EDID to get Supplied EDID."]
    CTL_EDID_TYPE_OVERRIDE = 2,
    #[doc = "< [in] Is it Monitor's EDID. Used in LOCK_EDID and READ_EDID calls."]
    CTL_EDID_TYPE_MONITOR = 3,
    CTL_EDID_TYPE_MAX = 4,
}
#[doc = "\n @brief EDID type. Used in LOCK_EDID and READ_EDID calls."]
pub use self::_ctl_edid_type_t as ctl_edid_type_t;
#[doc = "\n @brief Edid management operation Out Flags"]
pub type ctl_edid_management_out_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_edid_management_out_flag_t {
    #[doc = "< [out] If OS was notified about a connection change. App will need to\n< wait for the OS action to complete."]
    CTL_EDID_MANAGEMENT_OUT_FLAG_OS_CONN_NOTIFICATION = 1,
    #[doc = "< [out] Is it previously supplied EDID, set for READ_EDID(CURRENT)."]
    CTL_EDID_MANAGEMENT_OUT_FLAG_SUPPLIED_EDID = 2,
    #[doc = "< [out] Is it Monitor's EDID, set for READ_EDID(CURRENT)."]
    CTL_EDID_MANAGEMENT_OUT_FLAG_MONITOR_EDID = 4,
    #[doc = "< [out] Is Monitor physically connected"]
    CTL_EDID_MANAGEMENT_OUT_FLAG_DISPLAY_CONNECTED = 8,
    CTL_EDID_MANAGEMENT_OUT_FLAG_MAX = -2147483648,
}
pub use self::_ctl_edid_management_out_flag_t as ctl_edid_management_out_flag_t;
#[doc = "\n @brief EDID management"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_edid_management_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] EDID managmeent operation type"]
    pub OpType: ctl_edid_management_optype_t,
    #[doc = "< [in] EDID Type, Monitor or Supplied"]
    pub EdidType: ctl_edid_type_t,
    #[doc = "< [in,out] EDID Size, should be 0 for querying the size of EDID, should\n< be previously returned size to read EDID. if buffer isn't big enough\n< to fit EDID, returns size of EDID bytes."]
    pub EdidSize: u32,
    #[doc = "< [in,out] buffer holding EDID data"]
    pub pEdidBuf: *mut u8,
    #[doc = "< [out] Output flags to inform about status of EDID management\n< operations"]
    pub OutFlags: ctl_edid_management_out_flags_t,
}
impl Default for _ctl_edid_management_args_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Custom mode operation types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_custom_mode_operation_types_t {
    #[doc = "< Get details of all previous applied custom modes if any."]
    CTL_CUSTOM_MODE_OPERATION_TYPES_GET_CUSTOM_SOURCE_MODES = 0,
    #[doc = "< Add a new mode. Allows only single mode adition at a time."]
    CTL_CUSTOM_MODE_OPERATION_TYPES_ADD_CUSTOM_SOURCE_MODE = 1,
    #[doc = "< Remove previously added custom mode. Allows single or multiple mode\n< removal at a time."]
    CTL_CUSTOM_MODE_OPERATION_TYPES_REMOVE_CUSTOM_SOURCE_MODES = 2,
    CTL_CUSTOM_MODE_OPERATION_TYPES_MAX = 3,
}
#[doc = "\n @brief Custom mode operation types"]
pub use self::_ctl_custom_mode_operation_types_t as ctl_custom_mode_operation_types_t;
#[doc = "\n @brief Get/Set Custom Mode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_get_set_custom_mode_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Custom mode operation type"]
    pub CustomModeOpType: ctl_custom_mode_operation_types_t,
    #[doc = "< [in,out] Number of Custom Src Modes to be added/removed/Read."]
    pub NumOfModes: u32,
    #[doc = "< [in,out] Custom mode source list which holds source modes to be\n< added/removed/Read."]
    pub pCustomSrcModeList: *mut ctl_custom_src_mode_t,
}
impl Default for _ctl_get_set_custom_mode_args_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Get/Set Custom Mode"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_custom_src_mode_t {
    #[doc = "< [in,out] CustomMode Source X Size"]
    pub SourceX: u32,
    #[doc = "< [in,out] CustomMode Source Y Size"]
    pub SourceY: u32,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Combined Display operation type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_combined_display_optype_t {
    #[doc = "< To check whether given outputs can form a combined display, no changes\n< are applied"]
    CTL_COMBINED_DISPLAY_OPTYPE_IS_SUPPORTED_CONFIG = 1,
    #[doc = "< To setup and enable a combined display"]
    CTL_COMBINED_DISPLAY_OPTYPE_ENABLE = 2,
    #[doc = "< To disable combined display"]
    CTL_COMBINED_DISPLAY_OPTYPE_DISABLE = 3,
    #[doc = "< To query combined display configuration"]
    CTL_COMBINED_DISPLAY_OPTYPE_QUERY_CONFIG = 4,
    CTL_COMBINED_DISPLAY_OPTYPE_MAX = 5,
}
#[doc = "\n @brief Combined Display operation type"]
pub use self::_ctl_combined_display_optype_t as ctl_combined_display_optype_t;
#[doc = "\n @brief Combined Display's child display target mode"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_child_display_target_mode_t {
    #[doc = "< [in,out] Width"]
    pub Width: u32,
    #[doc = "< [in,out] Height"]
    pub Height: u32,
    #[doc = "< [in,out] Refresh Rate"]
    pub RefreshRate: f32,
    #[doc = "< [out] Reserved field of 16 bytes"]
    pub ReservedFields: [u32; 4usize],
}
#[doc = "\n @brief Combined Display's child display information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_combined_display_child_info_t {
    #[doc = "< [in,out] Display output handle under combined display configuration"]
    pub hDisplayOutput: ctl_display_output_handle_t,
    #[doc = "< [in,out] FrameBuffer source's RECT within Combined Display respective"]
    pub FbSrc: ctl_rect_t,
    #[doc = "< [in,out] FrameBuffer target's RECT within output size"]
    pub FbPos: ctl_rect_t,
    #[doc = "< [in,out] 0/180 Degree Display orientation (rotation)"]
    pub DisplayOrientation: ctl_display_orientation_t,
    #[doc = "< [in,out] Desired target mode (width, height, refresh)"]
    pub TargetMode: ctl_child_display_target_mode_t,
}
impl Default for _ctl_combined_display_child_info_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Combined Display arguments"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_combined_display_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Combined display operation type"]
    pub OpType: ctl_combined_display_optype_t,
    #[doc = "< [out] Returns yes/no in response to IS_SUPPORTED_CONFIG command"]
    pub IsSupported: bool,
    #[doc = "< [in,out] Number of outputs part of desired combined display\n< configuration"]
    pub NumOutputs: u8,
    #[doc = "< [in,out] Width of desired combined display configuration"]
    pub CombinedDesktopWidth: u32,
    #[doc = "< [in,out] Height of desired combined display configuration"]
    pub CombinedDesktopHeight: u32,
    #[doc = "< [in,out] List of child display information respective to each output.\n< Up to 16 displays are supported with up to 4 displays per GPU."]
    pub pChildInfo: *mut ctl_combined_display_child_info_t,
    #[doc = "< [in,out] Handle to combined display output"]
    pub hCombinedDisplayOutput: ctl_display_output_handle_t,
}
impl Default for _ctl_combined_display_args_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Display Genlock Operations"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_genlock_operation_t {
    #[doc = "< Get details of GENLOCK support and timing information"]
    CTL_GENLOCK_OPERATION_GET_TIMING_DETAILS = 0,
    #[doc = "< Driver to verify that the topology is Genlock capable"]
    CTL_GENLOCK_OPERATION_VALIDATE = 1,
    #[doc = "< Enable GENLOCK"]
    CTL_GENLOCK_OPERATION_ENABLE = 2,
    #[doc = "< Disable GENLOCK"]
    CTL_GENLOCK_OPERATION_DISABLE = 3,
    #[doc = "< Get details of the current Genlock topology that is applied"]
    CTL_GENLOCK_OPERATION_GET_TOPOLOGY = 4,
    CTL_GENLOCK_OPERATION_MAX = 5,
}
#[doc = "\n @brief Display Genlock Operations"]
pub use self::_ctl_genlock_operation_t as ctl_genlock_operation_t;
#[doc = "\n @brief Display Genlock Info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_genlock_display_info_t {
    #[doc = "< [in,out] Display output handle under Genlock topology"]
    pub hDisplayOutput: ctl_display_output_handle_t,
    #[doc = "< [in,out] Genlock Primary"]
    pub IsPrimary: bool,
}
impl Default for _ctl_genlock_display_info_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Genlock Target Mode List"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_genlock_target_mode_list_t {
    #[doc = "< [in] Display output handle for whom target mode list is required"]
    pub hDisplayOutput: ctl_display_output_handle_t,
    #[doc = "< [in,out] Number of supported Modes that is returned from a driver"]
    pub NumModes: u32,
    #[doc = "< [out] Display Genlock operation and information"]
    pub pTargetModes: *mut ctl_display_timing_t,
}
impl Default for _ctl_genlock_target_mode_list_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Genlock Topology"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_genlock_topology_t {
    #[doc = "< [in,out] Number of Genlock displays"]
    pub NumGenlockDisplays: u8,
    #[doc = "< [in,out] Primary Genlock system"]
    pub IsPrimaryGenlockSystem: bool,
    #[doc = "< [in] Common target mode"]
    pub CommonTargetMode: ctl_display_timing_t,
    #[doc = "< [in,out] List of Genlock display info"]
    pub pGenlockDisplayInfo: *mut ctl_genlock_display_info_t,
    #[doc = "< [out] List of Genlock target modes"]
    pub pGenlockModeList: *mut ctl_genlock_target_mode_list_t,
}
impl Default for _ctl_genlock_topology_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Display Genlock Arg type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_genlock_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Display Genlock Operation"]
    pub Operation: ctl_genlock_operation_t,
    #[doc = "< [in,out] Display Genlock array of topology structures"]
    pub GenlockTopology: ctl_genlock_topology_t,
    #[doc = "< [out] Whether the feature is currently enabled or not"]
    pub IsGenlockEnabled: bool,
    #[doc = "< [out] Indicates if Genlock can be enabled/disabled with the given\n< topology"]
    pub IsGenlockPossible: bool,
}
impl Default for _ctl_genlock_args_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Vblank timestamp arguments"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_vblank_ts_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Number of child targets"]
    pub NumOfTargets: u8,
    #[doc = "< [out] List of vblank timestamps in microseconds per child target"]
    pub VblankTS: [u64; 16usize],
}
#[doc = "\n @brief Link Display Adapters Arguments"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_lda_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Numbers of adapters to be linked. Up to 4 adapters are\n< supported"]
    pub NumAdapters: u8,
    #[doc = "< [in,out][release] List of Control device adapter handles to be linked,\n< first one being Primary Adapter"]
    pub hLinkedAdapters: *mut ctl_device_adapter_handle_t,
    #[doc = "< [out] Reserved fields. Set to zero."]
    pub Reserved: [u64; 4usize],
}
impl Default for _ctl_lda_args_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Get/Set Dynamic Contrast Enhancement arguments"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_dce_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Flag to indicate Set or Get operation"]
    pub Set: bool,
    #[doc = "< [in] Target brightness percent"]
    pub TargetBrightnessPercent: u32,
    #[doc = "< [in] Phase-in speed multiplier for brightness to take effect"]
    pub PhaseinSpeedMultiplier: f64,
    #[doc = "< [in,out] Number of histogram bins"]
    pub NumBins: u32,
    #[doc = "< [in,out] For get calls, this represents current state & for set this\n< represents future state"]
    pub Enable: bool,
    #[doc = "< [out] is DCE feature supported"]
    pub IsSupported: bool,
    #[doc = "< [out] Bin wise histogram data of size NumBins * sizeof(uint32_t) for\n< current frame"]
    pub pHistogram: *mut u32,
}
impl Default for _ctl_dce_args_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Color model"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_wire_format_color_model_t {
    #[doc = "< Color model RGB"]
    CTL_WIRE_FORMAT_COLOR_MODEL_RGB = 0,
    #[doc = "< Color model YCBCR 420"]
    CTL_WIRE_FORMAT_COLOR_MODEL_YCBCR_420 = 1,
    #[doc = "< Color model YCBCR 422"]
    CTL_WIRE_FORMAT_COLOR_MODEL_YCBCR_422 = 2,
    #[doc = "< Color model YCBCR 444"]
    CTL_WIRE_FORMAT_COLOR_MODEL_YCBCR_444 = 3,
    CTL_WIRE_FORMAT_COLOR_MODEL_MAX = 4,
}
#[doc = "\n @brief Color model"]
pub use self::_ctl_wire_format_color_model_t as ctl_wire_format_color_model_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Operation type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_wire_format_operation_type_t {
    #[doc = "< Get request"]
    CTL_WIRE_FORMAT_OPERATION_TYPE_GET = 0,
    #[doc = "< Set request"]
    CTL_WIRE_FORMAT_OPERATION_TYPE_SET = 1,
    #[doc = "< Restore to default values"]
    CTL_WIRE_FORMAT_OPERATION_TYPE_RESTORE_DEFAULT = 2,
    CTL_WIRE_FORMAT_OPERATION_TYPE_MAX = 3,
}
#[doc = "\n @brief Operation type"]
pub use self::_ctl_wire_format_operation_type_t as ctl_wire_format_operation_type_t;
#[doc = "\n @brief Wire Format"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_wire_format_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Color model"]
    pub ColorModel: ctl_wire_format_color_model_t,
    #[doc = "< [in,out] Color Depth"]
    pub ColorDepth: ctl_output_bpc_flags_t,
}
impl Default for _ctl_wire_format_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Get Set Wire Format"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_get_set_wire_format_config_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Get/Set Operation"]
    pub Operation: ctl_wire_format_operation_type_t,
    #[doc = "< [out] Array of WireFormats supported"]
    pub SupportedWireFormat: [ctl_wire_format_t; 4usize],
    #[doc = "< [in,out]  Current/Requested WireFormat based on Operation. During SET\n< Operation, if multiple bpc is set, the MIN bpc will be applied"]
    pub WireFormat: ctl_wire_format_t,
}
impl Default for _ctl_get_set_wire_format_config_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Various display settings"]
pub type ctl_display_setting_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_display_setting_flag_t {
    #[doc = "< Low latency"]
    CTL_DISPLAY_SETTING_FLAG_LOW_LATENCY = 1,
    #[doc = "< Source tone mapping"]
    CTL_DISPLAY_SETTING_FLAG_SOURCE_TM = 2,
    #[doc = "< Content type"]
    CTL_DISPLAY_SETTING_FLAG_CONTENT_TYPE = 4,
    #[doc = "< Quantization range, full range or limited range"]
    CTL_DISPLAY_SETTING_FLAG_QUANTIZATION_RANGE = 8,
    #[doc = "< Picture aspect ratio"]
    CTL_DISPLAY_SETTING_FLAG_PICTURE_AR = 16,
    #[doc = "< Audio settings"]
    CTL_DISPLAY_SETTING_FLAG_AUDIO = 32,
    CTL_DISPLAY_SETTING_FLAG_MAX = -2147483648,
}
pub use self::_ctl_display_setting_flag_t as ctl_display_setting_flag_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Low latency setting"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_display_setting_low_latency_t {
    #[doc = "< Default"]
    CTL_DISPLAY_SETTING_LOW_LATENCY_DEFAULT = 0,
    #[doc = "< Disabled"]
    CTL_DISPLAY_SETTING_LOW_LATENCY_DISABLED = 1,
    #[doc = "< Enabled"]
    CTL_DISPLAY_SETTING_LOW_LATENCY_ENABLED = 2,
    CTL_DISPLAY_SETTING_LOW_LATENCY_MAX = 3,
}
#[doc = "\n @brief Low latency setting"]
pub use self::_ctl_display_setting_low_latency_t as ctl_display_setting_low_latency_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Source tone mapping setting"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_display_setting_sourcetm_t {
    #[doc = "< Default"]
    CTL_DISPLAY_SETTING_SOURCETM_DEFAULT = 0,
    #[doc = "< Disabled"]
    CTL_DISPLAY_SETTING_SOURCETM_DISABLED = 1,
    #[doc = "< Enabled"]
    CTL_DISPLAY_SETTING_SOURCETM_ENABLED = 2,
    CTL_DISPLAY_SETTING_SOURCETM_MAX = 3,
}
#[doc = "\n @brief Source tone mapping setting"]
pub use self::_ctl_display_setting_sourcetm_t as ctl_display_setting_sourcetm_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Content type settings"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_display_setting_content_type_t {
    #[doc = "< Default content type used by driver. Driver will use internal\n< techniques to determine content type and indicate to panel"]
    CTL_DISPLAY_SETTING_CONTENT_TYPE_DEFAULT = 0,
    #[doc = "< Content type indication is disabled"]
    CTL_DISPLAY_SETTING_CONTENT_TYPE_DISABLED = 1,
    #[doc = "< Typical desktop with a mix of text and graphics"]
    CTL_DISPLAY_SETTING_CONTENT_TYPE_DESKTOP = 2,
    #[doc = "< Video or media content"]
    CTL_DISPLAY_SETTING_CONTENT_TYPE_MEDIA = 3,
    #[doc = "< Gaming content"]
    CTL_DISPLAY_SETTING_CONTENT_TYPE_GAMING = 4,
    CTL_DISPLAY_SETTING_CONTENT_TYPE_MAX = 5,
}
#[doc = "\n @brief Content type settings"]
pub use self::_ctl_display_setting_content_type_t as ctl_display_setting_content_type_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Quantization range"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_display_setting_quantization_range_t {
    #[doc = "< Default based on video format"]
    CTL_DISPLAY_SETTING_QUANTIZATION_RANGE_DEFAULT = 0,
    #[doc = "< Limited range"]
    CTL_DISPLAY_SETTING_QUANTIZATION_RANGE_LIMITED_RANGE = 1,
    #[doc = "< Full range"]
    CTL_DISPLAY_SETTING_QUANTIZATION_RANGE_FULL_RANGE = 2,
    CTL_DISPLAY_SETTING_QUANTIZATION_RANGE_MAX = 3,
}
#[doc = "\n @brief Quantization range"]
pub use self::_ctl_display_setting_quantization_range_t as ctl_display_setting_quantization_range_t;
#[doc = "\n @brief Picture aspect ratio"]
pub type ctl_display_setting_picture_ar_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_display_setting_picture_ar_flag_t {
    #[doc = "< Default picture aspect ratio"]
    CTL_DISPLAY_SETTING_PICTURE_AR_FLAG_DEFAULT = 1,
    #[doc = "< Picture aspect ratio indication is explicitly disabled"]
    CTL_DISPLAY_SETTING_PICTURE_AR_FLAG_DISABLED = 2,
    #[doc = "< Aspect ratio of 4:3"]
    CTL_DISPLAY_SETTING_PICTURE_AR_FLAG_AR_4_3 = 4,
    #[doc = "< Aspect ratio of 16:9"]
    CTL_DISPLAY_SETTING_PICTURE_AR_FLAG_AR_16_9 = 8,
    #[doc = "< Aspect ratio of 64:27 or 21:9 anamorphic"]
    CTL_DISPLAY_SETTING_PICTURE_AR_FLAG_AR_64_27 = 16,
    #[doc = "< Aspect ratio of 256:135"]
    CTL_DISPLAY_SETTING_PICTURE_AR_FLAG_AR_256_135 = 32,
    CTL_DISPLAY_SETTING_PICTURE_AR_FLAG_MAX = -2147483648,
}
pub use self::_ctl_display_setting_picture_ar_flag_t as ctl_display_setting_picture_ar_flag_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Audio settings"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_display_setting_audio_t {
    #[doc = "< Default audio settings, always enumerated and enabled if display\n< supports it"]
    CTL_DISPLAY_SETTING_AUDIO_DEFAULT = 0,
    #[doc = "< Forcefully disable display audio end point enumeration to OS"]
    CTL_DISPLAY_SETTING_AUDIO_DISABLED = 1,
    CTL_DISPLAY_SETTING_AUDIO_MAX = 2,
}
#[doc = "\n @brief Audio settings"]
pub use self::_ctl_display_setting_audio_t as ctl_display_setting_audio_t;
#[doc = "\n @brief Get/Set end display settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_display_settings_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Flag to indicate Set or Get operation. Default option for all\n< features are reserved for Set=true calls, which will reset the setting\n< to driver defaults."]
    pub Set: bool,
    #[doc = "< [out] Display setting flags supported by the display."]
    pub SupportedFlags: ctl_display_setting_flags_t,
    #[doc = "< [out] Display setting flags which can be controlled by the caller.\n< Features which doesn't have this flag set cannot be changed by caller."]
    pub ControllableFlags: ctl_display_setting_flags_t,
    #[doc = "< [in,out] Display setting flags which caller can use to indicate the\n< features it's interested in. This cannot have a bit set which is not\n< supported by SupportedFlags and ControllableFlags."]
    pub ValidFlags: ctl_display_setting_flags_t,
    #[doc = "< [in,out] Low latency state of panel. For HDR10+ Gaming this need to be\n< in ENABLED state."]
    pub LowLatency: ctl_display_setting_low_latency_t,
    #[doc = "< [in,out] Source tone mapping state known to panel. For HDR10+ Gaming\n< this need to be in ENABLED state."]
    pub SourceTM: ctl_display_setting_sourcetm_t,
    #[doc = "< [in,out] Source content type known to panel."]
    pub ContentType: ctl_display_setting_content_type_t,
    #[doc = "< [in,out] Quantization range"]
    pub QuantizationRange: ctl_display_setting_quantization_range_t,
    #[doc = "< [out] Supported Picture aspect ratios"]
    pub SupportedPictureAR: ctl_display_setting_picture_ar_flags_t,
    #[doc = "< [in,out] Picture aspect ratio"]
    pub PictureAR: ctl_display_setting_picture_ar_flag_t,
    #[doc = "< [in,out] Audio settings"]
    pub AudioSettings: ctl_display_setting_audio_t,
    #[doc = "< [out] Reserved fields for future enumerations"]
    pub Reserved: [u32; 25usize],
}
impl Default for _ctl_display_settings_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Accelerator engine groups"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_engine_group_t {
    #[doc = "< Access information about all engines combined."]
    CTL_ENGINE_GROUP_GT = 0,
    #[doc = "< Access information about all render and compute engines combined."]
    CTL_ENGINE_GROUP_RENDER = 1,
    #[doc = "< Access information about all media engines combined."]
    CTL_ENGINE_GROUP_MEDIA = 2,
    CTL_ENGINE_GROUP_MAX = 3,
}
#[doc = "\n @brief Accelerator engine groups"]
pub use self::_ctl_engine_group_t as ctl_engine_group_t;
#[doc = "\n @brief Engine group properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_engine_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] The engine group"]
    pub type_: ctl_engine_group_t,
}
impl Default for _ctl_engine_properties_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Engine activity counters\n\n @details\n     - Percent utilization is calculated by taking two snapshots (s1, s2) and\n       using the equation: %util = (s2.activeTime - s1.activeTime) /\n       (s2.timestamp - s1.timestamp)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_engine_stats_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Monotonic counter for time in microseconds that this resource is\n< actively running workloads."]
    pub activeTime: u64,
    #[doc = "< [out] Monotonic timestamp counter in microseconds when activeTime\n< counter was sampled.\n< This timestamp should only be used to calculate delta time between\n< snapshots of this structure.\n< Never take the delta of this timestamp with the timestamp from a\n< different structure since they are not guaranteed to have the same base.\n< The absolute value of the timestamp is only valid during within the\n< application and may be different on the next execution."]
    pub timestamp: u64,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Fan resource speed mode"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_fan_speed_mode_t {
    #[doc = "< The fan speed is operating using the hardware default settings"]
    CTL_FAN_SPEED_MODE_DEFAULT = 0,
    #[doc = "< The fan speed is currently set to a fixed value"]
    CTL_FAN_SPEED_MODE_FIXED = 1,
    #[doc = "< The fan speed is currently controlled dynamically by hardware based on\n< a temp/speed table"]
    CTL_FAN_SPEED_MODE_TABLE = 2,
    CTL_FAN_SPEED_MODE_MAX = 3,
}
#[doc = "\n @brief Fan resource speed mode"]
pub use self::_ctl_fan_speed_mode_t as ctl_fan_speed_mode_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Fan speed units"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_fan_speed_units_t {
    #[doc = "< The fan speed is in units of revolutions per minute (rpm)"]
    CTL_FAN_SPEED_UNITS_RPM = 0,
    #[doc = "< The fan speed is a percentage of the maximum speed of the fan"]
    CTL_FAN_SPEED_UNITS_PERCENT = 1,
    CTL_FAN_SPEED_UNITS_MAX = 2,
}
#[doc = "\n @brief Fan speed units"]
pub use self::_ctl_fan_speed_units_t as ctl_fan_speed_units_t;
#[doc = "\n @brief Fan speed"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_fan_speed_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] The speed of the fan. On output, a value of -1 indicates that\n< there is no fixed fan speed setting."]
    pub speed: i32,
    #[doc = "< [in,out] The units that the fan speed is expressed in. On output, if\n< fan speed is -1 then units should be ignored."]
    pub units: ctl_fan_speed_units_t,
}
impl Default for _ctl_fan_speed_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Fan temperature/speed pair"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_fan_temp_speed_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Temperature in degrees Celsius."]
    pub temperature: u32,
    #[doc = "< [in,out] The speed of the fan"]
    pub speed: ctl_fan_speed_t,
}
impl Default for _ctl_fan_temp_speed_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Fan speed table"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_fan_speed_table_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] The number of valid points in the fan speed table. 0 means\n< that there is no fan speed table configured. -1 means that a fan speed\n< table is not supported by the hardware."]
    pub numPoints: i32,
    #[doc = "< [in,out] Array of temperature/fan speed pairs. The table is ordered\n< based on temperature from lowest to highest."]
    pub table: [ctl_fan_temp_speed_t; 32usize],
}
impl Default for _ctl_fan_speed_table_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Fan properties"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_fan_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Indicates if software can control the fan speed assuming the\n< user has permissions"]
    pub canControl: bool,
    #[doc = "< [out] Bitfield of supported fan configuration modes\n< (1<<::ctl_fan_speed_mode_t)"]
    pub supportedModes: u32,
    #[doc = "< [out] Bitfield of supported fan speed units\n< (1<<::ctl_fan_speed_units_t)"]
    pub supportedUnits: u32,
    #[doc = "< [out] The maximum RPM of the fan. A value of -1 means that this\n< property is unknown."]
    pub maxRPM: i32,
    #[doc = "< [out] The maximum number of points in the fan temp/speed table. A\n< value of -1 means that this fan doesn't support providing a temp/speed\n< table."]
    pub maxPoints: i32,
}
#[doc = "\n @brief Fan configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_fan_config_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] The fan speed mode (fixed, temp-speed table)"]
    pub mode: ctl_fan_speed_mode_t,
    #[doc = "< [in,out] The current fixed fan speed setting"]
    pub speedFixed: ctl_fan_speed_t,
    #[doc = "< [out] A table containing temperature/speed pairs"]
    pub speedTable: ctl_fan_speed_table_t,
}
impl Default for _ctl_fan_config_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Frequency domains."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_freq_domain_t {
    #[doc = "< GPU Core Domain."]
    CTL_FREQ_DOMAIN_GPU = 0,
    #[doc = "< Local Memory Domain."]
    CTL_FREQ_DOMAIN_MEMORY = 1,
    CTL_FREQ_DOMAIN_MAX = 2,
}
#[doc = "\n @brief Frequency domains."]
pub use self::_ctl_freq_domain_t as ctl_freq_domain_t;
#[doc = "\n @brief Frequency properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_freq_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] The hardware block that this frequency domain controls (GPU,\n< memory, ...)"]
    pub type_: ctl_freq_domain_t,
    #[doc = "< [out] Indicates if software can control the frequency of this domain\n< assuming the user has permissions"]
    pub canControl: bool,
    #[doc = "< [out] The minimum hardware clock frequency in units of MHz."]
    pub min: f64,
    #[doc = "< [out] The maximum non-overclock hardware clock frequency in units of\n< MHz."]
    pub max: f64,
}
impl Default for _ctl_freq_properties_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Frequency range between which the hardware can operate. The limits can\n        be above or below the hardware limits - the hardware will clamp\n        appropriately."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_freq_range_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] The min frequency in MHz below which hardware frequency\n< management will not request frequencies. On input, setting to 0 will\n< permit the frequency to go down to the hardware minimum. On output, a\n< negative value indicates that no external minimum frequency limit is\n< in effect."]
    pub min: f64,
    #[doc = "< [in,out] The max frequency in MHz above which hardware frequency\n< management will not request frequencies. On input, setting to 0 or a\n< very big number will permit the frequency to go all the way up to the\n< hardware maximum. On output, a negative number indicates that no\n< external maximum frequency limit is in effect."]
    pub max: f64,
}
#[doc = "\n @brief Frequency throttle reasons"]
pub type ctl_freq_throttle_reason_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_freq_throttle_reason_flag_t {
    #[doc = "< frequency throttled due to average power excursion (PL1)"]
    CTL_FREQ_THROTTLE_REASON_FLAG_AVE_PWR_CAP = 1,
    #[doc = "< frequency throttled due to burst power excursion (PL2)"]
    CTL_FREQ_THROTTLE_REASON_FLAG_BURST_PWR_CAP = 2,
    #[doc = "< frequency throttled due to current excursion (PL4)"]
    CTL_FREQ_THROTTLE_REASON_FLAG_CURRENT_LIMIT = 4,
    #[doc = "< frequency throttled due to thermal excursion (T > TjMax)"]
    CTL_FREQ_THROTTLE_REASON_FLAG_THERMAL_LIMIT = 8,
    #[doc = "< frequency throttled due to power supply assertion"]
    CTL_FREQ_THROTTLE_REASON_FLAG_PSU_ALERT = 16,
    #[doc = "< frequency throttled due to software supplied frequency range"]
    CTL_FREQ_THROTTLE_REASON_FLAG_SW_RANGE = 32,
    #[doc = "< frequency throttled due to a sub block that has a lower frequency\n< range when it receives clocks"]
    CTL_FREQ_THROTTLE_REASON_FLAG_HW_RANGE = 64,
    CTL_FREQ_THROTTLE_REASON_FLAG_MAX = -2147483648,
}
pub use self::_ctl_freq_throttle_reason_flag_t as ctl_freq_throttle_reason_flag_t;
#[doc = "\n @brief Frequency state"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_freq_state_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Current voltage in Volts. A negative value indicates that this\n< property is not known."]
    pub currentVoltage: f64,
    #[doc = "< [out] The current frequency request in MHz. A negative value indicates\n< that this property is not known."]
    pub request: f64,
    #[doc = "< [out] The maximum frequency in MHz supported under the current TDP\n< conditions. This fluctuates dynamically based on the power and thermal\n< limits of the part. A negative value indicates that this property is\n< not known."]
    pub tdp: f64,
    #[doc = "< [out] The efficient minimum frequency in MHz. A negative value\n< indicates that this property is not known."]
    pub efficient: f64,
    #[doc = "< [out] The resolved frequency in MHz. A negative value indicates that\n< this property is not known."]
    pub actual: f64,
    #[doc = "< [out] The reasons that the frequency is being limited by the hardware.\n< Returns 0 (frequency not throttled) or a combination of ::ctl_freq_throttle_reason_flag_t."]
    pub throttleReasons: ctl_freq_throttle_reason_flags_t,
}
#[doc = "\n @brief Frequency throttle time snapshot\n\n @details\n     - Percent time throttled is calculated by taking two snapshots (s1, s2)\n       and using the equation: %throttled = (s2.throttleTime -\n       s1.throttleTime) / (s2.timestamp - s1.timestamp)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_freq_throttle_time_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] The monotonic counter of time in microseconds that the frequency\n< has been limited by the hardware."]
    pub throttleTime: u64,
    #[doc = "< [out] Microsecond timestamp when throttleTime was captured.\n< This timestamp should only be used to calculate delta time between\n< snapshots of this structure.\n< Never take the delta of this timestamp with the timestamp from a\n< different structure since they are not guaranteed to have the same base.\n< The absolute value of the timestamp is only valid during within the\n< application and may be different on the next execution."]
    pub timestamp: u64,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Feature type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_video_processing_feature_t {
    #[doc = "< Film mode detection.  Contains CTL_PROPERTY_VALUE_TYPE_BOOL ValueType."]
    CTL_VIDEO_PROCESSING_FEATURE_FILM_MODE_DETECTION = 0,
    #[doc = "< Noise reduction.  Contains CTL_PROPERTY_VALUE_TYPE_CUSTOM type field\n< using struct ::ctl_video_processing_noise_reduction_t."]
    CTL_VIDEO_PROCESSING_FEATURE_NOISE_REDUCTION = 1,
    #[doc = "< Sharpness.  Contains CTL_PROPERTY_VALUE_TYPE_UINT32 ValueType."]
    CTL_VIDEO_PROCESSING_FEATURE_SHARPNESS = 2,
    #[doc = "< Adaptive contrast enhancement.  Contains\n< CTL_PROPERTY_VALUE_TYPE_CUSTOM type field using struct\n< ::ctl_video_processing_adaptive_contrast_enhancement_t."]
    CTL_VIDEO_PROCESSING_FEATURE_ADAPTIVE_CONTRAST_ENHANCEMENT = 3,
    #[doc = "< Super resolution.  Contains CTL_PROPERTY_VALUE_TYPE_CUSTOM ValueType\n< using ::ctl_video_processing_super_resolution_t. By defaut, Super\n< resolution is not active, need application to activate it, please\n< contact Intel for super resolution activation."]
    CTL_VIDEO_PROCESSING_FEATURE_SUPER_RESOLUTION = 4,
    #[doc = "< Standard color correction.  Controls Hue, Saturation, Contrast,\n< Brightness.  Contains CTL_PROPERTY_VALUE_TYPE_CUSTOM type field using\n< struct ::ctl_video_processing_standard_color_correction_t."]
    CTL_VIDEO_PROCESSING_FEATURE_STANDARD_COLOR_CORRECTION = 5,
    #[doc = "< Total color correction.  Controls Red, Green, Blue, Yellow, Cyan,\n< Magenta.  Contains CTL_PROPERTY_VALUE_TYPE_CUSTOM type field using\n< struct ::ctl_video_processing_total_color_correction_t."]
    CTL_VIDEO_PROCESSING_FEATURE_TOTAL_COLOR_CORRECTION = 6,
    #[doc = "< Skin tone enhancement.  Contains CTL_PROPERTY_VALUE_TYPE_UINT32\n< ValueType."]
    CTL_VIDEO_PROCESSING_FEATURE_SKIN_TONE_ENHANCEMENT = 7,
    CTL_VIDEO_PROCESSING_FEATURE_MAX = 8,
}
#[doc = "\n @brief Feature type"]
pub use self::_ctl_video_processing_feature_t as ctl_video_processing_feature_t;
#[doc = "\n @brief Super resolution values possible"]
pub type ctl_video_processing_super_resolution_flags_t = u32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_video_processing_super_resolution_flag_t {
    #[doc = "< Disable"]
    CTL_VIDEO_PROCESSING_SUPER_RESOLUTION_FLAG_DISABLE = 1,
    #[doc = "< Enable with default super resolution mode"]
    CTL_VIDEO_PROCESSING_SUPER_RESOLUTION_FLAG_ENABLE_DEFAULT_SCENARIO_MODE = 2,
    #[doc = "< Super resolution mode targeted at video conference content"]
    CTL_VIDEO_PROCESSING_SUPER_RESOLUTION_FLAG_ENABLE_CONFERENCE_SCENARIO_MODE = 4,
    #[doc = "< Super resolution mode targeted at camera capture content (e.g.\n< security camera)"]
    CTL_VIDEO_PROCESSING_SUPER_RESOLUTION_FLAG_ENABLE_CAMERA_SCENARIO_MODE = 8,
    CTL_VIDEO_PROCESSING_SUPER_RESOLUTION_FLAG_MAX = -2147483648,
}
pub use self::_ctl_video_processing_super_resolution_flag_t as ctl_video_processing_super_resolution_flag_t;
#[doc = "\n @brief Super Resolution feature details structure to be used with\n        SUPER_RESOLUTION"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_video_processing_super_resolution_info_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] SUPER_RESOLUTION flag"]
    pub super_resolution_flag: ctl_video_processing_super_resolution_flags_t,
    #[doc = "< [in,out] The range of input width information(min, max, default and\n< step size)which super resolution is capable of supporting."]
    pub super_resolution_range_in_width: ctl_property_info_uint_t,
    #[doc = "< [in,out] The range of input height information(min, max, default and\n< step size)which super resolution is capable of supporting."]
    pub super_resolution_range_in_height: ctl_property_info_uint_t,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[doc = "\n @brief Super Resolution Get/Set structure to be used with SUPER_RESOLUTION"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_video_processing_super_resolution_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] SUPER_RESOLUTION flag"]
    pub super_resolution_flag: ctl_video_processing_super_resolution_flags_t,
    #[doc = "< [in,out] The enabling of maximum input width and height limition. If\n< enabled, super resolution will always take effect if the input\n< resolution is smaller than the below specified max resolution;\n< otherwise, super_resolution_max_in_width and\n< super_resolution_max_in_height will be ignored"]
    pub super_resolution_max_in_enabled: bool,
    #[doc = "< [in,out] The maximum input width limition value setting which super\n< resolution will be allowed to enabled."]
    pub super_resolution_max_in_width: u32,
    #[doc = "< [in,out] The maximum input height limiation value setting which super\n< resolution will be allowed to enabled."]
    pub super_resolution_max_in_height: u32,
    #[doc = "< [in,out] Resetting of super resolution after rebooting."]
    pub super_resolution_reboot_reset: bool,
    #[doc = "< [out] Reserved field of 60 bytes"]
    pub ReservedFields: [u32; 15usize],
    #[doc = "< [out] Reserved field of 3 bytes"]
    pub ReservedBytes: [::std::os::raw::c_char; 3usize],
}
#[doc = "\n @brief Noise Reduction feature details structure to be used with\n        NOISE_REDUCTION"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_video_processing_noise_reduction_info_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Noise reduction min, max, default and step size information"]
    pub noise_reduction: ctl_property_info_uint_t,
    #[doc = "< [in,out] Noise reduction Auto Detect is supported; only valid if\n< NOISE_REDUCTION is enabled.  If enabled, noise reduction level is\n< automatically determined and set value is not used."]
    pub noise_reduction_auto_detect_supported: bool,
    #[doc = "< [in,out] Noise reduction auto detect default information"]
    pub noise_reduction_auto_detect: ctl_property_info_boolean_t,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[doc = "\n @brief Noise Reduction Get/Set structure to be used with NOISE_REDUCTION"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_video_processing_noise_reduction_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Noise reduction enable and value setting"]
    pub noise_reduction: ctl_property_uint_t,
    #[doc = "< [in,out] Noise reduction auto detect setting"]
    pub noise_reduction_auto_detect: ctl_property_boolean_t,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[doc = "\n @brief Adaptive Contrast Enhancement feature details structure to be used\n        with ADAPTIVE_CONTRAST_ENHANCEMENT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_video_processing_adaptive_contrast_enhancement_info_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Adaptive Contrast Enhancement min, max, default and step size\n< information"]
    pub adaptive_contrast_enhancement: ctl_property_info_uint_t,
    #[doc = "< [in,out] Adaptive contrast enhancement coexistance is supported; only\n< valid if ADAPTIVE_CONTRAST_ENHANCEMENT is enabled.  If enabled, Video\n< adaptive contrast ehancement will be allowed to be enabled and coexist\n< with Display adaptive contrast ehancement feature."]
    pub adaptive_contrast_enhancement_coexistence_supported: bool,
    #[doc = "< [in,out] Adaptive contrast enhancement coexistence default information"]
    pub adaptive_contrast_enhancement_coexistence: ctl_property_info_boolean_t,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[doc = "\n @brief Adaptive Contrast Enhancement Get/Set structure to be used with\n        ADAPTIVE_CONTRAST_ENHANCEMENT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_video_processing_adaptive_contrast_enhancement_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Adaptive Contrast Enhancement enable and value setting"]
    pub adaptive_contrast_enhancement: ctl_property_uint_t,
    #[doc = "< [in,out] Adaptive contrast enhancement coexistance setting"]
    pub adaptive_contrast_enhancement_coexistence: ctl_property_boolean_t,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[doc = "\n @brief Standard Color Correction feature details structure to be used with\n        STANDARD_COLOR_CORRECTION"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_video_processing_standard_color_correction_info_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] STANDARD_COLOR_CORRECTION default enable setting.  This\n< global settings controls all of Hue, Saturation, Contrast, Brightness\n< enabling.  Individual Enable controls shall be ignored."]
    pub standard_color_correction_default_enable: bool,
    #[doc = "< [in,out] Brightness min, max, default and step size information"]
    pub brightness: ctl_property_info_float_t,
    #[doc = "< [in,out] Contrast min, max, default and step size information"]
    pub contrast: ctl_property_info_float_t,
    #[doc = "< [in,out] Hue min, max, default and step size information"]
    pub hue: ctl_property_info_float_t,
    #[doc = "< [in,out] Saturation min, max, default and step size information"]
    pub saturation: ctl_property_info_float_t,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[doc = "\n @brief Standard Color Correction Get/Set structure to be used with\n        STANDARD_COLOR_CORRECTION"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_video_processing_standard_color_correction_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] STANDARD_COLOR_CORRECTION enable setting.  This global\n< setting controls all of Hue, Saturation, Contrast, Brightness\n< enabling."]
    pub standard_color_correction_enable: bool,
    #[doc = "< [in,out] Brightness value"]
    pub brightness: f32,
    #[doc = "< [in,out] Contrast value"]
    pub contrast: f32,
    #[doc = "< [in,out] Hue value"]
    pub hue: f32,
    #[doc = "< [in,out] Saturation value"]
    pub saturation: f32,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[doc = "\n @brief Total Color Correction Get/Set structure to be used with\n        TOTAL_COLOR_CORRECTION"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_video_processing_total_color_correction_info_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] TOTAL_COLOR_CORRECTION enable setting.  This global setting\n< controls all of Red, Green, Blue, Yellow, Cyan, Magenta enabling.\n< Individual Enable controls shall be ignored."]
    pub total_color_correction_default_enable: bool,
    #[doc = "< [in,out] Red min, max, default and step size information"]
    pub red: ctl_property_info_uint_t,
    #[doc = "< [in,out] Green min, max, default and step size information"]
    pub green: ctl_property_info_uint_t,
    #[doc = "< [in,out] Blue min, max, default and step size information"]
    pub blue: ctl_property_info_uint_t,
    #[doc = "< [in,out] Yellow min, max, default and step size information"]
    pub yellow: ctl_property_info_uint_t,
    #[doc = "< [in,out] Cyan min, max, default and step size information"]
    pub cyan: ctl_property_info_uint_t,
    #[doc = "< [in,out] Magenta min, max, default and step size information"]
    pub magenta: ctl_property_info_uint_t,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[doc = "\n @brief Total Color Correction Get/Set structure to be used with\n        TOTAL_COLOR_CORRECTION"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_video_processing_total_color_correction_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] TOTAL_COLOR_CORRECTION enable setting.  This global setting\n< controls all of Red, Green, Blue, Yellow, Cyan, Magenta enabling."]
    pub total_color_correction_enable: bool,
    #[doc = "< [in,out] Red value"]
    pub red: u32,
    #[doc = "< [in,out] Green value"]
    pub green: u32,
    #[doc = "< [in,out] Blue value"]
    pub blue: u32,
    #[doc = "< [in,out] Yellow value"]
    pub yellow: u32,
    #[doc = "< [in,out] Cyan value"]
    pub cyan: u32,
    #[doc = "< [in,out] Magenta value"]
    pub magenta: u32,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[doc = "\n @brief Video Processing feature details which will have range supported and\n        default values"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_video_processing_feature_details_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Video processing feature type"]
    pub FeatureType: ctl_video_processing_feature_t,
    #[doc = "< [out] Type of value"]
    pub ValueType: ctl_property_value_type_t,
    #[doc = "< [out] Union of various type of values for Video Processing features.\n< For enum types this can be noise reduction, color control etc. This\n< member is valid iff ValueType is not CTL_PROPERTY_VALUE_TYPE_CUSTOM"]
    pub Value: ctl_property_info_t,
    #[doc = "< [in] CustomValue buffer size"]
    pub CustomValueSize: i32,
    #[doc = "< [in,out] Pointer to a custom structure. Features that use CustomType,\n< after the first query for all of the supported features the user needs\n< to allocate this buffer and then query again just this specific\n< feature for the structure to be filled in. Caller should allocate this\n< buffer with known custom feature structure size. This member is valid\n< iff ValueType is CTL_PROPERTY_VALUE_TYPE_CUSTOM."]
    pub pCustomValue: *mut ::std::os::raw::c_void,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
impl Default for _ctl_video_processing_feature_details_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _ctl_video_processing_feature_details_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "_ctl_video_processing_feature_details_t {{ FeatureType: {:?}, ValueType: {:?}, Value: {:?}, pCustomValue: {:?}, ReservedFields: {:?} }}" , self . FeatureType , self . ValueType , self . Value , self . pCustomValue , self . ReservedFields)
    }
}
#[doc = "\n @brief Video Processing features which are controllable"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_video_processing_feature_caps_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Number of elements in supported features array"]
    pub NumSupportedFeatures: u32,
    #[doc = "< [in,out] Array of supported features and their details"]
    pub pFeatureDetails: *mut ctl_video_processing_feature_details_t,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
impl Default for _ctl_video_processing_feature_caps_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Video Processing feature for get/set"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_video_processing_feature_getset_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Features interested in"]
    pub FeatureType: ctl_video_processing_feature_t,
    #[doc = "< [in] Application name for which the property type is applicable. If\n< this is an empty string then this will get/set global settings for the\n< given adapter. Note that this should contain only the name of the\n< application and not the system specific path.  [This is not currently\n< supported and should be an empty string.]"]
    pub ApplicationName: *mut ::std::os::raw::c_char,
    #[doc = "< [in] Length of ApplicationName string"]
    pub ApplicationNameLength: i8,
    #[doc = "< [in] Set this if it's a set call"]
    pub bSet: bool,
    #[doc = "< [in] Type of value. Caller has to ensure it provides the right value\n< type which decides how one read the union structure below"]
    pub ValueType: ctl_property_value_type_t,
    #[doc = "< [in,out] Union of various type of values for Video Processing\n< features. For enum types this can be noise reduction, color control\n< etc. This member is valid iff ValueType is not\n< CTL_PROPERTY_VALUE_TYPE_CUSTOM"]
    pub Value: ctl_property_t,
    #[doc = "< [in] CustomValue buffer size.  For a feature requiring custom struct,\n< caller will know of it upfront the struct to use based on the feautre\n< and can provide the right size info here"]
    pub CustomValueSize: i32,
    #[doc = "< [in,out] Pointer to a custom structure. Caller should allocate this\n< buffer with known custom feature structure size. This member is valid\n< iff ValueType is CTL_PROPERTY_VALUE_TYPE_CUSTOM"]
    pub pCustomValue: *mut ::std::os::raw::c_void,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
impl Default for _ctl_video_processing_feature_getset_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _ctl_video_processing_feature_getset_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "_ctl_video_processing_feature_getset_t {{ FeatureType: {:?}, ApplicationName: {:?}, bSet: {:?}, ValueType: {:?}, Value: {:?}, pCustomValue: {:?}, ReservedFields: {:?} }}" , self . FeatureType , self . ApplicationName , self . bSet , self . ValueType , self . Value , self . pCustomValue , self . ReservedFields)
    }
}
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Memory module types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_mem_type_t {
    #[doc = "< HBM memory"]
    CTL_MEM_TYPE_HBM = 0,
    #[doc = "< DDR memory"]
    CTL_MEM_TYPE_DDR = 1,
    #[doc = "< DDR3 memory"]
    CTL_MEM_TYPE_DDR3 = 2,
    #[doc = "< DDR4 memory"]
    CTL_MEM_TYPE_DDR4 = 3,
    #[doc = "< DDR5 memory"]
    CTL_MEM_TYPE_DDR5 = 4,
    #[doc = "< LPDDR memory"]
    CTL_MEM_TYPE_LPDDR = 5,
    #[doc = "< LPDDR3 memory"]
    CTL_MEM_TYPE_LPDDR3 = 6,
    #[doc = "< LPDDR4 memory"]
    CTL_MEM_TYPE_LPDDR4 = 7,
    #[doc = "< LPDDR5 memory"]
    CTL_MEM_TYPE_LPDDR5 = 8,
    #[doc = "< GDDR4 memory"]
    CTL_MEM_TYPE_GDDR4 = 9,
    #[doc = "< GDDR5 memory"]
    CTL_MEM_TYPE_GDDR5 = 10,
    #[doc = "< GDDR5X memory"]
    CTL_MEM_TYPE_GDDR5X = 11,
    #[doc = "< GDDR6 memory"]
    CTL_MEM_TYPE_GDDR6 = 12,
    #[doc = "< GDDR6X memory"]
    CTL_MEM_TYPE_GDDR6X = 13,
    #[doc = "< GDDR7 memory"]
    CTL_MEM_TYPE_GDDR7 = 14,
    #[doc = "< UNKNOWN memory"]
    CTL_MEM_TYPE_UNKNOWN = 15,
    CTL_MEM_TYPE_MAX = 16,
}
#[doc = "\n @brief Memory module types"]
pub use self::_ctl_mem_type_t as ctl_mem_type_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Memory module location"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_mem_loc_t {
    #[doc = "< System memory"]
    CTL_MEM_LOC_SYSTEM = 0,
    #[doc = "< On board local device memory"]
    CTL_MEM_LOC_DEVICE = 1,
    CTL_MEM_LOC_MAX = 2,
}
#[doc = "\n @brief Memory module location"]
pub use self::_ctl_mem_loc_t as ctl_mem_loc_t;
#[doc = "\n @brief Memory properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_mem_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] The memory type"]
    pub type_: ctl_mem_type_t,
    #[doc = "< [out] Location of this memory (system, device)"]
    pub location: ctl_mem_loc_t,
    #[doc = "< [out] Physical memory size in bytes. A value of 0 indicates that this\n< property is not known. However, a call to ::ctlMemoryGetState() will\n< correctly return the total size of usable memory."]
    pub physicalSize: u64,
    #[doc = "< [out] Width of the memory bus. A value of -1 means that this property\n< is unknown."]
    pub busWidth: i32,
    #[doc = "< [out] The number of memory channels. A value of -1 means that this\n< property is unknown."]
    pub numChannels: i32,
}
impl Default for _ctl_mem_properties_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Memory state - health, allocated\n\n @details\n     - Percent allocation is given by 100 * (size - free / size.\n     - Percent free is given by 100 * free / size."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_mem_state_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] The free memory in bytes"]
    pub free: u64,
    #[doc = "< [out] The total allocatable memory in bytes (can be less than\n< ::ctl_mem_properties_t.physicalSize)"]
    pub size: u64,
}
#[doc = "\n @brief Memory bandwidth\n\n @details\n     - Percent bandwidth is calculated by taking two snapshots (s1, s2) and\n       using the equation: %bw = 10^6 * ((s2.readCounter - s1.readCounter) +\n       (s2.writeCounter - s1.writeCounter)) / (s2.maxBandwidth *\n       (s2.timestamp - s1.timestamp))"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_mem_bandwidth_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Current maximum bandwidth in units of bytes/sec"]
    pub maxBandwidth: u64,
    #[doc = "< [out] The timestamp (in microseconds) when these measurements were sampled.\n< This timestamp should only be used to calculate delta time between\n< snapshots of this structure.\n< Never take the delta of this timestamp with the timestamp from a\n< different structure since they are not guaranteed to have the same base.\n< The absolute value of the timestamp is only valid during within the\n< application and may be different on the next execution."]
    pub timestamp: u64,
    #[doc = "< [out] Total bytes read from memory. Supported only for Version > 0"]
    pub readCounter: u64,
    #[doc = "< [out] Total bytes written to memory. Supported only for Version > 0"]
    pub writeCounter: u64,
}
#[doc = "\n @brief Telemetry Item for each telemetry property\n\n @details\n     - If the supported field is true, then the entire structure has valid\n       information.\n     - The ::ctl_data_value_t is of type ::ctl_data_type_t and units\n       ::ctl_units_t"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_oc_telemetry_item_t {
    #[doc = "< [out] Indicates if the value is supported."]
    pub bSupported: bool,
    #[doc = "< [out] Indicates the units of the value."]
    pub units: ctl_units_t,
    #[doc = "< [out] Indicates the data type."]
    pub type_: ctl_data_type_t,
    #[doc = "< [out] The value of type ::ctl_data_type_t and units ::ctl_units_t."]
    pub value: ctl_data_value_t,
}
impl Default for _ctl_oc_telemetry_item_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _ctl_oc_telemetry_item_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_ctl_oc_telemetry_item_t {{ bSupported: {:?}, units: {:?}, type: {:?}, value: {:?} }}",
            self.bSupported, self.units, self.type_, self.value
        )
    }
}
#[doc = "\n @brief Overclocking Control Information\n\n @details\n     - Whether the device supports overclocking.\n     - The\n       bSupported/bRelative/bReference/units/min/max/step/default/reference\n       values for the available overclock controls\n     - The idea is to facilitate the way the applications present overclock\n       settings to the user. If bSupported is false, the corresponding\n       overclock control is not supported\n     - The setting units will be an enum that enables the application to know\n       the units for the control setting e.g. MHz. The min and max settings\n       give the limits for the control.\n     - The step setting gives the minimum change in the control value (plus\n       or minus) - if a control is not changed by at least this amount, the\n       hardware may round up or down.\n     - The default values gives the manufacturing setting for the control.\n       Some controls such as frequency offset and voltage offset are\n       relative; in this case, bRelative will be true, otherwise the control\n       settings are absolute values.\n     - For relative controls and if bReference is true, the reference value\n       gives the absolute value at the default setting.\n     - If bReference is false, the absolute value of the default setting is\n       no not known and it is probably better to display the setting to users\n       as percentage offsets."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_oc_control_info_t {
    #[doc = "< [out] Indicates if the values are known."]
    pub bSupported: bool,
    #[doc = "< [out] Indicates if the values are meant to be taken as relative values\n< instead of absolut values."]
    pub bRelative: bool,
    #[doc = "< [out] For relative values, this indicates if a reference is available."]
    pub bReference: bool,
    #[doc = "< [out] Units for the values."]
    pub units: ctl_units_t,
    #[doc = "< [out] Minimum Value."]
    pub min: f64,
    #[doc = "< [out] Maximum Value."]
    pub max: f64,
    #[doc = "< [out] Step Value."]
    pub step: f64,
    #[doc = "< [out] Default Value."]
    pub Default: f64,
    #[doc = "< [out] Reference Value if the bReference is true."]
    pub reference: f64,
}
impl Default for _ctl_oc_control_info_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Overclock properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_oc_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Indicates if the adapter supports overclocking."]
    pub bSupported: bool,
    #[doc = "< [out] related to function ::ctlOverclockGpuFrequencyOffsetSet"]
    pub gpuFrequencyOffset: ctl_oc_control_info_t,
    #[doc = "< [out] related to function ::ctlOverclockGpuVoltageOffsetSet"]
    pub gpuVoltageOffset: ctl_oc_control_info_t,
    #[doc = "< [out] Property Field Deprecated / No Longer Supported"]
    pub vramFrequencyOffset: ctl_oc_control_info_t,
    #[doc = "< [out] Property Field Deprecated / No Longer Supported"]
    pub vramVoltageOffset: ctl_oc_control_info_t,
    #[doc = "< [out] related to function ::ctlOverclockPowerLimitSet"]
    pub powerLimit: ctl_oc_control_info_t,
    #[doc = "< [out] related to function ::ctlOverclockTemperatureLimitSet"]
    pub temperatureLimit: ctl_oc_control_info_t,
}
impl Default for _ctl_oc_properties_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Overclock Voltage Frequency Pair"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_oc_vf_pair_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Voltage component of the pair in mV."]
    pub Voltage: f64,
    #[doc = "< [in,out] Frequency component of the pair in MHz."]
    pub Frequency: f64,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief PSU Type."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_psu_type_t {
    #[doc = "< Type of the PSU is unknown."]
    CTL_PSU_TYPE_PSU_NONE = 0,
    #[doc = "< Type of the PSU is PCIe"]
    CTL_PSU_TYPE_PSU_PCIE = 1,
    #[doc = "< Type of the PSU is 6 PIN"]
    CTL_PSU_TYPE_PSU_6PIN = 2,
    #[doc = "< Type of the PSU is 8 PIN"]
    CTL_PSU_TYPE_PSU_8PIN = 3,
    CTL_PSU_TYPE_MAX = 4,
}
#[doc = "\n @brief PSU Type."]
pub use self::_ctl_psu_type_t as ctl_psu_type_t;
#[doc = "\n @brief PSU Info"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_psu_info_t {
    #[doc = "< [out] Indicates if this PSU entry is supported."]
    pub bSupported: bool,
    #[doc = "< [out] Type of the PSU."]
    pub psuType: ctl_psu_type_t,
    #[doc = "< [out] Snapshot of the monotonic energy counter maintained by hardware.\n< It measures the total energy consumed this power source. By taking the\n< delta between two snapshots and dividing by the delta time in seconds,\n< an application can compute the average power."]
    pub energyCounter: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous snapshot of the voltage of this power source."]
    pub voltage: ctl_oc_telemetry_item_t,
}
impl Default for _ctl_psu_info_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _ctl_psu_info_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "_ctl_psu_info_t {{ bSupported: {:?}, psuType: {:?}, energyCounter: {:?}, voltage: {:?} }}" , self . bSupported , self . psuType , self . energyCounter , self . voltage)
    }
}
#[doc = "\n @brief Power Telemetry"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_power_telemetry_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Snapshot of the timestamp counter that measures the total time\n< since Jan 1, 1970 UTC. It is a decimal value in seconds with a minimum\n< accuracy of 1 millisecond."]
    pub timeStamp: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Snapshot of the monotonic energy counter maintained by hardware.\n< It measures the total energy consumed by the GPU chip. By taking the\n< delta between two snapshots and dividing by the delta time in seconds,\n< an application can compute the average power."]
    pub gpuEnergyCounter: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous snapshot of the voltage feeding the GPU chip. It\n< is measured at the power supply output - chip input will be lower."]
    pub gpuVoltage: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous snapshot of the GPU chip frequency."]
    pub gpuCurrentClockFrequency: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous snapshot of the GPU chip temperature, read from\n< the sensor reporting the highest value."]
    pub gpuCurrentTemperature: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Snapshot of the monotonic global activity counter. It measures\n< the time in seconds (accurate down to 1 millisecond) that any GPU\n< engine is busy. By taking the delta between two snapshots and dividing\n< by the delta time in seconds, an application can compute the average\n< percentage utilization of the GPU.."]
    pub globalActivityCounter: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Snapshot of the monotonic 3D/compute activity counter. It\n< measures the time in seconds (accurate down to 1 millisecond) that any\n< 3D render/compute engine is busy. By taking the delta between two\n< snapshots and dividing by the delta time in seconds, an application\n< can compute the average percentage utilization of all 3D\n< render/compute blocks in the GPU."]
    pub renderComputeActivityCounter: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Snapshot of the monotonic media activity counter. It measures\n< the time in seconds (accurate down to 1 millisecond) that any media\n< engine is busy. By taking the delta between two snapshots and dividing\n< by the delta time in seconds, an application can compute the average\n< percentage utilization of all media blocks in the GPU."]
    pub mediaActivityCounter: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous indication that the desired GPU frequency is being\n< throttled because the GPU chip is exceeding the maximum power limits.\n< Increasing the power limits using ::ctlOverclockPowerLimitSet() is one\n< way to remove this limitation."]
    pub gpuPowerLimited: bool,
    #[doc = "< [out] Instantaneous indication that the desired GPU frequency is being\n< throttled because the GPU chip is exceeding the temperature limits.\n< Increasing the temperature limits using\n< ::ctlOverclockTemperatureLimitSet() is one way to reduce this\n< limitation. Improving the cooling solution is another way."]
    pub gpuTemperatureLimited: bool,
    #[doc = "< [out] Instantaneous indication that the desired GPU frequency is being\n< throttled because the GPU chip has exceeded the power supply current\n< limits. A better power supply is required to reduce this limitation."]
    pub gpuCurrentLimited: bool,
    #[doc = "< [out] Instantaneous indication that the GPU frequency cannot be\n< increased because the voltage limits have been reached. Increase the\n< voltage offset using ::ctlOverclockGpuVoltageOffsetSet() is one way to\n< reduce this limitation."]
    pub gpuVoltageLimited: bool,
    #[doc = "< [out] Instantaneous indication that due to lower GPU utilization, the\n< hardware has lowered the GPU frequency."]
    pub gpuUtilizationLimited: bool,
    #[doc = "< [out] Snapshot of the monotonic energy counter maintained by hardware.\n< It measures the total energy consumed by the local memory modules. By\n< taking the delta between two snapshots and dividing by the delta time\n< in seconds, an application can compute the average power."]
    pub vramEnergyCounter: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous snapshot of the voltage feeding the memory\n< modules."]
    pub vramVoltage: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous snapshot of the raw clock frequency driving the\n< memory modules."]
    pub vramCurrentClockFrequency: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous snapshot of the effective data transfer rate that\n< the memory modules can sustain based on the current clock frequency.."]
    pub vramCurrentEffectiveFrequency: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous snapshot of the monotonic counter that measures\n< the read traffic from the memory modules. By taking the delta between\n< two snapshots and dividing by the delta time in seconds, an\n< application can compute the average read bandwidth."]
    pub vramReadBandwidthCounter: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous snapshot of the monotonic counter that measures\n< the write traffic to the memory modules. By taking the delta between\n< two snapshots and dividing by the delta time in seconds, an\n< application can compute the average write bandwidth."]
    pub vramWriteBandwidthCounter: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous snapshot of the GPU chip temperature, read from\n< the sensor reporting the highest value."]
    pub vramCurrentTemperature: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous indication that the memory frequency is being\n< throttled because the memory modules are exceeding the maximum power\n< limits."]
    pub vramPowerLimited: bool,
    #[doc = "< [out] Instantaneous indication that the memory frequency is being\n< throttled because the memory modules are exceeding the temperature\n< limits."]
    pub vramTemperatureLimited: bool,
    #[doc = "< [out] Instantaneous indication that the memory frequency is being\n< throttled because the memory modules have exceeded the power supply\n< current limits."]
    pub vramCurrentLimited: bool,
    #[doc = "< [out] Instantaneous indication that the memory frequency cannot be\n< increased because the voltage limits have been reached."]
    pub vramVoltageLimited: bool,
    #[doc = "< [out] Instantaneous indication that due to lower memory traffic, the\n< hardware has lowered the memory frequency."]
    pub vramUtilizationLimited: bool,
    #[doc = "< [out] Total Card Energy Counter."]
    pub totalCardEnergyCounter: ctl_oc_telemetry_item_t,
    #[doc = "< [out] PSU voltage and power."]
    pub psu: [ctl_psu_info_t; 5usize],
    #[doc = "< [out] Fan speed."]
    pub fanSpeed: [ctl_oc_telemetry_item_t; 5usize],
}
impl Default for _ctl_power_telemetry_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for _ctl_power_telemetry_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "_ctl_power_telemetry_t {{ timeStamp: {:?}, gpuEnergyCounter: {:?}, gpuVoltage: {:?}, gpuCurrentClockFrequency: {:?}, gpuCurrentTemperature: {:?}, globalActivityCounter: {:?}, renderComputeActivityCounter: {:?}, mediaActivityCounter: {:?}, gpuPowerLimited: {:?}, gpuTemperatureLimited: {:?}, gpuCurrentLimited: {:?}, gpuVoltageLimited: {:?}, gpuUtilizationLimited: {:?}, vramEnergyCounter: {:?}, vramVoltage: {:?}, vramCurrentClockFrequency: {:?}, vramCurrentEffectiveFrequency: {:?}, vramReadBandwidthCounter: {:?}, vramWriteBandwidthCounter: {:?}, vramCurrentTemperature: {:?}, vramPowerLimited: {:?}, vramTemperatureLimited: {:?}, vramCurrentLimited: {:?}, vramVoltageLimited: {:?}, vramUtilizationLimited: {:?}, totalCardEnergyCounter: {:?}, psu: {:?}, fanSpeed: {:?} }}" , self . timeStamp , self . gpuEnergyCounter , self . gpuVoltage , self . gpuCurrentClockFrequency , self . gpuCurrentTemperature , self . globalActivityCounter , self . renderComputeActivityCounter , self . mediaActivityCounter , self . gpuPowerLimited , self . gpuTemperatureLimited , self . gpuCurrentLimited , self . gpuVoltageLimited , self . gpuUtilizationLimited , self . vramEnergyCounter , self . vramVoltage , self . vramCurrentClockFrequency , self . vramCurrentEffectiveFrequency , self . vramReadBandwidthCounter , self . vramWriteBandwidthCounter , self . vramCurrentTemperature , self . vramPowerLimited , self . vramTemperatureLimited , self . vramCurrentLimited , self . vramVoltageLimited , self . vramUtilizationLimited , self . totalCardEnergyCounter , self . psu , self . fanSpeed)
    }
}
#[doc = "\n @brief PCI address"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_pci_address_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] BDF domain"]
    pub domain: u32,
    #[doc = "< [out] BDF bus"]
    pub bus: u32,
    #[doc = "< [out] BDF device"]
    pub device: u32,
    #[doc = "< [out] BDF function"]
    pub function: u32,
}
#[doc = "\n @brief PCI speed"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_pci_speed_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] The link generation. A value of -1 means that this property is\n< unknown."]
    pub gen: i32,
    #[doc = "< [out] The number of lanes. A value of -1 means that this property is\n< unknown."]
    pub width: i32,
    #[doc = "< [out] The maximum bandwidth in bytes/sec (sum of all lanes). A value\n< of -1 means that this property is unknown."]
    pub maxBandwidth: i64,
}
#[doc = "\n @brief Static PCI properties"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_pci_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] The BDF address"]
    pub address: ctl_pci_address_t,
    #[doc = "< [out] Fastest port configuration supported by the device (sum of all\n< lanes)"]
    pub maxSpeed: ctl_pci_speed_t,
    #[doc = "< [out] Support for Resizable Bar on this device."]
    pub resizable_bar_supported: bool,
    #[doc = "< [out] Resizable Bar enabled on this device"]
    pub resizable_bar_enabled: bool,
}
#[doc = "\n @brief Dynamic PCI state"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_pci_state_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] The current port configure speed"]
    pub speed: ctl_pci_speed_t,
}
#[doc = "\n @brief Properties related to device power settings"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_power_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Software can change the power limits of this domain assuming the\n< user has permissions."]
    pub canControl: bool,
    #[doc = "< [out] The factory default TDP power limit of the part in milliwatts. A\n< value of -1 means that this is not known."]
    pub defaultLimit: i32,
    #[doc = "< [out] The minimum power limit in milliwatts that can be requested."]
    pub minLimit: i32,
    #[doc = "< [out] The maximum power limit in milliwatts that can be requested."]
    pub maxLimit: i32,
}
#[doc = "\n @brief Energy counter snapshot\n\n @details\n     - Average power is calculated by taking two snapshots (s1, s2) and using\n       the equation: PowerWatts = (s2.energy - s1.energy) / (s2.timestamp -\n       s1.timestamp)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_power_energy_counter_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] The monotonic energy counter in microjoules."]
    pub energy: u64,
    #[doc = "< [out] Microsecond timestamp when energy was captured.\n< This timestamp should only be used to calculate delta time between\n< snapshots of this structure.\n< Never take the delta of this timestamp with the timestamp from a\n< different structure since they are not guaranteed to have the same base.\n< The absolute value of the timestamp is only valid during within the\n< application and may be different on the next execution."]
    pub timestamp: u64,
}
#[doc = "\n @brief Sustained power limits\n\n @details\n     - The power controller (Punit) will throttle the operating frequency if\n       the power averaged over a window (typically seconds) exceeds this\n       limit."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_power_sustained_limit_t {
    #[doc = "< [in,out] indicates if the limit is enabled (true) or ignored (false)"]
    pub enabled: bool,
    #[doc = "< [in,out] power limit in milliwatts"]
    pub power: i32,
    #[doc = "< [in,out] power averaging window (Tau) in milliseconds"]
    pub interval: i32,
}
#[doc = "\n @brief Burst power limit\n\n @details\n     - The power controller (Punit) will throttle the operating frequency of\n       the device if the power averaged over a few milliseconds exceeds a\n       limit known as PL2. Typically PL2 > PL1 so that it permits the\n       frequency to burst higher for short periods than would be otherwise\n       permitted by PL1."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_power_burst_limit_t {
    #[doc = "< [in,out] indicates if the limit is enabled (true) or ignored (false)"]
    pub enabled: bool,
    #[doc = "< [in,out] power limit in milliwatts"]
    pub power: i32,
}
#[doc = "\n @brief Peak power limit\n\n @details\n     - The power controller (Punit) will preemptively throttle the operating\n       frequency of the device when the instantaneous power exceeds this\n       limit. The limit is known as PL4. It expresses the maximum power that\n       can be drawn from the power supply.\n     - If this power limit is removed or set too high, the power supply will\n       generate an interrupt when it detects an overcurrent condition and the\n       power controller will throttle the device frequencies down to min. It\n       is thus better to tune the PL4 value in order to avoid such\n       excursions."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_power_peak_limit_t {
    #[doc = "< [in,out] power limit in milliwatts for the AC power source."]
    pub powerAC: i32,
    #[doc = "< [in,out] power limit in milliwatts for the DC power source. On input,\n< this is ignored if the product does not have a battery. On output,\n< this will be -1 if the product does not have a battery."]
    pub powerDC: i32,
}
#[doc = "\n @brief Power limits"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_power_limits_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] sustained power limit."]
    pub sustainedPowerLimit: ctl_power_sustained_limit_t,
    #[doc = "< [in,out] burst power limit."]
    pub burstPowerLimit: ctl_power_burst_limit_t,
    #[doc = "< [in,out] peak power limit."]
    pub peakPowerLimits: ctl_power_peak_limit_t,
}
#[doc = "\n @brief Energy threshold\n\n @details\n     - ."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ctl_energy_threshold_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Indicates if the energy threshold is enabled."]
    pub enable: bool,
    #[doc = "< [in,out] The energy threshold in Joules. Will be 0.0 if no threshold\n< has been set."]
    pub threshold: f64,
    #[doc = "< [in,out] The host process ID that set the energy threshold. Will be\n< 0xFFFFFFFF if no threshold has been set."]
    pub processId: u32,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @brief Temperature sensors"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _ctl_temp_sensors_t {
    #[doc = "< The maximum temperature across all device sensors"]
    CTL_TEMP_SENSORS_GLOBAL = 0,
    #[doc = "< The maximum temperature across all sensors in the GPU"]
    CTL_TEMP_SENSORS_GPU = 1,
    #[doc = "< The maximum temperature across all sensors in the local memory"]
    CTL_TEMP_SENSORS_MEMORY = 2,
    #[doc = "< The minimum temperature across all device sensors"]
    CTL_TEMP_SENSORS_GLOBAL_MIN = 3,
    #[doc = "< The minimum temperature across all sensors in the GPU"]
    CTL_TEMP_SENSORS_GPU_MIN = 4,
    #[doc = "< The minimum temperature across all sensors in the local device memory"]
    CTL_TEMP_SENSORS_MEMORY_MIN = 5,
    CTL_TEMP_SENSORS_MAX = 6,
}
#[doc = "\n @brief Temperature sensors"]
pub use self::_ctl_temp_sensors_t as ctl_temp_sensors_t;
#[doc = "\n @brief Temperature sensor properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_temp_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Which part of the device the temperature sensor measures"]
    pub type_: ctl_temp_sensors_t,
    #[doc = "< [out] Will contain the maximum temperature for the specific device in\n< degrees Celsius."]
    pub maxTemperature: f64,
}
impl Default for _ctl_temp_properties_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @brief Function-pointer for ctlInit"]
pub type ctl_pfnInit_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ctl_init_args_t, arg2: *mut ctl_api_handle_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlClose"]
pub type ctl_pfnClose_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ctl_api_handle_t) -> ctl_result_t>;
#[doc = "\n @brief Function-pointer for ctlSetRuntimePath"]
pub type ctl_pfnSetRuntimePath_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ctl_runtime_path_args_t) -> ctl_result_t>;
#[doc = "\n @brief Function-pointer for ctlWaitForPropertyChange"]
pub type ctl_pfnWaitForPropertyChange_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_wait_property_change_args_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlReservedCall"]
pub type ctl_pfnReservedCall_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_reserved_args_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSupported3DCapabilities"]
pub type ctl_pfnGetSupported3DCapabilities_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_3d_feature_caps_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSet3DFeature"]
pub type ctl_pfnGetSet3DFeature_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_3d_feature_getset_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlCheckDriverVersion"]
pub type ctl_pfnCheckDriverVersion_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: ctl_version_info_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEnumerateDevices"]
pub type ctl_pfnEnumerateDevices_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_api_handle_t,
        arg2: *mut u32,
        arg3: *mut ctl_device_adapter_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEnumerateDisplayOutputs"]
pub type ctl_pfnEnumerateDisplayOutputs_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut u32,
        arg3: *mut ctl_display_output_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEnumerateI2CPinPairs"]
pub type ctl_pfnEnumerateI2CPinPairs_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut u32,
        arg3: *mut ctl_i2c_pin_pair_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetDeviceProperties"]
pub type ctl_pfnGetDeviceProperties_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_device_adapter_properties_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetDisplayProperties"]
pub type ctl_pfnGetDisplayProperties_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_display_properties_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetAdaperDisplayEncoderProperties"]
pub type ctl_pfnGetAdaperDisplayEncoderProperties_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_adapter_display_encoder_properties_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetZeDevice"]
pub type ctl_pfnGetZeDevice_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut *mut ::std::os::raw::c_void,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSharpnessCaps"]
pub type ctl_pfnGetSharpnessCaps_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_sharpness_caps_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetCurrentSharpness"]
pub type ctl_pfnGetCurrentSharpness_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_sharpness_settings_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlSetCurrentSharpness"]
pub type ctl_pfnSetCurrentSharpness_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_sharpness_settings_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlI2CAccess"]
pub type ctl_pfnI2CAccess_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_i2c_access_args_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlI2CAccessOnPinPair"]
pub type ctl_pfnI2CAccessOnPinPair_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_i2c_pin_pair_handle_t,
        arg2: *mut ctl_i2c_access_pinpair_args_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlAUXAccess"]
pub type ctl_pfnAUXAccess_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_aux_access_args_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetPowerOptimizationCaps"]
pub type ctl_pfnGetPowerOptimizationCaps_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_power_optimization_caps_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetPowerOptimizationSetting"]
pub type ctl_pfnGetPowerOptimizationSetting_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_power_optimization_settings_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlSetPowerOptimizationSetting"]
pub type ctl_pfnSetPowerOptimizationSetting_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_power_optimization_settings_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlSetBrightnessSetting"]
pub type ctl_pfnSetBrightnessSetting_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_set_brightness_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetBrightnessSetting"]
pub type ctl_pfnGetBrightnessSetting_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_get_brightness_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlPixelTransformationGetConfig"]
pub type ctl_pfnPixelTransformationGetConfig_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_pixtx_pipe_get_config_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlPixelTransformationSetConfig"]
pub type ctl_pfnPixelTransformationSetConfig_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_pixtx_pipe_set_config_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlPanelDescriptorAccess"]
pub type ctl_pfnPanelDescriptorAccess_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_panel_descriptor_access_args_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSupportedRetroScalingCapability"]
pub type ctl_pfnGetSupportedRetroScalingCapability_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_retro_scaling_caps_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSetRetroScaling"]
pub type ctl_pfnGetSetRetroScaling_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_retro_scaling_settings_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSupportedScalingCapability"]
pub type ctl_pfnGetSupportedScalingCapability_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_scaling_caps_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetCurrentScaling"]
pub type ctl_pfnGetCurrentScaling_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_scaling_settings_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlSetCurrentScaling"]
pub type ctl_pfnSetCurrentScaling_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_scaling_settings_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetLACEConfig"]
pub type ctl_pfnGetLACEConfig_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_lace_config_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlSetLACEConfig"]
pub type ctl_pfnSetLACEConfig_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_lace_config_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlSoftwarePSR"]
pub type ctl_pfnSoftwarePSR_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_sw_psr_settings_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetIntelArcSyncInfoForMonitor"]
pub type ctl_pfnGetIntelArcSyncInfoForMonitor_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_intel_arc_sync_monitor_params_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEnumerateMuxDevices"]
pub type ctl_pfnEnumerateMuxDevices_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_api_handle_t,
        arg2: *mut u32,
        arg3: *mut ctl_mux_output_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetMuxProperties"]
pub type ctl_pfnGetMuxProperties_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_mux_output_handle_t,
        arg2: *mut ctl_mux_properties_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlSwitchMux"]
pub type ctl_pfnSwitchMux_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_mux_output_handle_t,
        arg2: ctl_display_output_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetIntelArcSyncProfile"]
pub type ctl_pfnGetIntelArcSyncProfile_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_intel_arc_sync_profile_params_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlSetIntelArcSyncProfile"]
pub type ctl_pfnSetIntelArcSyncProfile_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_intel_arc_sync_profile_params_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEdidManagement"]
pub type ctl_pfnEdidManagement_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_edid_management_args_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSetCustomMode"]
pub type ctl_pfnGetSetCustomMode_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_get_set_custom_mode_args_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSetCombinedDisplay"]
pub type ctl_pfnGetSetCombinedDisplay_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_combined_display_args_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSetDisplayGenlock"]
pub type ctl_pfnGetSetDisplayGenlock_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ctl_device_adapter_handle_t,
        arg2: *mut ctl_genlock_args_t,
        arg3: u32,
        arg4: *mut ctl_device_adapter_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetVblankTimestamp"]
pub type ctl_pfnGetVblankTimestamp_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_vblank_ts_args_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlLinkDisplayAdapters"]
pub type ctl_pfnLinkDisplayAdapters_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_lda_args_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlUnlinkDisplayAdapters"]
pub type ctl_pfnUnlinkDisplayAdapters_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t) -> ctl_result_t>;
#[doc = "\n @brief Function-pointer for ctlGetLinkedDisplayAdapters"]
pub type ctl_pfnGetLinkedDisplayAdapters_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_lda_args_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSetDynamicContrastEnhancement"]
pub type ctl_pfnGetSetDynamicContrastEnhancement_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_dce_args_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSetWireFormat"]
pub type ctl_pfnGetSetWireFormat_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_get_set_wire_format_config_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSetDisplaySettings"]
pub type ctl_pfnGetSetDisplaySettings_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_display_settings_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEnumEngineGroups"]
pub type ctl_pfnEnumEngineGroups_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut u32,
        arg3: *mut ctl_engine_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEngineGetProperties"]
pub type ctl_pfnEngineGetProperties_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_engine_handle_t,
        arg2: *mut ctl_engine_properties_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEngineGetActivity"]
pub type ctl_pfnEngineGetActivity_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_engine_handle_t, arg2: *mut ctl_engine_stats_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEnumFans"]
pub type ctl_pfnEnumFans_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut u32,
        arg3: *mut ctl_fan_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFanGetProperties"]
pub type ctl_pfnFanGetProperties_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_fan_handle_t, arg2: *mut ctl_fan_properties_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFanGetConfig"]
pub type ctl_pfnFanGetConfig_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_fan_handle_t, arg2: *mut ctl_fan_config_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFanSetDefaultMode"]
pub type ctl_pfnFanSetDefaultMode_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ctl_fan_handle_t) -> ctl_result_t>;
#[doc = "\n @brief Function-pointer for ctlFanSetFixedSpeedMode"]
pub type ctl_pfnFanSetFixedSpeedMode_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_fan_handle_t, arg2: *const ctl_fan_speed_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFanSetSpeedTableMode"]
pub type ctl_pfnFanSetSpeedTableMode_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_fan_handle_t,
        arg2: *const ctl_fan_speed_table_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFanGetState"]
pub type ctl_pfnFanGetState_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_fan_handle_t,
        arg2: ctl_fan_speed_units_t,
        arg3: *mut i32,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEnumFrequencyDomains"]
pub type ctl_pfnEnumFrequencyDomains_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut u32,
        arg3: *mut ctl_freq_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFrequencyGetProperties"]
pub type ctl_pfnFrequencyGetProperties_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_freq_handle_t, arg2: *mut ctl_freq_properties_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFrequencyGetAvailableClocks"]
pub type ctl_pfnFrequencyGetAvailableClocks_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_freq_handle_t, arg2: *mut u32, arg3: *mut f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFrequencyGetRange"]
pub type ctl_pfnFrequencyGetRange_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_freq_handle_t, arg2: *mut ctl_freq_range_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFrequencySetRange"]
pub type ctl_pfnFrequencySetRange_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_freq_handle_t, arg2: *const ctl_freq_range_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFrequencyGetState"]
pub type ctl_pfnFrequencyGetState_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_freq_handle_t, arg2: *mut ctl_freq_state_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFrequencyGetThrottleTime"]
pub type ctl_pfnFrequencyGetThrottleTime_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_freq_handle_t,
        arg2: *mut ctl_freq_throttle_time_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSupportedVideoProcessingCapabilities"]
pub type ctl_pfnGetSupportedVideoProcessingCapabilities_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_video_processing_feature_caps_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSetVideoProcessingFeature"]
pub type ctl_pfnGetSetVideoProcessingFeature_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_video_processing_feature_getset_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEnumMemoryModules"]
pub type ctl_pfnEnumMemoryModules_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut u32,
        arg3: *mut ctl_mem_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlMemoryGetProperties"]
pub type ctl_pfnMemoryGetProperties_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_mem_handle_t, arg2: *mut ctl_mem_properties_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlMemoryGetState"]
pub type ctl_pfnMemoryGetState_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_mem_handle_t, arg2: *mut ctl_mem_state_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlMemoryGetBandwidth"]
pub type ctl_pfnMemoryGetBandwidth_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_mem_handle_t, arg2: *mut ctl_mem_bandwidth_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockGetProperties"]
pub type ctl_pfnOverclockGetProperties_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_oc_properties_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockWaiverSet"]
pub type ctl_pfnOverclockWaiverSet_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t) -> ctl_result_t>;
#[doc = "\n @brief Function-pointer for ctlOverclockGpuFrequencyOffsetGet"]
pub type ctl_pfnOverclockGpuFrequencyOffsetGet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: *mut f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockGpuFrequencyOffsetSet"]
pub type ctl_pfnOverclockGpuFrequencyOffsetSet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockGpuVoltageOffsetGet"]
pub type ctl_pfnOverclockGpuVoltageOffsetGet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: *mut f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockGpuVoltageOffsetSet"]
pub type ctl_pfnOverclockGpuVoltageOffsetSet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockGpuLockGet"]
pub type ctl_pfnOverclockGpuLockGet_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_oc_vf_pair_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockGpuLockSet"]
pub type ctl_pfnOverclockGpuLockSet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: ctl_oc_vf_pair_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockVramFrequencyOffsetGet"]
pub type ctl_pfnOverclockVramFrequencyOffsetGet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: *mut f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockVramFrequencyOffsetSet"]
pub type ctl_pfnOverclockVramFrequencyOffsetSet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockVramVoltageOffsetGet"]
pub type ctl_pfnOverclockVramVoltageOffsetGet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: *mut f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockVramVoltageOffsetSet"]
pub type ctl_pfnOverclockVramVoltageOffsetSet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockPowerLimitGet"]
pub type ctl_pfnOverclockPowerLimitGet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: *mut f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockPowerLimitSet"]
pub type ctl_pfnOverclockPowerLimitSet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockTemperatureLimitGet"]
pub type ctl_pfnOverclockTemperatureLimitGet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: *mut f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockTemperatureLimitSet"]
pub type ctl_pfnOverclockTemperatureLimitSet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlPowerTelemetryGet"]
pub type ctl_pfnPowerTelemetryGet_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_power_telemetry_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockResetToDefault"]
pub type ctl_pfnOverclockResetToDefault_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t) -> ctl_result_t>;
#[doc = "\n @brief Function-pointer for ctlPciGetProperties"]
pub type ctl_pfnPciGetProperties_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_pci_properties_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlPciGetState"]
pub type ctl_pfnPciGetState_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_pci_state_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEnumPowerDomains"]
pub type ctl_pfnEnumPowerDomains_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut u32,
        arg3: *mut ctl_pwr_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlPowerGetProperties"]
pub type ctl_pfnPowerGetProperties_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_pwr_handle_t, arg2: *mut ctl_power_properties_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlPowerGetEnergyCounter"]
pub type ctl_pfnPowerGetEnergyCounter_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_pwr_handle_t,
        arg2: *mut ctl_power_energy_counter_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlPowerGetLimits"]
pub type ctl_pfnPowerGetLimits_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_pwr_handle_t, arg2: *mut ctl_power_limits_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlPowerSetLimits"]
pub type ctl_pfnPowerSetLimits_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_pwr_handle_t, arg2: *const ctl_power_limits_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEnumTemperatureSensors"]
pub type ctl_pfnEnumTemperatureSensors_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut u32,
        arg3: *mut ctl_temp_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlTemperatureGetProperties"]
pub type ctl_pfnTemperatureGetProperties_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_temp_handle_t, arg2: *mut ctl_temp_properties_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlTemperatureGetState"]
pub type ctl_pfnTemperatureGetState_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_temp_handle_t, arg2: *mut f64) -> ctl_result_t,
>;
pub struct ControlLib {
    __library: ::libloading::Library,
    pub ctlInit: unsafe extern "C" fn(
        pInitDesc: *mut ctl_init_args_t,
        phAPIHandle: *mut ctl_api_handle_t,
    ) -> ctl_result_t,
    pub ctlClose: unsafe extern "C" fn(hAPIHandle: ctl_api_handle_t) -> ctl_result_t,
    pub ctlSetRuntimePath:
        unsafe extern "C" fn(pArgs: *mut ctl_runtime_path_args_t) -> ctl_result_t,
    pub ctlWaitForPropertyChange: unsafe extern "C" fn(
        hDeviceAdapter: ctl_device_adapter_handle_t,
        pArgs: *mut ctl_wait_property_change_args_t,
    ) -> ctl_result_t,
    pub ctlReservedCall: unsafe extern "C" fn(
        hDeviceAdapter: ctl_device_adapter_handle_t,
        pArgs: *mut ctl_reserved_args_t,
    ) -> ctl_result_t,
    pub ctlGetSupported3DCapabilities: unsafe extern "C" fn(
        hDAhandle: ctl_device_adapter_handle_t,
        pFeatureCaps: *mut ctl_3d_feature_caps_t,
    ) -> ctl_result_t,
    pub ctlGetSet3DFeature: unsafe extern "C" fn(
        hDAhandle: ctl_device_adapter_handle_t,
        pFeature: *mut ctl_3d_feature_getset_t,
    ) -> ctl_result_t,
    pub ctlCheckDriverVersion: unsafe extern "C" fn(
        hDeviceAdapter: ctl_device_adapter_handle_t,
        version_info: ctl_version_info_t,
    ) -> ctl_result_t,
    pub ctlEnumerateDevices: unsafe extern "C" fn(
        hAPIHandle: ctl_api_handle_t,
        pCount: *mut u32,
        phDevices: *mut ctl_device_adapter_handle_t,
    ) -> ctl_result_t,
    pub ctlEnumerateDisplayOutputs: unsafe extern "C" fn(
        hDeviceAdapter: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phDisplayOutputs: *mut ctl_display_output_handle_t,
    ) -> ctl_result_t,
    pub ctlEnumerateI2CPinPairs: unsafe extern "C" fn(
        hDeviceAdapter: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phI2cPinPairs: *mut ctl_i2c_pin_pair_handle_t,
    ) -> ctl_result_t,
    pub ctlGetDeviceProperties: unsafe extern "C" fn(
        hDAhandle: ctl_device_adapter_handle_t,
        pProperties: *mut ctl_device_adapter_properties_t,
    ) -> ctl_result_t,
    pub ctlGetDisplayProperties: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pProperties: *mut ctl_display_properties_t,
    ) -> ctl_result_t,
    pub ctlGetAdaperDisplayEncoderProperties: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pProperties: *mut ctl_adapter_display_encoder_properties_t,
    ) -> ctl_result_t,
    pub ctlGetZeDevice: unsafe extern "C" fn(
        hDAhandle: ctl_device_adapter_handle_t,
        pZeDevice: *mut ::std::os::raw::c_void,
        hInstance: *mut *mut ::std::os::raw::c_void,
    ) -> ctl_result_t,
    pub ctlGetSharpnessCaps: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pSharpnessCaps: *mut ctl_sharpness_caps_t,
    ) -> ctl_result_t,
    pub ctlGetCurrentSharpness: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pSharpnessSettings: *mut ctl_sharpness_settings_t,
    ) -> ctl_result_t,
    pub ctlSetCurrentSharpness: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pSharpnessSettings: *mut ctl_sharpness_settings_t,
    ) -> ctl_result_t,
    pub ctlI2CAccess: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pI2cAccessArgs: *mut ctl_i2c_access_args_t,
    ) -> ctl_result_t,
    pub ctlI2CAccessOnPinPair: unsafe extern "C" fn(
        hI2cPinPair: ctl_i2c_pin_pair_handle_t,
        pI2cAccessArgs: *mut ctl_i2c_access_pinpair_args_t,
    ) -> ctl_result_t,
    pub ctlAUXAccess: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pAuxAccessArgs: *mut ctl_aux_access_args_t,
    ) -> ctl_result_t,
    pub ctlGetPowerOptimizationCaps: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pPowerOptimizationCaps: *mut ctl_power_optimization_caps_t,
    ) -> ctl_result_t,
    pub ctlGetPowerOptimizationSetting: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pPowerOptimizationSettings: *mut ctl_power_optimization_settings_t,
    ) -> ctl_result_t,
    pub ctlSetPowerOptimizationSetting: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pPowerOptimizationSettings: *mut ctl_power_optimization_settings_t,
    ) -> ctl_result_t,
    pub ctlSetBrightnessSetting: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pSetBrightnessSetting: *mut ctl_set_brightness_t,
    ) -> ctl_result_t,
    pub ctlGetBrightnessSetting: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pGetBrightnessSetting: *mut ctl_get_brightness_t,
    ) -> ctl_result_t,
    pub ctlPixelTransformationGetConfig: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pPixTxGetConfigArgs: *mut ctl_pixtx_pipe_get_config_t,
    ) -> ctl_result_t,
    pub ctlPixelTransformationSetConfig: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pPixTxSetConfigArgs: *mut ctl_pixtx_pipe_set_config_t,
    ) -> ctl_result_t,
    pub ctlPanelDescriptorAccess: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pPanelDescriptorAccessArgs: *mut ctl_panel_descriptor_access_args_t,
    ) -> ctl_result_t,
    pub ctlGetSupportedRetroScalingCapability: unsafe extern "C" fn(
        hDAhandle: ctl_device_adapter_handle_t,
        pRetroScalingCaps: *mut ctl_retro_scaling_caps_t,
    ) -> ctl_result_t,
    pub ctlGetSetRetroScaling: unsafe extern "C" fn(
        hDAhandle: ctl_device_adapter_handle_t,
        pGetSetRetroScalingType: *mut ctl_retro_scaling_settings_t,
    ) -> ctl_result_t,
    pub ctlGetSupportedScalingCapability: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pScalingCaps: *mut ctl_scaling_caps_t,
    ) -> ctl_result_t,
    pub ctlGetCurrentScaling: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pGetCurrentScalingType: *mut ctl_scaling_settings_t,
    ) -> ctl_result_t,
    pub ctlSetCurrentScaling: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pSetScalingType: *mut ctl_scaling_settings_t,
    ) -> ctl_result_t,
    pub ctlGetLACEConfig: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pLaceConfig: *mut ctl_lace_config_t,
    ) -> ctl_result_t,
    pub ctlSetLACEConfig: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pLaceConfig: *mut ctl_lace_config_t,
    ) -> ctl_result_t,
    pub ctlSoftwarePSR: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pSoftwarePsrSetting: *mut ctl_sw_psr_settings_t,
    ) -> ctl_result_t,
    pub ctlGetIntelArcSyncInfoForMonitor: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pIntelArcSyncMonitorParams: *mut ctl_intel_arc_sync_monitor_params_t,
    ) -> ctl_result_t,
    pub ctlEnumerateMuxDevices: unsafe extern "C" fn(
        hAPIHandle: ctl_api_handle_t,
        pCount: *mut u32,
        phMuxDevices: *mut ctl_mux_output_handle_t,
    ) -> ctl_result_t,
    pub ctlGetMuxProperties: unsafe extern "C" fn(
        hMuxDevice: ctl_mux_output_handle_t,
        pMuxProperties: *mut ctl_mux_properties_t,
    ) -> ctl_result_t,
    pub ctlSwitchMux: unsafe extern "C" fn(
        hMuxDevice: ctl_mux_output_handle_t,
        hInactiveDisplayOutput: ctl_display_output_handle_t,
    ) -> ctl_result_t,
    pub ctlGetIntelArcSyncProfile: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pIntelArcSyncProfileParams: *mut ctl_intel_arc_sync_profile_params_t,
    ) -> ctl_result_t,
    pub ctlSetIntelArcSyncProfile: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pIntelArcSyncProfileParams: *mut ctl_intel_arc_sync_profile_params_t,
    ) -> ctl_result_t,
    pub ctlEdidManagement: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pEdidManagementArgs: *mut ctl_edid_management_args_t,
    ) -> ctl_result_t,
    pub ctlGetSetCustomMode: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pCustomModeArgs: *mut ctl_get_set_custom_mode_args_t,
    ) -> ctl_result_t,
    pub ctlGetSetCombinedDisplay: unsafe extern "C" fn(
        hDeviceAdapter: ctl_device_adapter_handle_t,
        pCombinedDisplayArgs: *mut ctl_combined_display_args_t,
    ) -> ctl_result_t,
    pub ctlGetSetDisplayGenlock: unsafe extern "C" fn(
        hDeviceAdapter: *mut ctl_device_adapter_handle_t,
        pGenlockArgs: *mut ctl_genlock_args_t,
        AdapterCount: u32,
        hFailureDeviceAdapter: *mut ctl_device_adapter_handle_t,
    ) -> ctl_result_t,
    pub ctlGetVblankTimestamp: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pVblankTSArgs: *mut ctl_vblank_ts_args_t,
    ) -> ctl_result_t,
    pub ctlLinkDisplayAdapters: unsafe extern "C" fn(
        hPrimaryAdapter: ctl_device_adapter_handle_t,
        pLdaArgs: *mut ctl_lda_args_t,
    ) -> ctl_result_t,
    pub ctlUnlinkDisplayAdapters:
        unsafe extern "C" fn(hPrimaryAdapter: ctl_device_adapter_handle_t) -> ctl_result_t,
    pub ctlGetLinkedDisplayAdapters: unsafe extern "C" fn(
        hPrimaryAdapter: ctl_device_adapter_handle_t,
        pLdaArgs: *mut ctl_lda_args_t,
    ) -> ctl_result_t,
    pub ctlGetSetDynamicContrastEnhancement: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pDceArgs: *mut ctl_dce_args_t,
    ) -> ctl_result_t,
    pub ctlGetSetWireFormat: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pGetSetWireFormatSetting: *mut ctl_get_set_wire_format_config_t,
    ) -> ctl_result_t,
    pub ctlGetSetDisplaySettings: unsafe extern "C" fn(
        hDisplayOutput: ctl_display_output_handle_t,
        pDisplaySettings: *mut ctl_display_settings_t,
    ) -> ctl_result_t,
    pub ctlEnumEngineGroups: unsafe extern "C" fn(
        hDAhandle: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phEngine: *mut ctl_engine_handle_t,
    ) -> ctl_result_t,
    pub ctlEngineGetProperties: unsafe extern "C" fn(
        hEngine: ctl_engine_handle_t,
        pProperties: *mut ctl_engine_properties_t,
    ) -> ctl_result_t,
    pub ctlEngineGetActivity: unsafe extern "C" fn(
        hEngine: ctl_engine_handle_t,
        pStats: *mut ctl_engine_stats_t,
    ) -> ctl_result_t,
    pub ctlEnumFans: unsafe extern "C" fn(
        hDAhandle: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phFan: *mut ctl_fan_handle_t,
    ) -> ctl_result_t,
    pub ctlFanGetProperties: unsafe extern "C" fn(
        hFan: ctl_fan_handle_t,
        pProperties: *mut ctl_fan_properties_t,
    ) -> ctl_result_t,
    pub ctlFanGetConfig: unsafe extern "C" fn(
        hFan: ctl_fan_handle_t,
        pConfig: *mut ctl_fan_config_t,
    ) -> ctl_result_t,
    pub ctlFanSetDefaultMode: unsafe extern "C" fn(hFan: ctl_fan_handle_t) -> ctl_result_t,
    pub ctlFanSetFixedSpeedMode:
        unsafe extern "C" fn(hFan: ctl_fan_handle_t, speed: *const ctl_fan_speed_t) -> ctl_result_t,
    pub ctlFanSetSpeedTableMode: unsafe extern "C" fn(
        hFan: ctl_fan_handle_t,
        speedTable: *const ctl_fan_speed_table_t,
    ) -> ctl_result_t,
    pub ctlFanGetState: unsafe extern "C" fn(
        hFan: ctl_fan_handle_t,
        units: ctl_fan_speed_units_t,
        pSpeed: *mut i32,
    ) -> ctl_result_t,
    pub ctlEnumFrequencyDomains: unsafe extern "C" fn(
        hDAhandle: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phFrequency: *mut ctl_freq_handle_t,
    ) -> ctl_result_t,
    pub ctlFrequencyGetProperties: unsafe extern "C" fn(
        hFrequency: ctl_freq_handle_t,
        pProperties: *mut ctl_freq_properties_t,
    ) -> ctl_result_t,
    pub ctlFrequencyGetAvailableClocks: unsafe extern "C" fn(
        hFrequency: ctl_freq_handle_t,
        pCount: *mut u32,
        phFrequency: *mut f64,
    ) -> ctl_result_t,
    pub ctlFrequencyGetRange: unsafe extern "C" fn(
        hFrequency: ctl_freq_handle_t,
        pLimits: *mut ctl_freq_range_t,
    ) -> ctl_result_t,
    pub ctlFrequencySetRange: unsafe extern "C" fn(
        hFrequency: ctl_freq_handle_t,
        pLimits: *const ctl_freq_range_t,
    ) -> ctl_result_t,
    pub ctlFrequencyGetState: unsafe extern "C" fn(
        hFrequency: ctl_freq_handle_t,
        pState: *mut ctl_freq_state_t,
    ) -> ctl_result_t,
    pub ctlFrequencyGetThrottleTime: unsafe extern "C" fn(
        hFrequency: ctl_freq_handle_t,
        pThrottleTime: *mut ctl_freq_throttle_time_t,
    ) -> ctl_result_t,
    pub ctlGetSupportedVideoProcessingCapabilities: unsafe extern "C" fn(
        hDAhandle: ctl_device_adapter_handle_t,
        pFeatureCaps: *mut ctl_video_processing_feature_caps_t,
    ) -> ctl_result_t,
    pub ctlGetSetVideoProcessingFeature: unsafe extern "C" fn(
        hDAhandle: ctl_device_adapter_handle_t,
        pFeature: *mut ctl_video_processing_feature_getset_t,
    ) -> ctl_result_t,
    pub ctlEnumMemoryModules: unsafe extern "C" fn(
        hDAhandle: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phMemory: *mut ctl_mem_handle_t,
    ) -> ctl_result_t,
    pub ctlMemoryGetProperties: unsafe extern "C" fn(
        hMemory: ctl_mem_handle_t,
        pProperties: *mut ctl_mem_properties_t,
    ) -> ctl_result_t,
    pub ctlMemoryGetState: unsafe extern "C" fn(
        hMemory: ctl_mem_handle_t,
        pState: *mut ctl_mem_state_t,
    ) -> ctl_result_t,
    pub ctlMemoryGetBandwidth: unsafe extern "C" fn(
        hMemory: ctl_mem_handle_t,
        pBandwidth: *mut ctl_mem_bandwidth_t,
    ) -> ctl_result_t,
    pub ctlOverclockGetProperties: unsafe extern "C" fn(
        hDeviceHandle: ctl_device_adapter_handle_t,
        pOcProperties: *mut ctl_oc_properties_t,
    ) -> ctl_result_t,
    pub ctlOverclockWaiverSet:
        unsafe extern "C" fn(hDeviceHandle: ctl_device_adapter_handle_t) -> ctl_result_t,
    pub ctlOverclockGpuFrequencyOffsetGet: unsafe extern "C" fn(
        hDeviceHandle: ctl_device_adapter_handle_t,
        pOcFrequencyOffset: *mut f64,
    ) -> ctl_result_t,
    pub ctlOverclockGpuFrequencyOffsetSet: unsafe extern "C" fn(
        hDeviceHandle: ctl_device_adapter_handle_t,
        ocFrequencyOffset: f64,
    ) -> ctl_result_t,
    pub ctlOverclockGpuVoltageOffsetGet: unsafe extern "C" fn(
        hDeviceHandle: ctl_device_adapter_handle_t,
        pOcVoltageOffset: *mut f64,
    ) -> ctl_result_t,
    pub ctlOverclockGpuVoltageOffsetSet: unsafe extern "C" fn(
        hDeviceHandle: ctl_device_adapter_handle_t,
        ocVoltageOffset: f64,
    ) -> ctl_result_t,
    pub ctlOverclockGpuLockGet: unsafe extern "C" fn(
        hDeviceHandle: ctl_device_adapter_handle_t,
        pVfPair: *mut ctl_oc_vf_pair_t,
    ) -> ctl_result_t,
    pub ctlOverclockGpuLockSet: unsafe extern "C" fn(
        hDeviceHandle: ctl_device_adapter_handle_t,
        vFPair: ctl_oc_vf_pair_t,
    ) -> ctl_result_t,
    pub ctlOverclockVramFrequencyOffsetGet: unsafe extern "C" fn(
        hDeviceHandle: ctl_device_adapter_handle_t,
        pOcFrequencyOffset: *mut f64,
    ) -> ctl_result_t,
    pub ctlOverclockVramFrequencyOffsetSet: unsafe extern "C" fn(
        hDeviceHandle: ctl_device_adapter_handle_t,
        ocFrequencyOffset: f64,
    ) -> ctl_result_t,
    pub ctlOverclockVramVoltageOffsetGet: unsafe extern "C" fn(
        hDeviceHandle: ctl_device_adapter_handle_t,
        pVoltage: *mut f64,
    ) -> ctl_result_t,
    pub ctlOverclockVramVoltageOffsetSet: unsafe extern "C" fn(
        hDeviceHandle: ctl_device_adapter_handle_t,
        voltage: f64,
    ) -> ctl_result_t,
    pub ctlOverclockPowerLimitGet: unsafe extern "C" fn(
        hDeviceHandle: ctl_device_adapter_handle_t,
        pSustainedPowerLimit: *mut f64,
    ) -> ctl_result_t,
    pub ctlOverclockPowerLimitSet: unsafe extern "C" fn(
        hDeviceHandle: ctl_device_adapter_handle_t,
        sustainedPowerLimit: f64,
    ) -> ctl_result_t,
    pub ctlOverclockTemperatureLimitGet: unsafe extern "C" fn(
        hDeviceHandle: ctl_device_adapter_handle_t,
        pTemperatureLimit: *mut f64,
    ) -> ctl_result_t,
    pub ctlOverclockTemperatureLimitSet: unsafe extern "C" fn(
        hDeviceHandle: ctl_device_adapter_handle_t,
        temperatureLimit: f64,
    ) -> ctl_result_t,
    pub ctlPowerTelemetryGet: unsafe extern "C" fn(
        hDeviceHandle: ctl_device_adapter_handle_t,
        pTelemetryInfo: *mut ctl_power_telemetry_t,
    ) -> ctl_result_t,
    pub ctlOverclockResetToDefault:
        unsafe extern "C" fn(hDeviceHandle: ctl_device_adapter_handle_t) -> ctl_result_t,
    pub ctlPciGetProperties: unsafe extern "C" fn(
        hDAhandle: ctl_device_adapter_handle_t,
        pProperties: *mut ctl_pci_properties_t,
    ) -> ctl_result_t,
    pub ctlPciGetState: unsafe extern "C" fn(
        hDAhandle: ctl_device_adapter_handle_t,
        pState: *mut ctl_pci_state_t,
    ) -> ctl_result_t,
    pub ctlEnumPowerDomains: unsafe extern "C" fn(
        hDAhandle: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phPower: *mut ctl_pwr_handle_t,
    ) -> ctl_result_t,
    pub ctlPowerGetProperties: unsafe extern "C" fn(
        hPower: ctl_pwr_handle_t,
        pProperties: *mut ctl_power_properties_t,
    ) -> ctl_result_t,
    pub ctlPowerGetEnergyCounter: unsafe extern "C" fn(
        hPower: ctl_pwr_handle_t,
        pEnergy: *mut ctl_power_energy_counter_t,
    ) -> ctl_result_t,
    pub ctlPowerGetLimits: unsafe extern "C" fn(
        hPower: ctl_pwr_handle_t,
        pPowerLimits: *mut ctl_power_limits_t,
    ) -> ctl_result_t,
    pub ctlPowerSetLimits: unsafe extern "C" fn(
        hPower: ctl_pwr_handle_t,
        pPowerLimits: *const ctl_power_limits_t,
    ) -> ctl_result_t,
    pub ctlEnumTemperatureSensors: unsafe extern "C" fn(
        hDAhandle: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phTemperature: *mut ctl_temp_handle_t,
    ) -> ctl_result_t,
    pub ctlTemperatureGetProperties: unsafe extern "C" fn(
        hTemperature: ctl_temp_handle_t,
        pProperties: *mut ctl_temp_properties_t,
    ) -> ctl_result_t,
    pub ctlTemperatureGetState: unsafe extern "C" fn(
        hTemperature: ctl_temp_handle_t,
        pTemperature: *mut f64,
    ) -> ctl_result_t,
}
impl ControlLib {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let ctlInit = __library.get(b"ctlInit\0").map(|sym| *sym)?;
        let ctlClose = __library.get(b"ctlClose\0").map(|sym| *sym)?;
        let ctlSetRuntimePath = __library.get(b"ctlSetRuntimePath\0").map(|sym| *sym)?;
        let ctlWaitForPropertyChange = __library
            .get(b"ctlWaitForPropertyChange\0")
            .map(|sym| *sym)?;
        let ctlReservedCall = __library.get(b"ctlReservedCall\0").map(|sym| *sym)?;
        let ctlGetSupported3DCapabilities = __library
            .get(b"ctlGetSupported3DCapabilities\0")
            .map(|sym| *sym)?;
        let ctlGetSet3DFeature = __library.get(b"ctlGetSet3DFeature\0").map(|sym| *sym)?;
        let ctlCheckDriverVersion = __library.get(b"ctlCheckDriverVersion\0").map(|sym| *sym)?;
        let ctlEnumerateDevices = __library.get(b"ctlEnumerateDevices\0").map(|sym| *sym)?;
        let ctlEnumerateDisplayOutputs = __library
            .get(b"ctlEnumerateDisplayOutputs\0")
            .map(|sym| *sym)?;
        let ctlEnumerateI2CPinPairs = __library
            .get(b"ctlEnumerateI2CPinPairs\0")
            .map(|sym| *sym)?;
        let ctlGetDeviceProperties = __library.get(b"ctlGetDeviceProperties\0").map(|sym| *sym)?;
        let ctlGetDisplayProperties = __library
            .get(b"ctlGetDisplayProperties\0")
            .map(|sym| *sym)?;
        let ctlGetAdaperDisplayEncoderProperties = __library
            .get(b"ctlGetAdaperDisplayEncoderProperties\0")
            .map(|sym| *sym)?;
        let ctlGetZeDevice = __library.get(b"ctlGetZeDevice\0").map(|sym| *sym)?;
        let ctlGetSharpnessCaps = __library.get(b"ctlGetSharpnessCaps\0").map(|sym| *sym)?;
        let ctlGetCurrentSharpness = __library.get(b"ctlGetCurrentSharpness\0").map(|sym| *sym)?;
        let ctlSetCurrentSharpness = __library.get(b"ctlSetCurrentSharpness\0").map(|sym| *sym)?;
        let ctlI2CAccess = __library.get(b"ctlI2CAccess\0").map(|sym| *sym)?;
        let ctlI2CAccessOnPinPair = __library.get(b"ctlI2CAccessOnPinPair\0").map(|sym| *sym)?;
        let ctlAUXAccess = __library.get(b"ctlAUXAccess\0").map(|sym| *sym)?;
        let ctlGetPowerOptimizationCaps = __library
            .get(b"ctlGetPowerOptimizationCaps\0")
            .map(|sym| *sym)?;
        let ctlGetPowerOptimizationSetting = __library
            .get(b"ctlGetPowerOptimizationSetting\0")
            .map(|sym| *sym)?;
        let ctlSetPowerOptimizationSetting = __library
            .get(b"ctlSetPowerOptimizationSetting\0")
            .map(|sym| *sym)?;
        let ctlSetBrightnessSetting = __library
            .get(b"ctlSetBrightnessSetting\0")
            .map(|sym| *sym)?;
        let ctlGetBrightnessSetting = __library
            .get(b"ctlGetBrightnessSetting\0")
            .map(|sym| *sym)?;
        let ctlPixelTransformationGetConfig = __library
            .get(b"ctlPixelTransformationGetConfig\0")
            .map(|sym| *sym)?;
        let ctlPixelTransformationSetConfig = __library
            .get(b"ctlPixelTransformationSetConfig\0")
            .map(|sym| *sym)?;
        let ctlPanelDescriptorAccess = __library
            .get(b"ctlPanelDescriptorAccess\0")
            .map(|sym| *sym)?;
        let ctlGetSupportedRetroScalingCapability = __library
            .get(b"ctlGetSupportedRetroScalingCapability\0")
            .map(|sym| *sym)?;
        let ctlGetSetRetroScaling = __library.get(b"ctlGetSetRetroScaling\0").map(|sym| *sym)?;
        let ctlGetSupportedScalingCapability = __library
            .get(b"ctlGetSupportedScalingCapability\0")
            .map(|sym| *sym)?;
        let ctlGetCurrentScaling = __library.get(b"ctlGetCurrentScaling\0").map(|sym| *sym)?;
        let ctlSetCurrentScaling = __library.get(b"ctlSetCurrentScaling\0").map(|sym| *sym)?;
        let ctlGetLACEConfig = __library.get(b"ctlGetLACEConfig\0").map(|sym| *sym)?;
        let ctlSetLACEConfig = __library.get(b"ctlSetLACEConfig\0").map(|sym| *sym)?;
        let ctlSoftwarePSR = __library.get(b"ctlSoftwarePSR\0").map(|sym| *sym)?;
        let ctlGetIntelArcSyncInfoForMonitor = __library
            .get(b"ctlGetIntelArcSyncInfoForMonitor\0")
            .map(|sym| *sym)?;
        let ctlEnumerateMuxDevices = __library.get(b"ctlEnumerateMuxDevices\0").map(|sym| *sym)?;
        let ctlGetMuxProperties = __library.get(b"ctlGetMuxProperties\0").map(|sym| *sym)?;
        let ctlSwitchMux = __library.get(b"ctlSwitchMux\0").map(|sym| *sym)?;
        let ctlGetIntelArcSyncProfile = __library
            .get(b"ctlGetIntelArcSyncProfile\0")
            .map(|sym| *sym)?;
        let ctlSetIntelArcSyncProfile = __library
            .get(b"ctlSetIntelArcSyncProfile\0")
            .map(|sym| *sym)?;
        let ctlEdidManagement = __library.get(b"ctlEdidManagement\0").map(|sym| *sym)?;
        let ctlGetSetCustomMode = __library.get(b"ctlGetSetCustomMode\0").map(|sym| *sym)?;
        let ctlGetSetCombinedDisplay = __library
            .get(b"ctlGetSetCombinedDisplay\0")
            .map(|sym| *sym)?;
        let ctlGetSetDisplayGenlock = __library
            .get(b"ctlGetSetDisplayGenlock\0")
            .map(|sym| *sym)?;
        let ctlGetVblankTimestamp = __library.get(b"ctlGetVblankTimestamp\0").map(|sym| *sym)?;
        let ctlLinkDisplayAdapters = __library.get(b"ctlLinkDisplayAdapters\0").map(|sym| *sym)?;
        let ctlUnlinkDisplayAdapters = __library
            .get(b"ctlUnlinkDisplayAdapters\0")
            .map(|sym| *sym)?;
        let ctlGetLinkedDisplayAdapters = __library
            .get(b"ctlGetLinkedDisplayAdapters\0")
            .map(|sym| *sym)?;
        let ctlGetSetDynamicContrastEnhancement = __library
            .get(b"ctlGetSetDynamicContrastEnhancement\0")
            .map(|sym| *sym)?;
        let ctlGetSetWireFormat = __library.get(b"ctlGetSetWireFormat\0").map(|sym| *sym)?;
        let ctlGetSetDisplaySettings = __library
            .get(b"ctlGetSetDisplaySettings\0")
            .map(|sym| *sym)?;
        let ctlEnumEngineGroups = __library.get(b"ctlEnumEngineGroups\0").map(|sym| *sym)?;
        let ctlEngineGetProperties = __library.get(b"ctlEngineGetProperties\0").map(|sym| *sym)?;
        let ctlEngineGetActivity = __library.get(b"ctlEngineGetActivity\0").map(|sym| *sym)?;
        let ctlEnumFans = __library.get(b"ctlEnumFans\0").map(|sym| *sym)?;
        let ctlFanGetProperties = __library.get(b"ctlFanGetProperties\0").map(|sym| *sym)?;
        let ctlFanGetConfig = __library.get(b"ctlFanGetConfig\0").map(|sym| *sym)?;
        let ctlFanSetDefaultMode = __library.get(b"ctlFanSetDefaultMode\0").map(|sym| *sym)?;
        let ctlFanSetFixedSpeedMode = __library
            .get(b"ctlFanSetFixedSpeedMode\0")
            .map(|sym| *sym)?;
        let ctlFanSetSpeedTableMode = __library
            .get(b"ctlFanSetSpeedTableMode\0")
            .map(|sym| *sym)?;
        let ctlFanGetState = __library.get(b"ctlFanGetState\0").map(|sym| *sym)?;
        let ctlEnumFrequencyDomains = __library
            .get(b"ctlEnumFrequencyDomains\0")
            .map(|sym| *sym)?;
        let ctlFrequencyGetProperties = __library
            .get(b"ctlFrequencyGetProperties\0")
            .map(|sym| *sym)?;
        let ctlFrequencyGetAvailableClocks = __library
            .get(b"ctlFrequencyGetAvailableClocks\0")
            .map(|sym| *sym)?;
        let ctlFrequencyGetRange = __library.get(b"ctlFrequencyGetRange\0").map(|sym| *sym)?;
        let ctlFrequencySetRange = __library.get(b"ctlFrequencySetRange\0").map(|sym| *sym)?;
        let ctlFrequencyGetState = __library.get(b"ctlFrequencyGetState\0").map(|sym| *sym)?;
        let ctlFrequencyGetThrottleTime = __library
            .get(b"ctlFrequencyGetThrottleTime\0")
            .map(|sym| *sym)?;
        let ctlGetSupportedVideoProcessingCapabilities = __library
            .get(b"ctlGetSupportedVideoProcessingCapabilities\0")
            .map(|sym| *sym)?;
        let ctlGetSetVideoProcessingFeature = __library
            .get(b"ctlGetSetVideoProcessingFeature\0")
            .map(|sym| *sym)?;
        let ctlEnumMemoryModules = __library.get(b"ctlEnumMemoryModules\0").map(|sym| *sym)?;
        let ctlMemoryGetProperties = __library.get(b"ctlMemoryGetProperties\0").map(|sym| *sym)?;
        let ctlMemoryGetState = __library.get(b"ctlMemoryGetState\0").map(|sym| *sym)?;
        let ctlMemoryGetBandwidth = __library.get(b"ctlMemoryGetBandwidth\0").map(|sym| *sym)?;
        let ctlOverclockGetProperties = __library
            .get(b"ctlOverclockGetProperties\0")
            .map(|sym| *sym)?;
        let ctlOverclockWaiverSet = __library.get(b"ctlOverclockWaiverSet\0").map(|sym| *sym)?;
        let ctlOverclockGpuFrequencyOffsetGet = __library
            .get(b"ctlOverclockGpuFrequencyOffsetGet\0")
            .map(|sym| *sym)?;
        let ctlOverclockGpuFrequencyOffsetSet = __library
            .get(b"ctlOverclockGpuFrequencyOffsetSet\0")
            .map(|sym| *sym)?;
        let ctlOverclockGpuVoltageOffsetGet = __library
            .get(b"ctlOverclockGpuVoltageOffsetGet\0")
            .map(|sym| *sym)?;
        let ctlOverclockGpuVoltageOffsetSet = __library
            .get(b"ctlOverclockGpuVoltageOffsetSet\0")
            .map(|sym| *sym)?;
        let ctlOverclockGpuLockGet = __library.get(b"ctlOverclockGpuLockGet\0").map(|sym| *sym)?;
        let ctlOverclockGpuLockSet = __library.get(b"ctlOverclockGpuLockSet\0").map(|sym| *sym)?;
        let ctlOverclockVramFrequencyOffsetGet = __library
            .get(b"ctlOverclockVramFrequencyOffsetGet\0")
            .map(|sym| *sym)?;
        let ctlOverclockVramFrequencyOffsetSet = __library
            .get(b"ctlOverclockVramFrequencyOffsetSet\0")
            .map(|sym| *sym)?;
        let ctlOverclockVramVoltageOffsetGet = __library
            .get(b"ctlOverclockVramVoltageOffsetGet\0")
            .map(|sym| *sym)?;
        let ctlOverclockVramVoltageOffsetSet = __library
            .get(b"ctlOverclockVramVoltageOffsetSet\0")
            .map(|sym| *sym)?;
        let ctlOverclockPowerLimitGet = __library
            .get(b"ctlOverclockPowerLimitGet\0")
            .map(|sym| *sym)?;
        let ctlOverclockPowerLimitSet = __library
            .get(b"ctlOverclockPowerLimitSet\0")
            .map(|sym| *sym)?;
        let ctlOverclockTemperatureLimitGet = __library
            .get(b"ctlOverclockTemperatureLimitGet\0")
            .map(|sym| *sym)?;
        let ctlOverclockTemperatureLimitSet = __library
            .get(b"ctlOverclockTemperatureLimitSet\0")
            .map(|sym| *sym)?;
        let ctlPowerTelemetryGet = __library.get(b"ctlPowerTelemetryGet\0").map(|sym| *sym)?;
        let ctlOverclockResetToDefault = __library
            .get(b"ctlOverclockResetToDefault\0")
            .map(|sym| *sym)?;
        let ctlPciGetProperties = __library.get(b"ctlPciGetProperties\0").map(|sym| *sym)?;
        let ctlPciGetState = __library.get(b"ctlPciGetState\0").map(|sym| *sym)?;
        let ctlEnumPowerDomains = __library.get(b"ctlEnumPowerDomains\0").map(|sym| *sym)?;
        let ctlPowerGetProperties = __library.get(b"ctlPowerGetProperties\0").map(|sym| *sym)?;
        let ctlPowerGetEnergyCounter = __library
            .get(b"ctlPowerGetEnergyCounter\0")
            .map(|sym| *sym)?;
        let ctlPowerGetLimits = __library.get(b"ctlPowerGetLimits\0").map(|sym| *sym)?;
        let ctlPowerSetLimits = __library.get(b"ctlPowerSetLimits\0").map(|sym| *sym)?;
        let ctlEnumTemperatureSensors = __library
            .get(b"ctlEnumTemperatureSensors\0")
            .map(|sym| *sym)?;
        let ctlTemperatureGetProperties = __library
            .get(b"ctlTemperatureGetProperties\0")
            .map(|sym| *sym)?;
        let ctlTemperatureGetState = __library.get(b"ctlTemperatureGetState\0").map(|sym| *sym)?;
        Ok(ControlLib {
            __library,
            ctlInit,
            ctlClose,
            ctlSetRuntimePath,
            ctlWaitForPropertyChange,
            ctlReservedCall,
            ctlGetSupported3DCapabilities,
            ctlGetSet3DFeature,
            ctlCheckDriverVersion,
            ctlEnumerateDevices,
            ctlEnumerateDisplayOutputs,
            ctlEnumerateI2CPinPairs,
            ctlGetDeviceProperties,
            ctlGetDisplayProperties,
            ctlGetAdaperDisplayEncoderProperties,
            ctlGetZeDevice,
            ctlGetSharpnessCaps,
            ctlGetCurrentSharpness,
            ctlSetCurrentSharpness,
            ctlI2CAccess,
            ctlI2CAccessOnPinPair,
            ctlAUXAccess,
            ctlGetPowerOptimizationCaps,
            ctlGetPowerOptimizationSetting,
            ctlSetPowerOptimizationSetting,
            ctlSetBrightnessSetting,
            ctlGetBrightnessSetting,
            ctlPixelTransformationGetConfig,
            ctlPixelTransformationSetConfig,
            ctlPanelDescriptorAccess,
            ctlGetSupportedRetroScalingCapability,
            ctlGetSetRetroScaling,
            ctlGetSupportedScalingCapability,
            ctlGetCurrentScaling,
            ctlSetCurrentScaling,
            ctlGetLACEConfig,
            ctlSetLACEConfig,
            ctlSoftwarePSR,
            ctlGetIntelArcSyncInfoForMonitor,
            ctlEnumerateMuxDevices,
            ctlGetMuxProperties,
            ctlSwitchMux,
            ctlGetIntelArcSyncProfile,
            ctlSetIntelArcSyncProfile,
            ctlEdidManagement,
            ctlGetSetCustomMode,
            ctlGetSetCombinedDisplay,
            ctlGetSetDisplayGenlock,
            ctlGetVblankTimestamp,
            ctlLinkDisplayAdapters,
            ctlUnlinkDisplayAdapters,
            ctlGetLinkedDisplayAdapters,
            ctlGetSetDynamicContrastEnhancement,
            ctlGetSetWireFormat,
            ctlGetSetDisplaySettings,
            ctlEnumEngineGroups,
            ctlEngineGetProperties,
            ctlEngineGetActivity,
            ctlEnumFans,
            ctlFanGetProperties,
            ctlFanGetConfig,
            ctlFanSetDefaultMode,
            ctlFanSetFixedSpeedMode,
            ctlFanSetSpeedTableMode,
            ctlFanGetState,
            ctlEnumFrequencyDomains,
            ctlFrequencyGetProperties,
            ctlFrequencyGetAvailableClocks,
            ctlFrequencyGetRange,
            ctlFrequencySetRange,
            ctlFrequencyGetState,
            ctlFrequencyGetThrottleTime,
            ctlGetSupportedVideoProcessingCapabilities,
            ctlGetSetVideoProcessingFeature,
            ctlEnumMemoryModules,
            ctlMemoryGetProperties,
            ctlMemoryGetState,
            ctlMemoryGetBandwidth,
            ctlOverclockGetProperties,
            ctlOverclockWaiverSet,
            ctlOverclockGpuFrequencyOffsetGet,
            ctlOverclockGpuFrequencyOffsetSet,
            ctlOverclockGpuVoltageOffsetGet,
            ctlOverclockGpuVoltageOffsetSet,
            ctlOverclockGpuLockGet,
            ctlOverclockGpuLockSet,
            ctlOverclockVramFrequencyOffsetGet,
            ctlOverclockVramFrequencyOffsetSet,
            ctlOverclockVramVoltageOffsetGet,
            ctlOverclockVramVoltageOffsetSet,
            ctlOverclockPowerLimitGet,
            ctlOverclockPowerLimitSet,
            ctlOverclockTemperatureLimitGet,
            ctlOverclockTemperatureLimitSet,
            ctlPowerTelemetryGet,
            ctlOverclockResetToDefault,
            ctlPciGetProperties,
            ctlPciGetState,
            ctlEnumPowerDomains,
            ctlPowerGetProperties,
            ctlPowerGetEnergyCounter,
            ctlPowerGetLimits,
            ctlPowerSetLimits,
            ctlEnumTemperatureSensors,
            ctlTemperatureGetProperties,
            ctlTemperatureGetState,
        })
    }
    #[doc = "\n @brief Control Api Init\n\n @details\n     - Control Api Init\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pInitDesc`\n         + `nullptr == phAPIHandle`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlInit(
        &self,
        pInitDesc: *mut ctl_init_args_t,
        phAPIHandle: *mut ctl_api_handle_t,
    ) -> ctl_result_t {
        (self.ctlInit)(pInitDesc, phAPIHandle)
    }
    #[doc = "\n @brief Control Api Destroy\n\n @details\n     - Control Api Close\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hAPIHandle`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlClose(&self, hAPIHandle: ctl_api_handle_t) -> ctl_result_t {
        (self.ctlClose)(hAPIHandle)
    }
    #[doc = "\n @brief Runtime path\n\n @details\n     - Control Api set runtime path. Optional call from a loader which allows\n       the loaded runtime to enumerate only the adapters which the specified\n       runtime is responsible for. This is done usually by a loader or by\n       callers who know how to get the specific runtime of interest. This\n       call right now is reserved for use by Intel components.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlSetRuntimePath(&self, pArgs: *mut ctl_runtime_path_args_t) -> ctl_result_t {
        (self.ctlSetRuntimePath)(pArgs)
    }
    #[doc = "\n @brief Wait for a property change. Note that this is a blocking call\n\n @details\n     - Wait for a property change in display, 3d, media etc.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceAdapter`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlWaitForPropertyChange(
        &self,
        hDeviceAdapter: ctl_device_adapter_handle_t,
        pArgs: *mut ctl_wait_property_change_args_t,
    ) -> ctl_result_t {
        (self.ctlWaitForPropertyChange)(hDeviceAdapter, pArgs)
    }
    #[doc = "\n @brief Reserved function\n\n @details\n     - Reserved function\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceAdapter`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlReservedCall(
        &self,
        hDeviceAdapter: ctl_device_adapter_handle_t,
        pArgs: *mut ctl_reserved_args_t,
    ) -> ctl_result_t {
        (self.ctlReservedCall)(hDeviceAdapter, pArgs)
    }
    #[doc = "\n @brief Get 3D capabilities\n\n @details\n     - The application gets 3D properties\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pFeatureCaps`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlGetSupported3DCapabilities(
        &self,
        hDAhandle: ctl_device_adapter_handle_t,
        pFeatureCaps: *mut ctl_3d_feature_caps_t,
    ) -> ctl_result_t {
        (self.ctlGetSupported3DCapabilities)(hDAhandle, pFeatureCaps)
    }
    #[doc = "\n @brief Get/Set 3D feature\n\n @details\n     - 3D feature details\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pFeature`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlGetSet3DFeature(
        &self,
        hDAhandle: ctl_device_adapter_handle_t,
        pFeature: *mut ctl_3d_feature_getset_t,
    ) -> ctl_result_t {
        (self.ctlGetSet3DFeature)(hDAhandle, pFeature)
    }
    #[doc = "\n @brief Check Driver version\n\n @details\n     - The application checks driver version\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceAdapter`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlCheckDriverVersion(
        &self,
        hDeviceAdapter: ctl_device_adapter_handle_t,
        version_info: ctl_version_info_t,
    ) -> ctl_result_t {
        (self.ctlCheckDriverVersion)(hDeviceAdapter, version_info)
    }
    #[doc = "\n @brief Enumerate devices\n\n @details\n     - The application enumerates all device adapters in the system\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hAPIHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCount`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlEnumerateDevices(
        &self,
        hAPIHandle: ctl_api_handle_t,
        pCount: *mut u32,
        phDevices: *mut ctl_device_adapter_handle_t,
    ) -> ctl_result_t {
        (self.ctlEnumerateDevices)(hAPIHandle, pCount, phDevices)
    }
    #[doc = "\n @brief Enumerate display outputs\n\n @details\n     - Enumerates display output capabilities\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceAdapter`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCount`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlEnumerateDisplayOutputs(
        &self,
        hDeviceAdapter: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phDisplayOutputs: *mut ctl_display_output_handle_t,
    ) -> ctl_result_t {
        (self.ctlEnumerateDisplayOutputs)(hDeviceAdapter, pCount, phDisplayOutputs)
    }
    #[doc = "\n @brief Enumerate I2C Pin Pairs\n\n @details\n     - Returns available list of I2C Pin-Pairs on a requested adapter\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceAdapter`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCount`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"The incoming pointer pCount is null\"\n     - ::CTL_RESULT_ERROR_INVALID_SIZE - \"The supplied Count is not equal to actual number of i2c pin-pair instances\""]
    pub unsafe fn ctlEnumerateI2CPinPairs(
        &self,
        hDeviceAdapter: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phI2cPinPairs: *mut ctl_i2c_pin_pair_handle_t,
    ) -> ctl_result_t {
        (self.ctlEnumerateI2CPinPairs)(hDeviceAdapter, pCount, phI2cPinPairs)
    }
    #[doc = "\n @brief Get Device Properties\n\n @details\n     - The application gets device properties\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pProperties`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlGetDeviceProperties(
        &self,
        hDAhandle: ctl_device_adapter_handle_t,
        pProperties: *mut ctl_device_adapter_properties_t,
    ) -> ctl_result_t {
        (self.ctlGetDeviceProperties)(hDAhandle, pProperties)
    }
    #[doc = "\n @brief Get Display  Properties\n\n @details\n     - The application gets display  properties\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pProperties`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlGetDisplayProperties(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pProperties: *mut ctl_display_properties_t,
    ) -> ctl_result_t {
        (self.ctlGetDisplayProperties)(hDisplayOutput, pProperties)
    }
    #[doc = "\n @brief Get Adapter Display encoder  Properties\n\n @details\n     - The application gets the graphic adapters display encoder properties\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pProperties`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlGetAdaperDisplayEncoderProperties(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pProperties: *mut ctl_adapter_display_encoder_properties_t,
    ) -> ctl_result_t {
        (self.ctlGetAdaperDisplayEncoderProperties)(hDisplayOutput, pProperties)
    }
    #[doc = "\n @brief Get Level0 Device handle\n\n @details\n     - The application gets OneAPI Level0 Device handles\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pZeDevice`\n         + `nullptr == hInstance`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlGetZeDevice(
        &self,
        hDAhandle: ctl_device_adapter_handle_t,
        pZeDevice: *mut ::std::os::raw::c_void,
        hInstance: *mut *mut ::std::os::raw::c_void,
    ) -> ctl_result_t {
        (self.ctlGetZeDevice)(hDAhandle, pZeDevice, hInstance)
    }
    #[doc = "\n @brief Get Sharpness capability\n\n @details\n     - Returns sharpness capability\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pSharpnessCaps`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlGetSharpnessCaps(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pSharpnessCaps: *mut ctl_sharpness_caps_t,
    ) -> ctl_result_t {
        (self.ctlGetSharpnessCaps)(hDisplayOutput, pSharpnessCaps)
    }
    #[doc = "\n @brief Get Sharpness setting\n\n @details\n     - Returns current sharpness settings\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pSharpnessSettings`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlGetCurrentSharpness(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pSharpnessSettings: *mut ctl_sharpness_settings_t,
    ) -> ctl_result_t {
        (self.ctlGetCurrentSharpness)(hDisplayOutput, pSharpnessSettings)
    }
    #[doc = "\n @brief Set Sharpness setting\n\n @details\n     - Set current sharpness settings\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pSharpnessSettings`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlSetCurrentSharpness(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pSharpnessSettings: *mut ctl_sharpness_settings_t,
    ) -> ctl_result_t {
        (self.ctlSetCurrentSharpness)(hDisplayOutput, pSharpnessSettings)
    }
    #[doc = "\n @brief I2C Access\n\n @details\n     - Interface to access I2C using display handle as identifier.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pI2cAccessArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_OPERATION_TYPE - \"Invalid operation type\"\n     - ::CTL_RESULT_ERROR_INVALID_SIZE - \"Invalid I2C data size\"\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS - \"Insufficient permissions\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernal mode driver call failure\""]
    pub unsafe fn ctlI2CAccess(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pI2cAccessArgs: *mut ctl_i2c_access_args_t,
    ) -> ctl_result_t {
        (self.ctlI2CAccess)(hDisplayOutput, pI2cAccessArgs)
    }
    #[doc = "\n @brief I2C Access On Pin Pair\n\n @details\n     - Interface to access I2C using pin-pair handle as identifier.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hI2cPinPair`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pI2cAccessArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_OPERATION_TYPE - \"Invalid operation type\"\n     - ::CTL_RESULT_ERROR_INVALID_SIZE - \"Invalid I2C data size\"\n     - ::CTL_RESULT_ERROR_INVALID_ARGUMENT - \"Invalid Args passed\"\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS - \"Insufficient permissions\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernal mode driver call failure\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_HANDLE - \"Invalid or Null handle passed\"\n     - ::CTL_RESULT_ERROR_EXTERNAL_DISPLAY_ATTACHED - \"Write to Address not allowed when Display is connected\""]
    pub unsafe fn ctlI2CAccessOnPinPair(
        &self,
        hI2cPinPair: ctl_i2c_pin_pair_handle_t,
        pI2cAccessArgs: *mut ctl_i2c_access_pinpair_args_t,
    ) -> ctl_result_t {
        (self.ctlI2CAccessOnPinPair)(hI2cPinPair, pI2cAccessArgs)
    }
    #[doc = "\n @brief Aux Access\n\n @details\n     - The application does Aux access, PSR needs to be disabled for AUX\n       call.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pAuxAccessArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_OPERATION_TYPE - \"Invalid operation type\"\n     - ::CTL_RESULT_ERROR_INVALID_SIZE - \"Invalid AUX data size\"\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS - \"Insufficient permissions\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_INVALID_AUX_ACCESS_FLAG - \"Invalid flag for AUX access\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernal mode driver call failure\""]
    pub unsafe fn ctlAUXAccess(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pAuxAccessArgs: *mut ctl_aux_access_args_t,
    ) -> ctl_result_t {
        (self.ctlAUXAccess)(hDisplayOutput, pAuxAccessArgs)
    }
    #[doc = "\n @brief Get Power optimization features\n\n @details\n     - Returns power optimization capabilities\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pPowerOptimizationCaps`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlGetPowerOptimizationCaps(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pPowerOptimizationCaps: *mut ctl_power_optimization_caps_t,
    ) -> ctl_result_t {
        (self.ctlGetPowerOptimizationCaps)(hDisplayOutput, pPowerOptimizationCaps)
    }
    #[doc = "\n @brief Get Power optimization setting\n\n @details\n     - Returns power optimization setting for a specific feature\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pPowerOptimizationSettings`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_POWERFEATURE_OPTIMIZATION_FLAG - \"Unsupported PowerOptimizationFeature\"\n     - ::CTL_RESULT_ERROR_INVALID_POWERSOURCE_TYPE_FOR_DPST - \"DPST is supported only in DC Mode\""]
    pub unsafe fn ctlGetPowerOptimizationSetting(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pPowerOptimizationSettings: *mut ctl_power_optimization_settings_t,
    ) -> ctl_result_t {
        (self.ctlGetPowerOptimizationSetting)(hDisplayOutput, pPowerOptimizationSettings)
    }
    #[doc = "\n @brief Set Power optimization setting\n\n @details\n     - Set power optimization setting for a specific feature\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pPowerOptimizationSettings`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_POWERFEATURE_OPTIMIZATION_FLAG - \"Unsupported PowerOptimizationFeature\"\n     - ::CTL_RESULT_ERROR_INVALID_POWERSOURCE_TYPE_FOR_DPST - \"DPST is supported only in DC Mode\"\n     - ::CTL_RESULT_ERROR_SET_FBC_FEATURE_NOT_SUPPORTED - \"Set FBC Feature not supported\""]
    pub unsafe fn ctlSetPowerOptimizationSetting(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pPowerOptimizationSettings: *mut ctl_power_optimization_settings_t,
    ) -> ctl_result_t {
        (self.ctlSetPowerOptimizationSetting)(hDisplayOutput, pPowerOptimizationSettings)
    }
    #[doc = "\n @brief Set Brightness on companion display\n\n @details\n     - Set Brightness for a target display. Currently support is only for\n       companion display.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pSetBrightnessSetting`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_ARGUMENT - \"Invalid Brightness data passed as argument\"\n     - ::CTL_RESULT_ERROR_DISPLAY_NOT_ACTIVE - \"Display not active\"\n     - ::CTL_RESULT_ERROR_INVALID_OPERATION_TYPE - \"Currently Brightness API is supported only on companion display\""]
    pub unsafe fn ctlSetBrightnessSetting(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pSetBrightnessSetting: *mut ctl_set_brightness_t,
    ) -> ctl_result_t {
        (self.ctlSetBrightnessSetting)(hDisplayOutput, pSetBrightnessSetting)
    }
    #[doc = "\n @brief Get Brightness setting\n\n @details\n     - Get Brightness for a target display. Currently support is only for\n       companion display.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pGetBrightnessSetting`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_DISPLAY_NOT_ACTIVE - \"Display not active\"\n     - ::CTL_RESULT_ERROR_INVALID_OPERATION_TYPE - \"Currently Brightness API is supported only on companion display\""]
    pub unsafe fn ctlGetBrightnessSetting(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pGetBrightnessSetting: *mut ctl_get_brightness_t,
    ) -> ctl_result_t {
        (self.ctlGetBrightnessSetting)(hDisplayOutput, pGetBrightnessSetting)
    }
    #[doc = "\n @brief Pixel transformation get pipe configuration\n\n @details\n     - The application does pixel transformation get pipe configuration\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pPixTxGetConfigArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS - \"Insufficient permissions\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernal mode driver call failure\"\n     - ::CTL_RESULT_ERROR_INVALID_PIXTX_GET_CONFIG_QUERY_TYPE - \"Invalid query type\"\n     - ::CTL_RESULT_ERROR_INVALID_PIXTX_BLOCK_ID - \"Invalid block id\"\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PIXTX_BLOCK_CONFIG_MEMORY - \"Insufficient memery allocated for BlockConfigs\"\n     - ::CTL_RESULT_ERROR_3DLUT_INVALID_PIPE - \"Invalid pipe for 3dlut\"\n     - ::CTL_RESULT_ERROR_3DLUT_INVALID_DATA - \"Invalid 3dlut data\"\n     - ::CTL_RESULT_ERROR_3DLUT_NOT_SUPPORTED_IN_HDR - \"3dlut not supported in HDR\"\n     - ::CTL_RESULT_ERROR_3DLUT_INVALID_OPERATION - \"Invalid 3dlut operation\"\n     - ::CTL_RESULT_ERROR_3DLUT_UNSUCCESSFUL - \"3dlut call unsuccessful\""]
    pub unsafe fn ctlPixelTransformationGetConfig(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pPixTxGetConfigArgs: *mut ctl_pixtx_pipe_get_config_t,
    ) -> ctl_result_t {
        (self.ctlPixelTransformationGetConfig)(hDisplayOutput, pPixTxGetConfigArgs)
    }
    #[doc = "\n @brief Pixel transformation set pipe configuration\n\n @details\n     - The application does pixel transformation set pipe configuration\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pPixTxSetConfigArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS - \"Insufficient permissions\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernal mode driver call failure\"\n     - ::CTL_RESULT_ERROR_INVALID_PIXTX_SET_CONFIG_OPERATION_TYPE - \"Invalid operation type\"\n     - ::CTL_RESULT_ERROR_INVALID_SET_CONFIG_NUMBER_OF_SAMPLES - \"Invalid number of samples\"\n     - ::CTL_RESULT_ERROR_INVALID_PIXTX_BLOCK_ID - \"Invalid block id\"\n     - ::CTL_RESULT_ERROR_PERSISTANCE_NOT_SUPPORTED - \"Persistance not supported\"\n     - ::CTL_RESULT_ERROR_3DLUT_INVALID_PIPE - \"Invalid pipe for 3dlut\"\n     - ::CTL_RESULT_ERROR_3DLUT_INVALID_DATA - \"Invalid 3dlut data\"\n     - ::CTL_RESULT_ERROR_3DLUT_NOT_SUPPORTED_IN_HDR - \"3dlut not supported in HDR\"\n     - ::CTL_RESULT_ERROR_3DLUT_INVALID_OPERATION - \"Invalid 3dlut operation\"\n     - ::CTL_RESULT_ERROR_3DLUT_UNSUCCESSFUL - \"3dlut call unsuccessful\""]
    pub unsafe fn ctlPixelTransformationSetConfig(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pPixTxSetConfigArgs: *mut ctl_pixtx_pipe_set_config_t,
    ) -> ctl_result_t {
        (self.ctlPixelTransformationSetConfig)(hDisplayOutput, pPixTxSetConfigArgs)
    }
    #[doc = "\n @brief Panel Descriptor Access\n\n @details\n     - The application does EDID or Display ID access\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pPanelDescriptorAccessArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_OPERATION_TYPE - \"Invalid operation type\"\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS - \"Insufficient permissions\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernal mode driver call failure\""]
    pub unsafe fn ctlPanelDescriptorAccess(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pPanelDescriptorAccessArgs: *mut ctl_panel_descriptor_access_args_t,
    ) -> ctl_result_t {
        (self.ctlPanelDescriptorAccess)(hDisplayOutput, pPanelDescriptorAccessArgs)
    }
    #[doc = "\n @brief Get Supported Retro Scaling Types\n\n @details\n     - Returns supported retro scaling capabilities\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pRetroScalingCaps`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlGetSupportedRetroScalingCapability(
        &self,
        hDAhandle: ctl_device_adapter_handle_t,
        pRetroScalingCaps: *mut ctl_retro_scaling_caps_t,
    ) -> ctl_result_t {
        (self.ctlGetSupportedRetroScalingCapability)(hDAhandle, pRetroScalingCaps)
    }
    #[doc = "\n @brief Get/Set Retro Scaling\n\n @details\n     - Get or Set the status of retro scaling.This Api will do a physical\n       modeset resulting in flash on the screen\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pGetSetRetroScalingType`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlGetSetRetroScaling(
        &self,
        hDAhandle: ctl_device_adapter_handle_t,
        pGetSetRetroScalingType: *mut ctl_retro_scaling_settings_t,
    ) -> ctl_result_t {
        (self.ctlGetSetRetroScaling)(hDAhandle, pGetSetRetroScalingType)
    }
    #[doc = "\n @brief Get Supported Scaling Types\n\n @details\n     - Returns supported scaling capabilities\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pScalingCaps`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlGetSupportedScalingCapability(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pScalingCaps: *mut ctl_scaling_caps_t,
    ) -> ctl_result_t {
        (self.ctlGetSupportedScalingCapability)(hDisplayOutput, pScalingCaps)
    }
    #[doc = "\n @brief Get Current Scaling\n\n @details\n     - Returns current active scaling\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pGetCurrentScalingType`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlGetCurrentScaling(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pGetCurrentScalingType: *mut ctl_scaling_settings_t,
    ) -> ctl_result_t {
        (self.ctlGetCurrentScaling)(hDisplayOutput, pGetCurrentScalingType)
    }
    #[doc = "\n @brief Set Scaling Type\n\n @details\n     - Returns current active scaling\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pSetScalingType`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlSetCurrentScaling(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pSetScalingType: *mut ctl_scaling_settings_t,
    ) -> ctl_result_t {
        (self.ctlSetCurrentScaling)(hDisplayOutput, pSetScalingType)
    }
    #[doc = "\n @brief Get LACE Config\n\n @details\n     - Returns current LACE Config\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pLaceConfig`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_LACE_INVALID_DATA_ARGUMENT_PASSED - \"Lace Incorrrect AggressivePercent data or LuxVsAggressive Map data passed by user\""]
    pub unsafe fn ctlGetLACEConfig(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pLaceConfig: *mut ctl_lace_config_t,
    ) -> ctl_result_t {
        (self.ctlGetLACEConfig)(hDisplayOutput, pLaceConfig)
    }
    #[doc = "\n @brief Sets LACE Config\n\n @details\n     - Sets LACE Config\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pLaceConfig`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_LACE_INVALID_DATA_ARGUMENT_PASSED - \"Lace Incorrrect AggressivePercent data or LuxVsAggressive Map data passed by user\""]
    pub unsafe fn ctlSetLACEConfig(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pLaceConfig: *mut ctl_lace_config_t,
    ) -> ctl_result_t {
        (self.ctlSetLACEConfig)(hDisplayOutput, pLaceConfig)
    }
    #[doc = "\n @brief Get Software PSR caps/Set software PSR State\n\n @details\n     - Returns Software PSR status or Sets Software PSR capabilities. This is\n       a reserved capability. By default, software PSR is not supported/will\n       not be enabled, need application to activate it, please contact Intel\n       for activation.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pSoftwarePsrSetting`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlSoftwarePSR(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pSoftwarePsrSetting: *mut ctl_sw_psr_settings_t,
    ) -> ctl_result_t {
        (self.ctlSoftwarePSR)(hDisplayOutput, pSoftwarePsrSetting)
    }
    #[doc = "\n @brief Get Intel Arc Sync information for monitor\n\n @details\n     - Returns Intel Arc Sync information for selected monitor\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pIntelArcSyncMonitorParams`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlGetIntelArcSyncInfoForMonitor(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pIntelArcSyncMonitorParams: *mut ctl_intel_arc_sync_monitor_params_t,
    ) -> ctl_result_t {
        (self.ctlGetIntelArcSyncInfoForMonitor)(hDisplayOutput, pIntelArcSyncMonitorParams)
    }
    #[doc = "\n @brief Enumerate Display MUX Devices on this system across adapters\n\n @details\n     - The application enumerates all MUX devices in the system\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hAPIHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCount`\n         + `nullptr == phMuxDevices`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlEnumerateMuxDevices(
        &self,
        hAPIHandle: ctl_api_handle_t,
        pCount: *mut u32,
        phMuxDevices: *mut ctl_mux_output_handle_t,
    ) -> ctl_result_t {
        (self.ctlEnumerateMuxDevices)(hAPIHandle, pCount, phMuxDevices)
    }
    #[doc = "\n @brief Get Display Mux properties\n\n @details\n     - Get the propeties of the Mux device\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hMuxDevice`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pMuxProperties`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlGetMuxProperties(
        &self,
        hMuxDevice: ctl_mux_output_handle_t,
        pMuxProperties: *mut ctl_mux_properties_t,
    ) -> ctl_result_t {
        (self.ctlGetMuxProperties)(hMuxDevice, pMuxProperties)
    }
    #[doc = "\n @brief Switch Mux output\n\n @details\n     - Switches the MUX output\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hMuxDevice`\n         + `nullptr == hInactiveDisplayOutput`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlSwitchMux(
        &self,
        hMuxDevice: ctl_mux_output_handle_t,
        hInactiveDisplayOutput: ctl_display_output_handle_t,
    ) -> ctl_result_t {
        (self.ctlSwitchMux)(hMuxDevice, hInactiveDisplayOutput)
    }
    #[doc = "\n @brief Get Intel Arc Sync profile\n\n @details\n     - Returns Intel Arc Sync profile for selected monitor\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pIntelArcSyncProfileParams`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlGetIntelArcSyncProfile(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pIntelArcSyncProfileParams: *mut ctl_intel_arc_sync_profile_params_t,
    ) -> ctl_result_t {
        (self.ctlGetIntelArcSyncProfile)(hDisplayOutput, pIntelArcSyncProfileParams)
    }
    #[doc = "\n @brief Set Intel Arc Sync profile\n\n @details\n     - Sets Intel Arc Sync profile for selected monitor. In a mux situation,\n       this API should be called for all display IDs associated with a\n       physical display.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pIntelArcSyncProfileParams`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlSetIntelArcSyncProfile(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pIntelArcSyncProfileParams: *mut ctl_intel_arc_sync_profile_params_t,
    ) -> ctl_result_t {
        (self.ctlSetIntelArcSyncProfile)(hDisplayOutput, pIntelArcSyncProfileParams)
    }
    #[doc = "\n @brief EDID Management allows managing an output's EDID or Plugged Status.\n\n @details\n     - To manage output's EDID or Display ID. Supports native DP SST and HDMI\n       Display types.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pEdidManagementArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_OPERATION_TYPE - \"Invalid operation type\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernal mode driver call failure\"\n     - ::CTL_RESULT_ERROR_INVALID_ARGUMENT - \"Invalid combination of parameters\"\n     - ::CTL_RESULT_ERROR_DISPLAY_NOT_ATTACHED - \"Error for Output Device not attached\"\n     - ::CTL_RESULT_ERROR_OUT_OF_DEVICE_MEMORY - \"Insufficient device memory to satisfy call\"\n     - ::CTL_RESULT_ERROR_DATA_NOT_FOUND - \"Requested EDID data not present.\""]
    pub unsafe fn ctlEdidManagement(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pEdidManagementArgs: *mut ctl_edid_management_args_t,
    ) -> ctl_result_t {
        (self.ctlEdidManagement)(hDisplayOutput, pEdidManagementArgs)
    }
    #[doc = "\n @brief Get/Set Custom mode.\n\n @details\n     - To get or set custom mode.\n     - Add custom source mode operation supports only single mode additon at\n       a time.\n     - Remove custom source mode operation supports single or multiple mode\n       removal at a time.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCustomModeArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_OPERATION_TYPE - \"Invalid operation type\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernal mode driver call failure\"\n     - ::CTL_RESULT_ERROR_INVALID_ARGUMENT - \"Invalid combination of parameters\"\n     - ::CTL_RESULT_ERROR_CUSTOM_MODE_STANDARD_CUSTOM_MODE_EXISTS - \"Standard custom mode exists\"\n     - ::CTL_RESULT_ERROR_CUSTOM_MODE_NON_CUSTOM_MATCHING_MODE_EXISTS - \"Non custom matching mode exists\"\n     - ::CTL_RESULT_ERROR_CUSTOM_MODE_INSUFFICIENT_MEMORY - \"Custom mode insufficent memory\""]
    pub unsafe fn ctlGetSetCustomMode(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pCustomModeArgs: *mut ctl_get_set_custom_mode_args_t,
    ) -> ctl_result_t {
        (self.ctlGetSetCustomMode)(hDisplayOutput, pCustomModeArgs)
    }
    #[doc = "\n @brief Get/Set Combined Display\n\n @details\n     - To get or set combined display with given Child Targets on a Single\n       GPU or across identical GPUs. Multi-GPU(MGPU) combined display is\n       reserved i.e. it is not public and requires special application GUID.\n       MGPU Combined Display will get activated or deactivated in next boot.\n       MGPU scenario will internally link the associated adapters via Linked\n       Display Adapter Call, with supplied hDeviceAdapter being the LDA\n       Primary. If Genlock and enabled in Driver registry and supported by\n       given Display Config, MGPU Combined Display will enable MGPU Genlock\n       with supplied hDeviceAdapter being the Genlock Primary Adapter and the\n       First Child Display being the Primary Display.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceAdapter`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCombinedDisplayArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_OPERATION_TYPE - \"Invalid operation type\"\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS - \"Insufficient permissions\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernel mode driver call failure\"\n     - ::CTL_RESULT_ERROR_FEATURE_NOT_SUPPORTED - \"Combined Display feature is not supported in this platform\"\n     - ::CTL_RESULT_ERROR_ADAPTER_NOT_SUPPORTED_ON_LDA_SECONDARY - \"Unsupported (secondary) adapter handle passed\""]
    pub unsafe fn ctlGetSetCombinedDisplay(
        &self,
        hDeviceAdapter: ctl_device_adapter_handle_t,
        pCombinedDisplayArgs: *mut ctl_combined_display_args_t,
    ) -> ctl_result_t {
        (self.ctlGetSetCombinedDisplay)(hDeviceAdapter, pCombinedDisplayArgs)
    }
    #[doc = "\n @brief Get/Set Display Genlock\n\n @details\n     - To get or set Display Genlock.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == hDeviceAdapter`\n         + `nullptr == pGenlockArgs`\n         + `nullptr == hFailureDeviceAdapter`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_INVALID_SIZE - \"Invalid topology structure size\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernel mode driver call failure\""]
    pub unsafe fn ctlGetSetDisplayGenlock(
        &self,
        hDeviceAdapter: *mut ctl_device_adapter_handle_t,
        pGenlockArgs: *mut ctl_genlock_args_t,
        AdapterCount: u32,
        hFailureDeviceAdapter: *mut ctl_device_adapter_handle_t,
    ) -> ctl_result_t {
        (self.ctlGetSetDisplayGenlock)(
            hDeviceAdapter,
            pGenlockArgs,
            AdapterCount,
            hFailureDeviceAdapter,
        )
    }
    #[doc = "\n @brief Get Vblank Timestamp\n\n @details\n     - To get a list of vblank timestamps in microseconds for each child\n       target of a display.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pVblankTSArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS - \"Insufficient permissions\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernel mode driver call failure\""]
    pub unsafe fn ctlGetVblankTimestamp(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pVblankTSArgs: *mut ctl_vblank_ts_args_t,
    ) -> ctl_result_t {
        (self.ctlGetVblankTimestamp)(hDisplayOutput, pVblankTSArgs)
    }
    #[doc = "\n @brief Link Display Adapters\n\n @details\n     - To Link Display Adapters.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hPrimaryAdapter`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pLdaArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernel mode driver call failure\"\n     - ::CTL_RESULT_ERROR_ADAPTER_ALREADY_LINKED - \"Adapter is already linked\""]
    pub unsafe fn ctlLinkDisplayAdapters(
        &self,
        hPrimaryAdapter: ctl_device_adapter_handle_t,
        pLdaArgs: *mut ctl_lda_args_t,
    ) -> ctl_result_t {
        (self.ctlLinkDisplayAdapters)(hPrimaryAdapter, pLdaArgs)
    }
    #[doc = "\n @brief Unlink Display Adapters\n\n @details\n     - To Unlink Display Adapters\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hPrimaryAdapter`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernel mode driver call failure\"\n     - ::CTL_RESULT_ERROR_ADAPTER_NOT_SUPPORTED_ON_LDA_SECONDARY - \"Unsupported (secondary) adapter handle passed\""]
    pub unsafe fn ctlUnlinkDisplayAdapters(
        &self,
        hPrimaryAdapter: ctl_device_adapter_handle_t,
    ) -> ctl_result_t {
        (self.ctlUnlinkDisplayAdapters)(hPrimaryAdapter)
    }
    #[doc = "\n @brief Get Linked Display Adapters\n\n @details\n     - To return list of Linked Display Adapters.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hPrimaryAdapter`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pLdaArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernel mode driver call failure\"\n     - ::CTL_RESULT_ERROR_ADAPTER_NOT_SUPPORTED_ON_LDA_SECONDARY - \"Unsupported (secondary) adapter handle passed\""]
    pub unsafe fn ctlGetLinkedDisplayAdapters(
        &self,
        hPrimaryAdapter: ctl_device_adapter_handle_t,
        pLdaArgs: *mut ctl_lda_args_t,
    ) -> ctl_result_t {
        (self.ctlGetLinkedDisplayAdapters)(hPrimaryAdapter, pLdaArgs)
    }
    #[doc = "\n @brief Get/Set Dynamic Contrast Enhancement\n\n @details\n     - To get the DCE feature status and, if feature is enabled, returns the\n       current histogram, or to set the brightness at the phase-in speed\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pDceArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernel mode driver call failure\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_HANDLE - \"Invalid or Null handle passed\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_INVALID_OPERATION_TYPE - \"Invalid operation type\"\n     - ::CTL_RESULT_ERROR_INVALID_ARGUMENT - \"Invalid combination of parameters\""]
    pub unsafe fn ctlGetSetDynamicContrastEnhancement(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pDceArgs: *mut ctl_dce_args_t,
    ) -> ctl_result_t {
        (self.ctlGetSetDynamicContrastEnhancement)(hDisplayOutput, pDceArgs)
    }
    #[doc = "\n @brief Get/Set Color Format and Color Depth\n\n @details\n     - Get and Set the Color Format and Color Depth of a target\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pGetSetWireFormatSetting`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_ARGUMENT - \"Invalid data passed as argument, WireFormat is not supported\"\n     - ::CTL_RESULT_ERROR_DISPLAY_NOT_ACTIVE - \"Display not active\"\n     - ::CTL_RESULT_ERROR_INVALID_OPERATION_TYPE - \"Invalid operation type\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\""]
    pub unsafe fn ctlGetSetWireFormat(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pGetSetWireFormatSetting: *mut ctl_get_set_wire_format_config_t,
    ) -> ctl_result_t {
        (self.ctlGetSetWireFormat)(hDisplayOutput, pGetSetWireFormatSetting)
    }
    #[doc = "\n @brief Get/Set Display settings\n\n @details\n     - To get/set end display settings like low latency, HDR10+ signaling\n       etc. which are controlled via info-frames/secondary data packets\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pDisplaySettings`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernel mode driver call failure\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_HANDLE - \"Invalid or Null handle passed\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_INVALID_OPERATION_TYPE - \"Invalid operation type\"\n     - ::CTL_RESULT_ERROR_INVALID_ARGUMENT - \"Invalid combination of parameters\""]
    pub unsafe fn ctlGetSetDisplaySettings(
        &self,
        hDisplayOutput: ctl_display_output_handle_t,
        pDisplaySettings: *mut ctl_display_settings_t,
    ) -> ctl_result_t {
        (self.ctlGetSetDisplaySettings)(hDisplayOutput, pDisplaySettings)
    }
    #[doc = "\n @brief Get handle of engine groups\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCount`"]
    pub unsafe fn ctlEnumEngineGroups(
        &self,
        hDAhandle: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phEngine: *mut ctl_engine_handle_t,
    ) -> ctl_result_t {
        (self.ctlEnumEngineGroups)(hDAhandle, pCount, phEngine)
    }
    #[doc = "\n @brief Get engine group properties\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hEngine`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pProperties`"]
    pub unsafe fn ctlEngineGetProperties(
        &self,
        hEngine: ctl_engine_handle_t,
        pProperties: *mut ctl_engine_properties_t,
    ) -> ctl_result_t {
        (self.ctlEngineGetProperties)(hEngine, pProperties)
    }
    #[doc = "\n @brief Get the activity stats for an engine group\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hEngine`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pStats`"]
    pub unsafe fn ctlEngineGetActivity(
        &self,
        hEngine: ctl_engine_handle_t,
        pStats: *mut ctl_engine_stats_t,
    ) -> ctl_result_t {
        (self.ctlEngineGetActivity)(hEngine, pStats)
    }
    #[doc = "\n @brief Get handle of fans\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCount`"]
    pub unsafe fn ctlEnumFans(
        &self,
        hDAhandle: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phFan: *mut ctl_fan_handle_t,
    ) -> ctl_result_t {
        (self.ctlEnumFans)(hDAhandle, pCount, phFan)
    }
    #[doc = "\n @brief Get fan properties\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFan`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pProperties`"]
    pub unsafe fn ctlFanGetProperties(
        &self,
        hFan: ctl_fan_handle_t,
        pProperties: *mut ctl_fan_properties_t,
    ) -> ctl_result_t {
        (self.ctlFanGetProperties)(hFan, pProperties)
    }
    #[doc = "\n @brief Get fan configurations and the current fan speed mode (default, fixed,\n        temp-speed table)\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFan`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pConfig`"]
    pub unsafe fn ctlFanGetConfig(
        &self,
        hFan: ctl_fan_handle_t,
        pConfig: *mut ctl_fan_config_t,
    ) -> ctl_result_t {
        (self.ctlFanGetConfig)(hFan, pConfig)
    }
    #[doc = "\n @brief Configure the fan to run with hardware factory settings (set mode to\n        ::CTL_FAN_SPEED_MODE_DEFAULT)\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFan`\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS\n         + User does not have permissions to make these modifications."]
    pub unsafe fn ctlFanSetDefaultMode(&self, hFan: ctl_fan_handle_t) -> ctl_result_t {
        (self.ctlFanSetDefaultMode)(hFan)
    }
    #[doc = "\n @brief Configure the fan to rotate at a fixed speed (set mode to\n        ::CTL_FAN_SPEED_MODE_FIXED)\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFan`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == speed`\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS\n         + User does not have permissions to make these modifications.\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_FEATURE\n         + Fixing the fan speed not supported by the hardware or the fan speed units are not supported. See ::ctl_fan_properties_t.supportedModes and ::ctl_fan_properties_t.supportedUnits."]
    pub unsafe fn ctlFanSetFixedSpeedMode(
        &self,
        hFan: ctl_fan_handle_t,
        speed: *const ctl_fan_speed_t,
    ) -> ctl_result_t {
        (self.ctlFanSetFixedSpeedMode)(hFan, speed)
    }
    #[doc = "\n @brief Configure the fan to adjust speed based on a temperature/speed table\n        (set mode to ::CTL_FAN_SPEED_MODE_TABLE)\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFan`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == speedTable`\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS\n         + User does not have permissions to make these modifications.\n     - ::CTL_RESULT_ERROR_INVALID_ARGUMENT\n         + The temperature/speed pairs in the array are not sorted on temperature from lowest to highest.\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_FEATURE\n         + Fan speed table not supported by the hardware or the fan speed units are not supported. See ::ctl_fan_properties_t.supportedModes and ::ctl_fan_properties_t.supportedUnits."]
    pub unsafe fn ctlFanSetSpeedTableMode(
        &self,
        hFan: ctl_fan_handle_t,
        speedTable: *const ctl_fan_speed_table_t,
    ) -> ctl_result_t {
        (self.ctlFanSetSpeedTableMode)(hFan, speedTable)
    }
    #[doc = "\n @brief Get current state of a fan - current mode and speed\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFan`\n     - CTL_RESULT_ERROR_INVALID_ENUMERATION\n         + `::CTL_FAN_SPEED_UNITS_PERCENT < units`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pSpeed`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_FEATURE\n         + The requested fan speed units are not supported. See ::ctl_fan_properties_t.supportedUnits."]
    pub unsafe fn ctlFanGetState(
        &self,
        hFan: ctl_fan_handle_t,
        units: ctl_fan_speed_units_t,
        pSpeed: *mut i32,
    ) -> ctl_result_t {
        (self.ctlFanGetState)(hFan, units, pSpeed)
    }
    #[doc = "\n @brief Get handle of frequency domains\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCount`"]
    pub unsafe fn ctlEnumFrequencyDomains(
        &self,
        hDAhandle: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phFrequency: *mut ctl_freq_handle_t,
    ) -> ctl_result_t {
        (self.ctlEnumFrequencyDomains)(hDAhandle, pCount, phFrequency)
    }
    #[doc = "\n @brief Get frequency properties - available frequencies\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFrequency`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pProperties`"]
    pub unsafe fn ctlFrequencyGetProperties(
        &self,
        hFrequency: ctl_freq_handle_t,
        pProperties: *mut ctl_freq_properties_t,
    ) -> ctl_result_t {
        (self.ctlFrequencyGetProperties)(hFrequency, pProperties)
    }
    #[doc = "\n @brief Get available non-overclocked hardware clock frequencies for the\n        frequency domain\n\n @details\n     - The list of available frequencies is returned in order of slowest to\n       fastest.\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFrequency`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCount`"]
    pub unsafe fn ctlFrequencyGetAvailableClocks(
        &self,
        hFrequency: ctl_freq_handle_t,
        pCount: *mut u32,
        phFrequency: *mut f64,
    ) -> ctl_result_t {
        (self.ctlFrequencyGetAvailableClocks)(hFrequency, pCount, phFrequency)
    }
    #[doc = "\n @brief Get current frequency limits\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFrequency`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pLimits`"]
    pub unsafe fn ctlFrequencyGetRange(
        &self,
        hFrequency: ctl_freq_handle_t,
        pLimits: *mut ctl_freq_range_t,
    ) -> ctl_result_t {
        (self.ctlFrequencyGetRange)(hFrequency, pLimits)
    }
    #[doc = "\n @brief Set frequency range between which the hardware can operate.\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFrequency`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pLimits`\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS\n         + User does not have permissions to make these modifications."]
    pub unsafe fn ctlFrequencySetRange(
        &self,
        hFrequency: ctl_freq_handle_t,
        pLimits: *const ctl_freq_range_t,
    ) -> ctl_result_t {
        (self.ctlFrequencySetRange)(hFrequency, pLimits)
    }
    #[doc = "\n @brief Get current frequency state - frequency request, actual frequency, TDP\n        limits\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFrequency`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pState`"]
    pub unsafe fn ctlFrequencyGetState(
        &self,
        hFrequency: ctl_freq_handle_t,
        pState: *mut ctl_freq_state_t,
    ) -> ctl_result_t {
        (self.ctlFrequencyGetState)(hFrequency, pState)
    }
    #[doc = "\n @brief Get frequency throttle time\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFrequency`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pThrottleTime`"]
    pub unsafe fn ctlFrequencyGetThrottleTime(
        &self,
        hFrequency: ctl_freq_handle_t,
        pThrottleTime: *mut ctl_freq_throttle_time_t,
    ) -> ctl_result_t {
        (self.ctlFrequencyGetThrottleTime)(hFrequency, pThrottleTime)
    }
    #[doc = "\n @brief Get Video Processing capabilities\n\n @details\n     - The application gets Video Processing properties\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pFeatureCaps`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlGetSupportedVideoProcessingCapabilities(
        &self,
        hDAhandle: ctl_device_adapter_handle_t,
        pFeatureCaps: *mut ctl_video_processing_feature_caps_t,
    ) -> ctl_result_t {
        (self.ctlGetSupportedVideoProcessingCapabilities)(hDAhandle, pFeatureCaps)
    }
    #[doc = "\n @brief Get/Set Video Processing feature details\n\n @details\n     - Video Processing feature details\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pFeature`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub unsafe fn ctlGetSetVideoProcessingFeature(
        &self,
        hDAhandle: ctl_device_adapter_handle_t,
        pFeature: *mut ctl_video_processing_feature_getset_t,
    ) -> ctl_result_t {
        (self.ctlGetSetVideoProcessingFeature)(hDAhandle, pFeature)
    }
    #[doc = "\n @brief Get handle of memory modules\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCount`"]
    pub unsafe fn ctlEnumMemoryModules(
        &self,
        hDAhandle: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phMemory: *mut ctl_mem_handle_t,
    ) -> ctl_result_t {
        (self.ctlEnumMemoryModules)(hDAhandle, pCount, phMemory)
    }
    #[doc = "\n @brief Get memory properties\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hMemory`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pProperties`"]
    pub unsafe fn ctlMemoryGetProperties(
        &self,
        hMemory: ctl_mem_handle_t,
        pProperties: *mut ctl_mem_properties_t,
    ) -> ctl_result_t {
        (self.ctlMemoryGetProperties)(hMemory, pProperties)
    }
    #[doc = "\n @brief Get memory state - health, allocated\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hMemory`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pState`"]
    pub unsafe fn ctlMemoryGetState(
        &self,
        hMemory: ctl_mem_handle_t,
        pState: *mut ctl_mem_state_t,
    ) -> ctl_result_t {
        (self.ctlMemoryGetState)(hMemory, pState)
    }
    #[doc = "\n @brief Get memory bandwidth\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hMemory`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pBandwidth`\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS\n         + User does not have permissions to query this telemetry."]
    pub unsafe fn ctlMemoryGetBandwidth(
        &self,
        hMemory: ctl_mem_handle_t,
        pBandwidth: *mut ctl_mem_bandwidth_t,
    ) -> ctl_result_t {
        (self.ctlMemoryGetBandwidth)(hMemory, pBandwidth)
    }
    #[doc = "\n @brief Get overclock properties - available properties.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pOcProperties`"]
    pub unsafe fn ctlOverclockGetProperties(
        &self,
        hDeviceHandle: ctl_device_adapter_handle_t,
        pOcProperties: *mut ctl_oc_properties_t,
    ) -> ctl_result_t {
        (self.ctlOverclockGetProperties)(hDeviceHandle, pOcProperties)
    }
    #[doc = "\n @brief Overclock Waiver - Warranty Waiver.\n\n @details\n     - Most of the overclock functions will return an error if the waiver is\n       not set. This is because most overclock settings will increase the\n       electric/thermal stress on the part and thus reduce its lifetime.\n     - By setting the waiver, the user is indicate that they are accepting a\n       reduction in the lifetime of the part.\n     - It is the responsibility of overclock applications to notify each user\n       at least once with a popup of the dangers and requiring acceptance.\n     - Only once the user has accepted should this function be called by the\n       application.\n     - It is acceptable for the application to cache the user choice and call\n       this function on future executions without issuing the popup.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`"]
    pub unsafe fn ctlOverclockWaiverSet(
        &self,
        hDeviceHandle: ctl_device_adapter_handle_t,
    ) -> ctl_result_t {
        (self.ctlOverclockWaiverSet)(hDeviceHandle)
    }
    #[doc = "\n @brief Get the Overclock Frequency Offset for the GPU in MHz.\n\n @details\n     - Determine the current frequency offset in effect (refer to\n       ::ctlOverclockGpuFrequencyOffsetSet() for details).\n     - The value returned may be different from the value that was previously\n       set by the application depending on hardware limitations or if the\n       function ::ctlOverclockGpuFrequencyOffsetSet() has been called or\n       another application that has changed the value.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pOcFrequencyOffset`"]
    pub unsafe fn ctlOverclockGpuFrequencyOffsetGet(
        &self,
        hDeviceHandle: ctl_device_adapter_handle_t,
        pOcFrequencyOffset: *mut f64,
    ) -> ctl_result_t {
        (self.ctlOverclockGpuFrequencyOffsetGet)(hDeviceHandle, pOcFrequencyOffset)
    }
    #[doc = "\n @brief Set the Overclock Frequency Offset for the GPU in MHZ.\n\n @details\n     - The purpose of this function is to increase/decrease the frequency at\n       which typical workloads will run within the same thermal budget.\n     - The frequency offset is expressed in units of 1MHz.\n     - The actual operating frequency for each workload is not guaranteed to\n       change exactly by the specified offset.\n     - For positive frequency offsets, the factory maximum frequency may\n       increase by up to the specified amount.\n     - For negative frequency offsets, the overclock waiver must have been\n       set since this can result in running the part at voltages beyond the\n       part warrantee limits. An error is returned if the waiver has not been\n       set.\n     - Specifying large values for the frequency offset can lead to\n       instability. It is recommended that changes are made in small\n       increments and stability/performance measured running intense GPU\n       workloads before increasing further.\n     - This setting is not persistent through system reboots or driver\n       resets/hangs. It is up to the overclock application to reapply the\n       settings in those cases.\n     - This setting can cause system/device instability. It is up to the\n       overclock application to detect if the system has rebooted\n       unexpectedly or the device was restarted. When this occurs, the\n       application should not reapply the overclock settings automatically\n       but instead return to previously known good settings or notify the\n       user that the settings are not being applied.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`"]
    pub unsafe fn ctlOverclockGpuFrequencyOffsetSet(
        &self,
        hDeviceHandle: ctl_device_adapter_handle_t,
        ocFrequencyOffset: f64,
    ) -> ctl_result_t {
        (self.ctlOverclockGpuFrequencyOffsetSet)(hDeviceHandle, ocFrequencyOffset)
    }
    #[doc = "\n @brief Get the Overclock Gpu Voltage Offset in mV.\n\n @details\n     - Determine the current voltage offset in effect on the hardware (refer\n       to ::ctlOverclockGpuVoltageOffsetSet for details).\n     - The value returned may be different from the value that was previously\n       set by the application depending on hardware limitations or if the\n       function ::ctlOverclockGpuVoltageOffsetSet has been called or another\n       application that has changed the value.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pOcVoltageOffset`"]
    pub unsafe fn ctlOverclockGpuVoltageOffsetGet(
        &self,
        hDeviceHandle: ctl_device_adapter_handle_t,
        pOcVoltageOffset: *mut f64,
    ) -> ctl_result_t {
        (self.ctlOverclockGpuVoltageOffsetGet)(hDeviceHandle, pOcVoltageOffset)
    }
    #[doc = "\n @brief Set the Overclock Gpu Voltage Offset in mV.\n\n @details\n     - The purpose of this function is to attempt to run the GPU up to higher\n       voltages beyond the part warrantee limits. This can permit running at\n       even higher frequencies than can be obtained using the frequency\n       offset setting, but at the risk of reducing the lifetime of the part.\n     - The voltage offset is expressed in units of millivolts with values\n       permitted down to a resolution of 1 millivolt.\n     - The overclock waiver must be set before calling this function\n       otherwise and error will be returned.\n     - There is no guarantee that a workload can operate at the higher\n       frequencies permitted by this setting. Significantly more heat will be\n       generated at these high frequencies/voltages which will necessitate a\n       good cooling solution.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`"]
    pub unsafe fn ctlOverclockGpuVoltageOffsetSet(
        &self,
        hDeviceHandle: ctl_device_adapter_handle_t,
        ocVoltageOffset: f64,
    ) -> ctl_result_t {
        (self.ctlOverclockGpuVoltageOffsetSet)(hDeviceHandle, ocVoltageOffset)
    }
    #[doc = "\n @brief Gets the Locked GPU Voltage for Overclocking in mV.\n\n @details\n     - The purpose of this function is to determine if the current values of\n       the frequency/voltage lock.\n     - If the lock is not currently active, will return 0 for frequency and\n       voltage.\n     - Note that the operating frequency/voltage may be lower than these\n       settings if power/thermal limits are exceeded.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pVfPair`"]
    pub unsafe fn ctlOverclockGpuLockGet(
        &self,
        hDeviceHandle: ctl_device_adapter_handle_t,
        pVfPair: *mut ctl_oc_vf_pair_t,
    ) -> ctl_result_t {
        (self.ctlOverclockGpuLockGet)(hDeviceHandle, pVfPair)
    }
    #[doc = "\n @brief Locks the GPU voltage for Overclocking in mV.\n\n @details\n     - The purpose of this function is to provide an interface for scanners\n       to lock the frequency and voltage to fixed values.\n     - The frequency is expressed in units of MHz with a resolution of 1MHz.\n     - The voltage is expressed in units of millivolts with values\n       permitted down to a resolution of 1 millivolt.\n     - The overclock waiver must be set since fixing the voltage at a high\n       value puts unnecessary stress on the part.\n     - The actual frequency may reduce depending on power/thermal\n       limitations.\n     - Requesting a frequency and/or voltage of 0 will return the hardware to\n       dynamic frequency/voltage management with any previous frequency\n       offset or voltage offset settings reapplied.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`"]
    pub unsafe fn ctlOverclockGpuLockSet(
        &self,
        hDeviceHandle: ctl_device_adapter_handle_t,
        vFPair: ctl_oc_vf_pair_t,
    ) -> ctl_result_t {
        (self.ctlOverclockGpuLockSet)(hDeviceHandle, vFPair)
    }
    #[doc = "\n @brief Get the current Vram Frequency Offset in GT/s.\n\n @details\n     - The purpose of this function is to return the current VRAM frequency\n       offset in units of GT/s.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pOcFrequencyOffset`"]
    pub unsafe fn ctlOverclockVramFrequencyOffsetGet(
        &self,
        hDeviceHandle: ctl_device_adapter_handle_t,
        pOcFrequencyOffset: *mut f64,
    ) -> ctl_result_t {
        (self.ctlOverclockVramFrequencyOffsetGet)(hDeviceHandle, pOcFrequencyOffset)
    }
    #[doc = "\n @brief Set the desired Vram frquency Offset in GT/s\n\n @details\n     - The purpose of this function is to increase/decrease the frequency of\n       VRAM.\n     - The frequency offset is expressed in units of GT/s with a minimum step\n       size given by ::ctlOverclockGetProperties.\n     - The actual operating frequency for each workload is not guaranteed to\n       change exactly by the specified offset.\n     - The waiver must be set using clibOverclockWaiverSet() before this\n       function can be called.\n     - This setting is not persistent through system reboots or driver\n       resets/hangs. It is up to the overclock application to reapply the\n       settings in those cases.\n     - This setting can cause system/device instability. It is up to the\n       overclock application to detect if the system has rebooted\n       unexpectedly or the device was restarted. When this occurs, the\n       application should not reapply the overclock settings automatically\n       but instead return to previously known good settings or notify the\n       user that the settings are not being applied.\n     - If the memory controller doesn't support changes to frequency on the\n       fly, one of the following return codes will be given:\n     - ::CTL_RESULT_ERROR_RESET_DEVICE_REQUIRED: The requested memory\n       overclock will be applied when the device is reset or the system is\n       rebooted. In this case, the overclock software should check if the\n       overclock request was applied after the reset/reboot. If it was and\n       when the overclock application shuts down gracefully and if the\n       overclock application wants the setting to be persistent, the\n       application should request the same overclock settings again so that\n       they will be applied on the next reset/reboot. If this is not done,\n       then every time the device is reset and overclock is requested, the\n       device needs to be reset a second time.\n     - ::CTL_RESULT_ERROR_FULL_REBOOT_REQUIRED: The requested memory\n       overclock will be applied when the system is rebooted. In this case,\n       the overclock software should check if the overclock request was\n       applied after the reboot. If it was and when the overclock application\n       shuts down gracefully and if the overclock application wants the\n       setting to be persistent, the application should request the same\n       overclock settings again so that they will be applied on the next\n       reset/reboot. If this is not done and the overclock setting is\n       requested after the reboot has occurred, a second reboot will be\n       required.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`"]
    pub unsafe fn ctlOverclockVramFrequencyOffsetSet(
        &self,
        hDeviceHandle: ctl_device_adapter_handle_t,
        ocFrequencyOffset: f64,
    ) -> ctl_result_t {
        (self.ctlOverclockVramFrequencyOffsetSet)(hDeviceHandle, ocFrequencyOffset)
    }
    #[doc = "\n @brief Get the Overclock Vram Voltage Offset in mV.\n\n @details\n     - The purpose of this function is to increase/decrease the voltage of\n       VRAM.\n     - The voltage offset is expressed in units of millivolts with a minimum\n       step size given by ::ctlOverclockGetProperties.\n     - The waiver must be set using ::ctlOverclockWaiverSet before this\n       function can be called.\n     - This setting is not persistent through system reboots or driver\n       resets/hangs. It is up to the overclock application to reapply the\n       settings in those cases.\n     - This setting can cause system/device instability. It is up to the\n       overclock application to detect if the system has rebooted\n       unexpectedly or the device was restarted. When this occurs, the\n       application should not reapply the overclock settings automatically\n       but instead return to previously known good settings or notify the\n       user that the settings are not being applied.\n     - If the memory controller doesn't support changes to voltage on the\n       fly, one of the following return codes will be given:\n     - ::CTL_RESULT_ERROR_RESET_DEVICE_REQUIRED: The requested memory\n       overclock will be applied when the device is reset or the system is\n       rebooted. In this case, the overclock software should check if the\n       overclock request was applied after the reset/reboot. If it was and\n       when the overclock application shuts down gracefully and if the\n       overclock application wants the setting to be persistent, the\n       application should request the same overclock settings again so that\n       they will be applied on the next reset/reboot. If this is not done,\n       then every time the device is reset and overclock is requested, the\n       device needs to be reset a second time.\n     - ::CTL_RESULT_ERROR_FULL_REBOOT_REQUIRED: The requested memory\n       overclock will be applied when the system is rebooted. In this case,\n       the overclock software should check if the overclock request was\n       applied after the reboot. If it was and when the overclock application\n       shuts down gracefully and if the overclock application wants the\n       setting to be persistent, the application should request the same\n       overclock settings again so that they will be applied on the next\n       reset/reboot. If this is not done and the overclock setting is\n       requested after the reboot has occurred, a second reboot will be\n       required.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pVoltage`"]
    pub unsafe fn ctlOverclockVramVoltageOffsetGet(
        &self,
        hDeviceHandle: ctl_device_adapter_handle_t,
        pVoltage: *mut f64,
    ) -> ctl_result_t {
        (self.ctlOverclockVramVoltageOffsetGet)(hDeviceHandle, pVoltage)
    }
    #[doc = "\n @brief Set the Overclock Vram Voltage Offset in mV.\n\n @details\n     - The purpose of this function is to set the maximum sustained power\n       limit. If the average GPU power averaged over a few seconds exceeds\n       this value, the frequency of the GPU will be throttled.\n     - Set a value of 0 to disable this power limit. In this case, the GPU\n       frequency will not throttle due to average power but may hit other\n       limits.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`"]
    pub unsafe fn ctlOverclockVramVoltageOffsetSet(
        &self,
        hDeviceHandle: ctl_device_adapter_handle_t,
        voltage: f64,
    ) -> ctl_result_t {
        (self.ctlOverclockVramVoltageOffsetSet)(hDeviceHandle, voltage)
    }
    #[doc = "\n @brief Get the sustained power limit in mW.\n\n @details\n     - The purpose of this function is to read the current sustained power\n       limit.\n     - A value of 0 means that the limit is disabled - the GPU frequency can\n       run as high as possible until other limits are hit.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pSustainedPowerLimit`"]
    pub unsafe fn ctlOverclockPowerLimitGet(
        &self,
        hDeviceHandle: ctl_device_adapter_handle_t,
        pSustainedPowerLimit: *mut f64,
    ) -> ctl_result_t {
        (self.ctlOverclockPowerLimitGet)(hDeviceHandle, pSustainedPowerLimit)
    }
    #[doc = "\n @brief Set the sustained power limit in mW.\n\n @details\n     - The purpose of this function is to set the maximum sustained power\n       limit. If the average GPU power averaged over a few seconds exceeds\n       this value, the frequency of the GPU will be throttled.\n     - Set a value of 0 to disable this power limit. In this case, the GPU\n       frequency will not throttle due to average power but may hit other\n       limits.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`"]
    pub unsafe fn ctlOverclockPowerLimitSet(
        &self,
        hDeviceHandle: ctl_device_adapter_handle_t,
        sustainedPowerLimit: f64,
    ) -> ctl_result_t {
        (self.ctlOverclockPowerLimitSet)(hDeviceHandle, sustainedPowerLimit)
    }
    #[doc = "\n @brief Get the current temperature limit in Celsius.\n\n @details\n     - The purpose of this function is to read the current thermal limit.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pTemperatureLimit`"]
    pub unsafe fn ctlOverclockTemperatureLimitGet(
        &self,
        hDeviceHandle: ctl_device_adapter_handle_t,
        pTemperatureLimit: *mut f64,
    ) -> ctl_result_t {
        (self.ctlOverclockTemperatureLimitGet)(hDeviceHandle, pTemperatureLimit)
    }
    #[doc = "\n @brief Set the temperature limit in Celsius.\n\n @details\n     - The purpose of this function is to change the maximum thermal limit.\n       When the GPU temperature exceeds this value, the GPU frequency will be\n       throttled.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`"]
    pub unsafe fn ctlOverclockTemperatureLimitSet(
        &self,
        hDeviceHandle: ctl_device_adapter_handle_t,
        temperatureLimit: f64,
    ) -> ctl_result_t {
        (self.ctlOverclockTemperatureLimitSet)(hDeviceHandle, temperatureLimit)
    }
    #[doc = "\n @brief Get Power Telemetry.\n\n @details\n     - Limited rate of 50 ms, any call under 50 ms will return the same\n       information.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pTelemetryInfo`"]
    pub unsafe fn ctlPowerTelemetryGet(
        &self,
        hDeviceHandle: ctl_device_adapter_handle_t,
        pTelemetryInfo: *mut ctl_power_telemetry_t,
    ) -> ctl_result_t {
        (self.ctlPowerTelemetryGet)(hDeviceHandle, pTelemetryInfo)
    }
    #[doc = "\n @brief Reset all Overclock Settings to stock\n\n @details\n     - Reset all Overclock setting to default using single API call\n     - This request resets any changes made to GpuFrequencyOffset,\n       GpuVoltageOffset, PowerLimit, TemperatureLimit, GpuLock\n     - This Doesn't reset any Fan Curve Changes. It can be reset using\n       ctlFanSetDefaultMode\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`"]
    pub unsafe fn ctlOverclockResetToDefault(
        &self,
        hDeviceHandle: ctl_device_adapter_handle_t,
    ) -> ctl_result_t {
        (self.ctlOverclockResetToDefault)(hDeviceHandle)
    }
    #[doc = "\n @brief Get PCI properties - address, max speed\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pProperties`"]
    pub unsafe fn ctlPciGetProperties(
        &self,
        hDAhandle: ctl_device_adapter_handle_t,
        pProperties: *mut ctl_pci_properties_t,
    ) -> ctl_result_t {
        (self.ctlPciGetProperties)(hDAhandle, pProperties)
    }
    #[doc = "\n @brief Get current PCI state - current speed\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pState`"]
    pub unsafe fn ctlPciGetState(
        &self,
        hDAhandle: ctl_device_adapter_handle_t,
        pState: *mut ctl_pci_state_t,
    ) -> ctl_result_t {
        (self.ctlPciGetState)(hDAhandle, pState)
    }
    #[doc = "\n @brief Get handle of power domains\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCount`"]
    pub unsafe fn ctlEnumPowerDomains(
        &self,
        hDAhandle: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phPower: *mut ctl_pwr_handle_t,
    ) -> ctl_result_t {
        (self.ctlEnumPowerDomains)(hDAhandle, pCount, phPower)
    }
    #[doc = "\n @brief Get properties related to a power domain\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hPower`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pProperties`"]
    pub unsafe fn ctlPowerGetProperties(
        &self,
        hPower: ctl_pwr_handle_t,
        pProperties: *mut ctl_power_properties_t,
    ) -> ctl_result_t {
        (self.ctlPowerGetProperties)(hPower, pProperties)
    }
    #[doc = "\n @brief Get energy counter\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hPower`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pEnergy`"]
    pub unsafe fn ctlPowerGetEnergyCounter(
        &self,
        hPower: ctl_pwr_handle_t,
        pEnergy: *mut ctl_power_energy_counter_t,
    ) -> ctl_result_t {
        (self.ctlPowerGetEnergyCounter)(hPower, pEnergy)
    }
    #[doc = "\n @brief Get power limits\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hPower`"]
    pub unsafe fn ctlPowerGetLimits(
        &self,
        hPower: ctl_pwr_handle_t,
        pPowerLimits: *mut ctl_power_limits_t,
    ) -> ctl_result_t {
        (self.ctlPowerGetLimits)(hPower, pPowerLimits)
    }
    #[doc = "\n @brief Set power limits\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hPower`\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS\n         + User does not have permissions to make these modifications.\n     - ::CTL_RESULT_ERROR_NOT_AVAILABLE\n         + The device is in use, meaning that the GPU is under Over clocking, applying power limits under overclocking is not supported."]
    pub unsafe fn ctlPowerSetLimits(
        &self,
        hPower: ctl_pwr_handle_t,
        pPowerLimits: *const ctl_power_limits_t,
    ) -> ctl_result_t {
        (self.ctlPowerSetLimits)(hPower, pPowerLimits)
    }
    #[doc = "\n @brief Get handle of temperature sensors\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCount`"]
    pub unsafe fn ctlEnumTemperatureSensors(
        &self,
        hDAhandle: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phTemperature: *mut ctl_temp_handle_t,
    ) -> ctl_result_t {
        (self.ctlEnumTemperatureSensors)(hDAhandle, pCount, phTemperature)
    }
    #[doc = "\n @brief Get temperature sensor properties\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hTemperature`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pProperties`"]
    pub unsafe fn ctlTemperatureGetProperties(
        &self,
        hTemperature: ctl_temp_handle_t,
        pProperties: *mut ctl_temp_properties_t,
    ) -> ctl_result_t {
        (self.ctlTemperatureGetProperties)(hTemperature, pProperties)
    }
    #[doc = "\n @brief Get the temperature from a specified sensor\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hTemperature`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pTemperature`"]
    pub unsafe fn ctlTemperatureGetState(
        &self,
        hTemperature: ctl_temp_handle_t,
        pTemperature: *mut f64,
    ) -> ctl_result_t {
        (self.ctlTemperatureGetState)(hTemperature, pTemperature)
    }
}
